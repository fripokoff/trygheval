{
  "success": true,
  "data": [
    {
      "id": 8,
      "status": "active",
      "project_title": "Exam_rank_06",
      "finish": true,
      "attachments": [],
      "cursus_id": "1",
      "updated_at": "2023-07-31T22:00:00.000Z",
      "students": 1,
      "eval_points": 0,
      "time": 180,
      "mandatorySections": [
        {
          "description": {
            "EN": "# Levels\n\nPossible exercises:\n| Level 1                         | \n| ----------------------- |\n| mini_serv                   |",
            "FR": "# Niveaux\n\nExercices possibles:\n| Niveau 1                         | \n| ----------------------- |\n| mini_serv                   |"
          },
          "yes_no": false,
          "separator": "border-t-8",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "# Level 1\n\n---\n\n## mini_serv\n\n---\n\n### Subject:\n```text\nAssignment name  : mini_serv\nExpected files   : mini_serv.c\nAllowed functions: write, close, select, socket, accept, listen, send, recv, bind, strstr, malloc, realloc, free, calloc, bzero, atoi, sprintf, strlen, exit, strcpy, strcat, memset\n--------------------------------------------------------------------------------\n\nWrite a program that will listen for client to connect on a certain port on 127.0.0.1 and will let clients to speak with each other\n\nThis program will take as first argument the port to bind to\nIf no argument is given, it should write in stderr \"Wrong number of arguments\" followed by a \\n and exit with status 1\nIf a System Calls returns an error before the program start accepting connection, it should write in stderr \"Fatal error\" followed by a \\n and exit with status 1\nIf you cant allocate memory it should write in stderr \"Fatal error\" followed by a \\n and exit with status 1\n\nYour program must be non-blocking but client can be lazy and if they don't read your message you must NOT disconnect them...\n\nYour program must not contains #define preproc\nYour program must only listen to 127.0.0.1\nThe fd that you will receive will already be set to make 'recv' or 'send' to block if select hasn't be called before calling them, but will not block otherwise. \n\nWhen a client connect to the server:\n- the client will be given an id. the first client will receive the id 0 and each new client will received the last client id + 1\n- %d will be replace by this number\n- a message is sent to all the client that was connected to the server: \"server: client %d just arrived\\n\"\n\nclients must be able to send messages to your program.\n- message will only be printable characters, no need to check\n- a single message always end with a \\n\n- a single message will never be longer than 4096 characters\n- when the server receive a message, it must resend it to all the other client with \"client %d: \" before the message\n\nWhen a client disconnect from the server:\n- a message is sent to all the client that was connected to the server: \"server: client %d just left\\n\"\n\nMemory or fd leaks are forbidden\n\nTo help you, you will find the file main.c with the beginning of a server and maybe some useful functions. (Beware this file use forbidden functions or write things that must not be there in your final program)\n\nYou also have a nc executable in the subject folder which only connects to localhost in order to test your server.\n\nWarning our tester is expecting that you send the messages as fast as you can. Don't do un-necessary buffer.\n\nEvaluation can be a bit longer than usual...\n\nHint: you can use nc to test your program\nHint: you should use nc to test your program\nHint: To test you can use fcntl(fd, F_SETFL, O_NONBLOCK) but use select and NEVER check EAGAIN (man 2 send)\n```\n### Code:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\ntypedef struct s_client\n{\n\tint\t\tid;\n\tchar\tmsg[1000000];\n}\tt_client;\n\nt_client\tclients[2048];\nfd_set\t\twrite_set, read_set, current;\nint\t\t\tmaxfd = 0, gid = 0;\nchar\t\tsend_buffer[1000000], recv_buffer[1000000];\n\nvoid\terr(char *msg)\n{\n\tif (msg)\n\t\twrite(2, msg, strlen(msg));\n\telse\n\t\twrite(2, \"Fatal error\", 11);\n\twrite(2, \"\\n\", 1);\n\texit(1);\n}\n\nvoid\tsend_to_all(int except_fd)\n{\n\tfor (int fd = 0; fd <= maxfd; fd++)\n\t{\n\t\tif (FD_ISSET(fd, &write_set) && fd != except_fd)\n\t\t\tif (send(fd, send_buffer, strlen(send_buffer), 0) == -1)\n\t\t\t\terr(NULL);\n\t}\n}\n\nint\tmain(int argc, char **argv)\n{\n\tif (argc != 2)\n\t\terr(\"Wrong number of arguments\");\n\n\tstruct sockaddr_in\tserveraddr;\n\tsocklen_t\t\t\tlen;\n\n\tint\tserverfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (serverfd == -1) err(NULL);\n\tmaxfd = serverfd;\n\n\tFD_ZERO(&current);\n\tFD_SET(serverfd, &current);\n\tbzero(clients, sizeof(clients));\n\tbzero(&serveraddr, sizeof(serveraddr));\n\n\tserveraddr.sin_family = AF_INET;\n\tserveraddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tserveraddr.sin_port = htons(atoi(argv[1]));\n\n\tif (bind(serverfd, (const struct sockaddr *)&serveraddr, sizeof(serveraddr)) != 0\n\t\t|| listen(serverfd, 100) != 0)\n\t\terr(NULL);\n\n\twhile (1)\n\t{\n\t\tread_set = write_set = current;\n\t\tif (select(maxfd + 1, &read_set, &write_set, 0, 0) < 0)\n\t\t\terr(NULL);\n\n\t\tfor (int fd = 0; fd <= maxfd; fd++)\n\t\t{\n\t\t\tif (FD_ISSET(fd, &read_set))\n\t\t\t{\n\t\t\t\tif (fd == serverfd)\n\t\t\t\t{\n\t\t\t\t\tint clientfd = accept(serverfd, (struct sockaddr *)&serveraddr, &len);\n\t\t\t\t\tif (clientfd == -1) err(NULL);\n\t\t\t\t\tif (clientfd > maxfd) maxfd = clientfd;\n\t\t\t\t\tFD_SET(clientfd, &current);\n\t\t\t\t\tclients[clientfd].id = gid++;\n\t\t\t\t\tsprintf(send_buffer, \"server: client %d just arrived\\n\", clients[clientfd].id);\n\t\t\t\t\tsend_to_all(clientfd);\n\t\t\t\t\tbzero(send_buffer, sizeof(send_buffer));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint ret = recv(fd, recv_buffer, sizeof(recv_buffer), 0);\n\t\t\t\t\tif (ret <= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tsprintf(send_buffer, \"server: client %d just left\\n\", clients[fd].id);\n\t\t\t\t\t\tsend_to_all(fd);\n\t\t\t\t\t\tbzero(send_buffer, sizeof(send_buffer));\n\t\t\t\t\t\tFD_CLR(fd, &current);\n\t\t\t\t\t\tbzero(clients[fd].msg, sizeof(clients[fd].msg));\n\t\t\t\t\t\tclose(fd);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int i = 0, j = strlen(clients[fd].msg); i < ret; i++, j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tclients[fd].msg[j] = recv_buffer[i];\n\t\t\t\t\t\t\tif (clients[fd].msg[j] == '\\n')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tclients[fd].msg[j] = '\\0';\n\t\t\t\t\t\t\t\tsprintf(send_buffer, \"client %d: %s\\n\", clients[fd].id, clients[fd].msg);\n\t\t\t\t\t\t\t\tsend_to_all(fd);\n\t\t\t\t\t\t\t\tbzero(send_buffer, sizeof(send_buffer));\n\t\t\t\t\t\t\t\tbzero(clients[fd].msg, sizeof(clients[fd].msg));\n                                j = -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak ;\n\t\t\t}\n\t\t}\n\t}\n\treturn (0);\n}\n```\n\n### Code (other version):\n```c\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <netinet/in.h>\n\ntypedef struct client \n{\n    int fd;\n    int id;\n} client;\n\nvoid exit_error(char *str) \n{\n    write(2, str, strlen(str));\n    exit(1);\n}\n\nint main(int argc, char **argv)\n{\n    if (argc != 2) \n    {\n        exit_error(\"Wrong number of arguments\\n\");\n    }\n\n    const int MAX_CLIENTS = 128;\n    const int BUFFER_SIZE = 200000;\n    client clients[MAX_CLIENTS];\n    int next_id = 0;\n    fd_set active_sockets, ready_sockets;\n    char buffer[BUFFER_SIZE];\n    char msg_buffer[BUFFER_SIZE];\n    int server_socket;\n\n    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) \n    {\n        exit_error(\"Fatal error\\n\");\n    }\n\n    struct sockaddr_in server_address = {0};\n    server_address.sin_family = AF_INET;\n    server_address.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n    server_address.sin_port = htons(atoi(argv[1]));\n\n    if (bind(server_socket, (struct sockaddr *)&server_address, sizeof(server_address)) < 0) \n    {\n        exit_error(\"Fatal error\\n\");\n    }\n\n    if (listen(server_socket , MAX_CLIENTS) < 0) \n    {\n        exit_error(\"Fatal error\\n\");\n    }\n\n    bzero(clients, sizeof(client) * MAX_CLIENTS);\n    FD_ZERO(&active_sockets);\n    FD_SET(server_socket, &active_sockets);\n    int max_socket = server_socket;\n\n    while (42) {\n        ready_sockets = active_sockets;\n        if (select(max_socket + 1, &ready_sockets, NULL, NULL, NULL) < 0) \n        {\n            exit_error(\"Fatal error\\n\");\n        }\n        for (int socket_id = 0; socket_id <= max_socket; socket_id++) \n        {\n            if (!FD_ISSET(socket_id, &ready_sockets)) \n            {\n                continue ;\n            }\n            bzero(buffer, BUFFER_SIZE);\n            if (socket_id == server_socket) \n            {\n                int client_socket;\n\n                if ((client_socket = accept(server_socket, NULL, NULL)) < 0) \n                {\n                    exit_error(\"Fatal error\\n\");\n                }\n                FD_SET(client_socket, &active_sockets);\n                max_socket = (client_socket > max_socket) ? client_socket : max_socket;\n                clients[client_socket].fd = client_socket;\n                clients[client_socket].id = next_id++;\n                sprintf(buffer, \"server: client %d just arrived\\n\", clients[client_socket].id);\n                for (int i = 0; i < MAX_CLIENTS; i++) {\n                    if (clients[i].fd != 0 && clients[i].fd != client_socket) \n                    {\n                        send(clients[i].fd, buffer, strlen(buffer), 0);\n                    }\n                }\n            } else {\n                int bytes_read = recv(socket_id, buffer, sizeof(buffer) - 1, 0);\n\n                if (bytes_read <= 0) \n                {\n                    bzero(msg_buffer, BUFFER_SIZE);\n                    sprintf(msg_buffer, \"server: client %d just left\\n\", clients[socket_id].id);\n                    for (int i = 0; i < MAX_CLIENTS; i++) \n                    {\n                        if (clients[i].fd != socket_id && clients[i].fd != 0) \n                        {\n                            send(clients[i].fd, msg_buffer, strlen(msg_buffer), 0);\n                        }\n                    }\n                    close(socket_id);\n                    FD_CLR(socket_id, &active_sockets);\n                } else {\n                    bzero(msg_buffer, BUFFER_SIZE);\n                    sprintf(msg_buffer, \"client %d: %s\\n\", clients[socket_id].id, buffer);\n                    for (int i = 0; i < MAX_CLIENTS; i++) \n                    {\n                        if (clients[i].fd != socket_id) \n                        {\n                            send(clients[i].fd, msg_buffer, strlen(msg_buffer), 0);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}\n```",
            "FR": "# Niveau 1\n\n---\n\n## mini_serv\n\n---\n\n### Sujet :\n```text\nNom de l'assignation : mini_serv\nFichiers attendus : mini_serv.c\nFonctions autorisées : write, close, select, socket, accept, listen, send, recv, bind, strstr, malloc, realloc, free, calloc, bzero, atoi, sprintf, strlen, exit, strcpy, strcat, memset\n--------------------------------------------------------------------------------\n\nÉcrivez un programme qui écoutera les clients se connecter sur un certain port sur 127.0.0.1 et permettra aux clients de parler entre eux.\n\nCe programme prendra comme premier argument le port auquel se lier.\nSi aucun argument n'est donné, il doit écrire dans stderr \"Wrong number of arguments\" suivi d'un \\n et quitter avec le statut 1.\nSi un appel système renvoie une erreur avant que le programme ne commence à accepter les connexions, il doit écrire dans stderr \"Fatal error\" suivi d'un \\n et quitter avec le statut 1.\nSi vous ne pouvez pas allouer de mémoire, il doit écrire dans stderr \"Fatal error\" suivi d'un \\n et quitter avec le statut 1.\n\nVotre programme doit être non bloquant, mais les clients peuvent être paresseux et s'ils ne lisent pas votre message, vous ne devez PAS les déconnecter...\n\nVotre programme ne doit pas contenir de préprocesseur #define.\nVotre programme ne doit écouter que 127.0.0.1.\nLe fd que vous recevrez sera déjà configuré pour que 'recv' ou 'send' se bloquent si select n'a pas été appelé avant de les appeler, mais ne se bloquera pas autrement.\n\nLorsqu'un client se connecte au serveur :\n- le client recevra un identifiant. Le premier client recevra l'identifiant 0 et chaque nouveau client recevra l'identifiant du dernier client + 1.\n- %d sera remplacé par ce nombre.\n- un message est envoyé à tous les clients qui étaient connectés au serveur : \"server: client %d just arrived\\n\".\n\nLes clients doivent pouvoir envoyer des messages à votre programme.\n- les messages ne contiendront que des caractères imprimables, pas besoin de vérifier.\n- un seul message se termine toujours par un \\n.\n\n- un seul message ne dépassera jamais 4096 caractères.\n- lorsque le serveur reçoit un message, il doit le renvoyer à tous les autres clients avec \"client %d: \" avant le message.\n\nLorsqu'un client se déconnecte du serveur :\n- un message est envoyé à tous les clients qui étaient connectés au serveur : \"server: client %d just left\\n\".\n\nLes fuites de mémoire ou de fd sont interdites.\n\nPour vous aider, vous trouverez le fichier main.c avec le début d'un serveur et peut-être quelques fonctions utiles. (Attention, ce fichier utilise des fonctions interdites ou écrit des choses qui ne doivent pas figurer dans votre programme final)\n\nVous avez également un exécutable nc dans le dossier du sujet qui ne se connecte qu'à localhost afin de tester votre serveur.\n\nAttention, notre testeur s'attend à ce que vous envoyiez les messages aussi vite que possible. N'utilisez pas de buffer inutile.\n\nL'évaluation peut être un peu plus longue que d'habitude...\n\nAstuce : vous pouvez utiliser nc pour tester votre programme.\nAstuce : vous devriez utiliser nc pour tester votre programme.\nAstuce : Pour tester, vous pouvez utiliser fcntl(fd, F_SETFL, O_NONBLOCK) mais utilisez select et ne vérifiez JAMAIS EAGAIN (man 2 send).\n```\n### Code :\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\ntypedef struct s_client\n{\n\tint\t\tid;\n\tchar\tmsg[1000000];\n}\tt_client;\n\nt_client\tclients[2048];\nfd_set\t\twrite_set, read_set, current;\nint\t\t\tmaxfd = 0, gid = 0;\nchar\t\tsend_buffer[1000000], recv_buffer[1000000];\n\nvoid\terr(char *msg)\n{\n\tif (msg)\n\t\twrite(2, msg, strlen(msg));\n\telse\n\t\twrite(2, \"Fatal error\", 11);\n\twrite(2, \"\\n\", 1);\n\texit(1);\n}\n\nvoid\tsend_to_all(int except_fd)\n{\n\tfor (int fd = 0; fd <= maxfd; fd++)\n\t{\n\t\tif (FD_ISSET(fd, &write_set) && fd != except_fd)\n\t\t\tif (send(fd, send_buffer, strlen(send_buffer), 0) == -1)\n\t\t\t\terr(NULL);\n\t}\n}\n\nint\tmain(int argc, char **argv)\n{\n\tif (argc != 2)\n\t\terr(\"Wrong number of arguments\");\n\n\tstruct sockaddr_in\tserveraddr;\n\tsocklen_t\t\t\tlen;\n\n\tint\tserverfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (serverfd == -1) err(NULL);\n\tmaxfd = serverfd;\n\n\tFD_ZERO(&current);\n\tFD_SET(serverfd, &current);\n\tbzero(clients, sizeof(clients));\n\tbzero(&serveraddr, sizeof(serveraddr));\n\n\tserveraddr.sin_family = AF_INET;\n\tserveraddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tserveraddr.sin_port = htons(atoi(argv[1]));\n\n\tif (bind(serverfd, (const struct sockaddr *)&serveraddr, sizeof(serveraddr)) != 0\n\t\t|| listen(serverfd, 100) != 0)\n\t\terr(NULL);\n\n\twhile (1)\n\t{\n\t\tread_set = write_set = current;\n\t\tif (select(maxfd + 1, &read_set, &write_set, 0, 0) < 0)\n\t\t\terr(NULL);\n\n\t\tfor (int fd = 0; fd <= maxfd; fd++)\n\t\t{\n\t\t\tif (FD_ISSET(fd, &read_set))\n\t\t\t{\n\t\t\t\tif (fd == serverfd)\n\t\t\t\t{\n\t\t\t\t\tint clientfd = accept(serverfd, (struct sockaddr *)&serveraddr, &len);\n\t\t\t\t\tif (clientfd == -1) err(NULL);\n\t\t\t\t\tif (clientfd > maxfd) maxfd = clientfd;\n\t\t\t\t\tFD_SET(clientfd, &current);\n\t\t\t\t\tclients[clientfd].id = gid++;\n\t\t\t\t\tsprintf(send_buffer, \"server: client %d just arrived\\n\", clients[clientfd].id);\n\t\t\t\t\tsend_to_all(clientfd);\n\t\t\t\t\tbzero(send_buffer, sizeof(send_buffer));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint ret = recv(fd, recv_buffer, sizeof(recv_buffer), 0);\n\t\t\t\t\tif (ret <= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tsprintf(send_buffer, \"server: client %d just left\\n\", clients[fd].id);\n\t\t\t\t\t\tsend_to_all(fd);\n\t\t\t\t\t\tbzero(send_buffer, sizeof(send_buffer));\n\t\t\t\t\t\tFD_CLR(fd, &current);\n\t\t\t\t\t\tbzero(clients[fd].msg, sizeof(clients[fd].msg));\n\t\t\t\t\t\tclose(fd);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int i = 0, j = strlen(clients[fd].msg); i < ret; i++, j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tclients[fd].msg[j] = recv_buffer[i];\n\t\t\t\t\t\t\tif (clients[fd].msg[j] == '\\n')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tclients[fd].msg[j] = '\\0';\n\t\t\t\t\t\t\t\tsprintf(send_buffer, \"client %d: %s\\n\", clients[fd].id, clients[fd].msg);\n\t\t\t\t\t\t\t\tsend_to_all(fd);\n\t\t\t\t\t\t\t\tbzero(send_buffer, sizeof(send_buffer));\n\t\t\t\t\t\t\t\tbzero(clients[fd].msg, sizeof(clients[fd].msg));\n                                j = -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak ;\n\t\t\t}\n\t\t}\n\t}\n\treturn (0);\n}\n```\n\n### Code (autre version) :\n```c\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <netinet/in.h>\n\ntypedef struct client \n{\n    int fd;\n    int id;\n} client;\n\nvoid exit_error(char *str) \n{\n    write(2, str, strlen(str));\n    exit(1);\n}\n\nint main(int argc, char **argv)\n{\n    if (argc != 2) \n    {\n        exit_error(\"Wrong number of arguments\\n\");\n    }\n\n    const int MAX_CLIENTS = 128;\n    const int BUFFER_SIZE = 200000;\n    client clients[MAX_CLIENTS];\n    int next_id = 0;\n    fd_set active_sockets, ready_sockets;\n    char buffer[BUFFER_SIZE];\n    char msg_buffer[BUFFER_SIZE];\n    int server_socket;\n\n    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) \n    {\n        exit_error(\"Fatal error\\n\");\n    }\n\n    struct sockaddr_in server_address = {0};\n    server_address.sin_family = AF_INET;\n    server_address.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n    server_address.sin_port = htons(atoi(argv[1]));\n\n    if (bind(server_socket, (struct sockaddr *)&server_address, sizeof(server_address)) < 0) \n    {\n        exit_error(\"Fatal error\\n\");\n    }\n\n    if (listen(server_socket , MAX_CLIENTS) < 0) \n    {\n        exit_error(\"Fatal error\\n\");\n    }\n\n    bzero(clients, sizeof(client) * MAX_CLIENTS);\n    FD_ZERO(&active_sockets);\n    FD_SET(server_socket, &active_sockets);\n    int max_socket = server_socket;\n\n    while (42) {\n        ready_sockets = active_sockets;\n        if (select(max_socket + 1, &ready_sockets, NULL, NULL, NULL) < 0) \n        {\n            exit_error(\"Fatal error\\n\");\n        }\n        for (int socket_id = 0; socket_id <= max_socket; socket_id++) \n        {\n            if (!FD_ISSET(socket_id, &ready_sockets)) \n            {\n                continue ;\n            }\n            bzero(buffer, BUFFER_SIZE);\n            if (socket_id == server_socket) \n            {\n                int client_socket;\n\n                if ((client_socket = accept(server_socket, NULL, NULL)) < 0) \n                {\n                    exit_error(\"Fatal error\\n\");\n                }\n                FD_SET(client_socket, &active_sockets);\n                max_socket = (client_socket > max_socket) ? client_socket : max_socket;\n                clients[client_socket].fd = client_socket;\n                clients[client_socket].id = next_id++;\n                sprintf(buffer, \"server: client %d just arrived\\n\", clients[client_socket].id);\n                for (int i = 0; i < MAX_CLIENTS; i++) {\n                    if (clients[i].fd != 0 && clients[i].fd != client_socket) \n                    {\n                        send(clients[i].fd, buffer, strlen(buffer), 0);\n                    }\n                }\n            } else {\n                int bytes_read = recv(socket_id, buffer, sizeof(buffer) - 1, 0);\n\n                if (bytes_read <= 0) \n                {\n                    bzero(msg_buffer, BUFFER_SIZE);\n                    sprintf(msg_buffer, \"server: client %d just left\\n\", clients[socket_id].id);\n                    for (int i = 0; i < MAX_CLIENTS; i++) \n                    {\n                        if (clients[i].fd != socket_id && clients[i].fd != 0) \n                        {\n                            send(clients[i].fd, msg_buffer, strlen(msg_buffer), 0);\n                        }\n                    }\n                    close(socket_id);\n                    FD_CLR(socket_id, &active_sockets);\n                } else {\n                    bzero(msg_buffer, BUFFER_SIZE);\n                    sprintf(msg_buffer, \"client %d: %s\\n\", clients[socket_id].id, buffer);\n                    for (int i = 0; i < MAX_CLIENTS; i++) \n                    {\n                        if (clients[i].fd != socket_id) \n                        {\n                            send(clients[i].fd, msg_buffer, strlen(msg_buffer), 0);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}\n```"
          },
          "yes_no": false,
          "separator": false,
          "type": "mandatory"
        }
      ],
      "bonusSections": [],
      "gradingOptions": [
        {
          "ok": false,
          "outstanding": false,
          "empty_work": false,
          "incomplete_work": false,
          "invalid_compilation": false,
          "norme": false,
          "cheat": false,
          "crash": false,
          "concerning_situations": false,
          "leaks": false,
          "forbidden_functions": false,
          "cannot_support": false
        }
      ],
      "languages": [
        "EN",
        "FR"
      ],
      "language": "EN",
      "introduction": {
        "FR": "# Avant l'exam\nLes exams ont une durée de 3H. Ils sont théoriquement disponibles 2 fois par semaine :\n\n- Une session le mardi matin de 10h à 13h\n- Une deuxième le jeudi soir de 16h à 19h\n\nCependant ces dates peuvent être amenées à être modifiées selon les contraintes de la vie de l'école et du staff (piscine, events, etc...). Les événements disponibles sur votre intra font foi !\n\nLe cluster est précisé dans l'event de l'intra.\n\nVous devez toujours vous inscrire à l'évènement ET au projet.\n\nIl n'est pas possible de venir travailler en cluster d'examen sur un de ses projets pendant le déroulement d'un exam. Les tuteurs et tutrices sont responsables de la gestion de l'examen, et peuvent à tout moment vous demander de quitter le cluster si vous n'êtes pas inscrits à l'exam. \n\n---\n\n# Pendant l'exam\n\n- Si vous avez changé de mot de passe intra entre votre inscription et le début de l'exam, il faut utiliser votre ancien mot de passe.\n- Si votre exercice est faux, vous devez retenter le même exercice et cela jusqu'à sa validation.\n- Le temps entre chaque commande grademe devient incremental (suivant la suite de fibonnacci 1,2,3,5,8,13 etc.). Attention à bien tester avant de faire un grademe.",
        "EN": "# Before the exam\nExams last 3 hours. They are theoretically available twice a week:\n\n- One session on Tuesday morning from 10 a.m. to 1 p.m.\n- A second on Thursday evening from 4 p.m. to 7 p.m.\n\nHowever, these dates may be subject to change depending on the constraints of school life and staff (swimming pool, events, etc.). The events available on your intra are authoritative!\n\nThe cluster is specified in the intra event.\n\nYou must always register for the event AND the project.\n\nIt is not possible to come and work in an exam cluster on one of its projects during an exam. Tutors are responsible for managing the exam, and may ask you to leave the cluster at any time if you are not registered for the exam.\n\n---\n\n# During the exam\n\n- If you have changed your intra password between your registration and the start of the exam, you must use your old password.\n- If your exercise is wrong, you must try the same exercise again until it is validated.\n- The time between each grademe command becomes incremental (following the Fibonacci sequence 1,2,3,5,8,13 etc.). Be sure to test well before doing a grademe."
      },
      "guidelines": {
        "FR": "# Règles Exams Machine\n`\nTout manquement à l'une des règles suivantes entraînera l'exclusion de l'examen, la note -42 et pourra être suivi de sanction supplémentaire.\n`\n\n- L'entrée s'effectue dans le calme et sans précipitation.\n\n- A l'entrée, vous devrez présenter votre carte aux API, sans carte l'accès à la session d'examen vous sera refusé.\n\n- Il est interdit de se connecter sur sa session personnelle dans le cluster réservé pour l'exam, après y être entré et avant en être sorti.\n\n- Vous devez vous utiliser le login exam et le password exam.\n\n- Une fois l'examen commencé, il est interdit de rentrer dans la salle. Aucun retardataire ne sera admis.\n\n- Les téléphones, montres connectées et autres objets (connectés ou non) sont interdits, ils devront être éteint et rangé dans les sacs ou déposés dans la boîte à l'entrée du cluster. Pas en silencieux. Éteints.\n\n- Les écouteurs, filaires ou non, sont des objets connectés et doivent être rangés dans les sacs. Pas dans les poches, ni dans les oreilles.\n\n- Vous n'êtes autorisés à garder aucun objet sur vous (Ni dans vos poches). Sont uniquement autorisés sur votre bureau :\n  - Papier (3 feuilles max)\n  - un et un seul stylo/crayon\n  - une montre mécanique (== avec des aiguilles et rien d'autre)\n  - mouchoirs\n  - boule quiès\n\n- Les sacs et manteaux devront être déposés à l'endroit indiqué par les API.\n- Il est interdit de les déposer devant les extincteurs, sous les oeuvres et bouches d'aération.\n- Les cartes d'étudiant·e·s doivent être posées en évidence sur les tables.\n- Vos poches doivent être vides. Tout autre objet trouvé sur vous entraîne une suspicion de triche.\n- Tout périphérique personnel connecté (clavier, souris, etc) sont interdits en examen.\n- Vous avez le droit uniquement à des feuilles vierges volantes en guise de brouillon (pas de carnet), à un stylo ou un crayon, ainsi qu'une bouteille d'eau fermée au sol. Si vous avez besoin d'objets supplémentaires concernant votre santé, prévenez l'un de vos surveillants.\n- Vos feuilles doivent être vierges jusqu'au début de l'examen. Vous n'avez pas le droit de coder avant le début de l'examen.\n- Toute tentative de communication avec d'autres étudiant·e·s que ce soit oral, écrit ou autre est prohibée, ce sera considéré comme une tentative de triche et entrainera une sortie d'exam.\n- Il est interdit de se connecter avec les identifiants d'un autre étudiant.\n- Vous devez désactiver le son de vos iMac dès votre arrivée, une fois l'examen commencé toute personne faisant \"sonner\" volontairement son mac sera exclue de l'examen sans avertissement préalable.\n- Il est interdit de se déplacer, sauf pour quitter la session d'examen.\n- Les API ainsi que leurs décisions doivent être respectés.\n- Si vous souhaitez aller aux toilettes, vous devrez attendre qu'un API fasse une annonce. En cas d'extrême urgence, levez vous et attendez un API pour lui demander. Si vous êtes malade, prévenez l'un des surveillants.\n- Pour toute question, vous devrez vous LEVER ET ATTENDRE un API.\n- Les règles générales des clusters s'appliquent aux examens.\n- Vérifiez que vous n'oubliez rien en sortant, les cartes oubliées seront à récupérer au bocal, le reste sera rapporté aux objets trouvés.\n- Une fois l'examen terminé merci de faire preuve de respect en rangeant sa chaise, son clavier, sa souris et ses feuilles de brouillon, de déconnecter la session ouverte sur le poste et de sortir en silence.\n- Si vous avez des besoins spéciaux et que le staff a été mis au courant dites le dès le début aux surveillants.\n\n---\n**LES INFRACTIONS SUIVANTES ENTRAÎNERONT AUTOMATIQUEMENT, AU MOINS, UNE EXCLUSION DE L'EXAMEN:**\n- Communication orale/autre à qui que ce soit, même à soi même\n- Tout objet sur vous (sauf liste au dessus)\n- Appareil électronique allumé dans un sac\n- Se connecter avec l'identifiant d'un.e autre étudiant.e\n- Regarder un autre écran que le sien\n- Brouillon non vierge avant le début de l'examen\n- Commencer à coder avant le début de l'examen\n- Multiple récidive d'une même infraction\n- Le non-respect des gestes barrières contre le COVID en salle d'exam.",
        "EN": "# Machine Exams Rules\n`\nAny failure to comply with one of the following rules will result in exclusion from the exam, a mark of -42 and may be followed by additional sanctions.\n`\n\n- Entry must be done calmly and without rushing.\n\n- Upon entry, you will have to present your card to the APIs, without a card access to the exam session will be refused.\n\n- It is forbidden to connect to your personal session in the cluster reserved for the exam, after entering it and before leaving it.\n\n- You must use the exam login and the exam password.\n\n- Once the exam has started, it is forbidden to enter the room. No latecomers will be allowed.\n\n- Telephones, connected watches and other objects (connected or not) are prohibited, they must be switched off and stored in bags or placed in the box at the entrance to the cluster. Not in silent mode. Switched off.\n\n- Headphones, wired or not, are connected objects and must be stored in bags. Not in pockets, nor in ears.\n\n- You are not allowed to keep any objects on you (Nor in your pockets). Only the following are allowed on your desk:\n - Paper (3 sheets max)\n - one and only one pen/pencil\n - a mechanical watch (== with hands and nothing else)\n - handkerchiefs\n - earplugs\n\n- Bags and coats must be left in the place indicated by the APIs.\n- It is forbidden to place them in front of fire extinguishers, under works of art and ventilation openings.\n- Student cards must be placed visibly on the tables.\n- Your pockets must be empty. Any other object found on you will lead to suspicion of cheating.\n- Any personal connected device (keyboard, mouse, etc.) is prohibited in the exam.\n- You are only entitled to blank sheets of paper as a draft (no notebook), a pen or pencil, as well as a closed bottle of water on the floor. If you need additional items regarding your health, please notify one of your supervisors.\n- Your sheets must be blank until the start of the exam. You are not allowed to code before the start of the exam.\n- Any attempt to communicate with other students whether oral, written or otherwise is prohibited, this will be considered as an attempt to cheat and will result in an exam exit.\n- It is forbidden to connect with the identifiers of another student.\n- You must turn off the sound of your iMac as soon as you arrive, once the exam has started anyone who voluntarily makes their mac \"ring\" will be excluded from the exam without prior warning.\n- It is forbidden to move around, except to leave the exam session.\n- APIs and their decisions must be respected.\n- If you wish to go to the toilet, you will have to wait for an API to make an announcement. In case of extreme urgency, get up and wait for an API to ask him. If you are sick, notify one of the supervisors.\n- For any question, you will have to GET UP AND WAIT for an API.\n- The general rules of the clusters apply to exams.\n- Check that you don't forget anything when leaving, forgotten cards will have to be picked up at the bocal, the rest will be reported to the lost and found.\n- Once the exam is over, please show respect by tidying up your chair, keyboard, mouse and draft sheets, disconnecting the session open on the computer and leaving in silence.\n- If you have special needs and the staff has been informed, tell the supervisors from the beginning.\n\n---\n**THE FOLLOWING INFRACTIONS WILL AUTOMATICALLY RESULT IN, AT LEAST, EXCLUSION FROM THE EXAM:**\n- Oral/other communication to anyone, even to oneself\n- Any object on you (except list above)\n- Electronic device switched on in a bag\n- Connecting with the identifier of another student\n- Looking at another screen than your own\n- Non-blank draft before the start of the exam\n- Starting to code before the start of the exam\n- Multiple recidivism of the same offense\n- Failure to comply with barrier gestures against COVID in the exam room."
      }
    }
  ],
  "message": "Sheet created successfully"
}