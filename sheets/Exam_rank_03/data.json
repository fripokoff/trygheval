{
  "success": true,
  "data": [
    {
      "id": 12,
      "project_title": "Exam_rank_03",
      "students": 1,
      "milestone": 4,
      "hours": 3,
      "countHour" : false,
      "finish" : true,
      "eval_points": 0,
      "time": 180,
      "introduction": {
        "FR": "# Avant l'exam\nLes exams ont une durée de 3H. Ils sont théoriquement disponibles 2 fois par semaine :\n\n- Une session le mardi matin de 10h à 13h\n- Une deuxième le jeudi soir de 16h à 19h\n\nCependant ces dates peuvent être amenées à être modifiées selon les contraintes de la vie de l'école et du staff (piscine, events, etc...). Les événements disponibles sur votre intra font foi !\n\nLe cluster est précisé dans l'event de l'intra.\n\nVous devez toujours vous inscrire à l'évènement ET au projet.\n\nIl n'est pas possible de venir travailler en cluster d'examen sur un de ses projets pendant le déroulement d'un exam. Les tuteurs et tutrices sont responsables de la gestion de l'examen, et peuvent à tout moment vous demander de quitter le cluster si vous n'êtes pas inscrits à l'exam. \n\n---\n\n# Pendant l'exam\n\n- Si vous avez changé de mot de passe intra entre votre inscription et le début de l'exam, il faut utiliser votre ancien mot de passe.\n- Si votre exercice est faux, vous devez retenter le même exercice et cela jusqu'à sa validation.\n- Le temps entre chaque commande grademe devient incremental (suivant la suite de fibonnacci 1,2,3,5,8,13 etc.). Attention à bien tester avant de faire un grademe.",
        "EN": "# Before the exam\nExams last 3 hours. They are theoretically available twice a week:\n\n- One session on Tuesday morning from 10 a.m. to 1 p.m.\n- A second on Thursday evening from 4 p.m. to 7 p.m.\n\nHowever, these dates may be subject to change depending on the constraints of school life and staff (swimming pool, events, etc.). The events available on your intra are authoritative!\n\nThe cluster is specified in the intra event.\n\nYou must always register for the event AND the project.\n\nIt is not possible to come and work in an exam cluster on one of its projects during an exam. Tutors are responsible for managing the exam, and may ask you to leave the cluster at any time if you are not registered for the exam.\n\n---\n\n# During the exam\n\n- If you have changed your intra password between your registration and the start of the exam, you must use your old password.\n- If your exercise is wrong, you must try the same exercise again until it is validated.\n- The time between each grademe command becomes incremental (following the Fibonacci sequence 1,2,3,5,8,13 etc.). Be sure to test well before doing a grademe."
      },
      "languages": [
        "EN",
        "FR"
      ],
      "language": "EN",
      "guidelines": {
        "FR": "# Règles Exams Machine\n`\nTout manquement à l'une des règles suivantes entraînera l'exclusion de l'examen, la note -42 et pourra être suivi de sanction supplémentaire.\n`\n\n- L'entrée s'effectue dans le calme et sans précipitation.\n\n- A l'entrée, vous devrez présenter votre carte aux API, sans carte l'accès à la session d'examen vous sera refusé.\n\n- Il est interdit de se connecter sur sa session personnelle dans le cluster réservé pour l'exam, après y être entré et avant en être sorti.\n\n- Vous devez vous utiliser le login exam et le password exam.\n\n- Une fois l'examen commencé, il est interdit de rentrer dans la salle. Aucun retardataire ne sera admis.\n\n- Les téléphones, montres connectées et autres objets (connectés ou non) sont interdits, ils devront être éteint et rangé dans les sacs ou déposés dans la boîte à l'entrée du cluster. Pas en silencieux. Éteints.\n\n- Les écouteurs, filaires ou non, sont des objets connectés et doivent être rangés dans les sacs. Pas dans les poches, ni dans les oreilles.\n\n- Vous n'êtes autorisés à garder aucun objet sur vous (Ni dans vos poches). Sont uniquement autorisés sur votre bureau :\n  - Papier (3 feuilles max)\n  - un et un seul stylo/crayon\n  - une montre mécanique (== avec des aiguilles et rien d'autre)\n  - mouchoirs\n  - boule quiès\n\n- Les sacs et manteaux devront être déposés à l'endroit indiqué par les API.\n- Il est interdit de les déposer devant les extincteurs, sous les oeuvres et bouches d'aération.\n- Les cartes d'étudiant·e·s doivent être posées en évidence sur les tables.\n- Vos poches doivent être vides. Tout autre objet trouvé sur vous entraîne une suspicion de triche.\n- Tout périphérique personnel connecté (clavier, souris, etc) sont interdits en examen.\n- Vous avez le droit uniquement à des feuilles vierges volantes en guise de brouillon (pas de carnet), à un stylo ou un crayon, ainsi qu'une bouteille d'eau fermée au sol. Si vous avez besoin d'objets supplémentaires concernant votre santé, prévenez l'un de vos surveillants.\n- Vos feuilles doivent être vierges jusqu'au début de l'examen. Vous n'avez pas le droit de coder avant le début de l'examen.\n- Toute tentative de communication avec d'autres étudiant·e·s que ce soit oral, écrit ou autre est prohibée, ce sera considéré comme une tentative de triche et entrainera une sortie d'exam.\n- Il est interdit de se connecter avec les identifiants d'un autre étudiant.\n- Vous devez désactiver le son de vos iMac dès votre arrivée, une fois l'examen commencé toute personne faisant \"sonner\" volontairement son mac sera exclue de l'examen sans avertissement préalable.\n- Il est interdit de se déplacer, sauf pour quitter la session d'examen.\n- Les API ainsi que leurs décisions doivent être respectés.\n- Si vous souhaitez aller aux toilettes, vous devrez attendre qu'un API fasse une annonce. En cas d'extrême urgence, levez vous et attendez un API pour lui demander. Si vous êtes malade, prévenez l'un des surveillants.\n- Pour toute question, vous devrez vous LEVER ET ATTENDRE un API.\n- Les règles générales des clusters s'appliquent aux examens.\n- Vérifiez que vous n'oubliez rien en sortant, les cartes oubliées seront à récupérer au bocal, le reste sera rapporté aux objets trouvés.\n- Une fois l'examen terminé merci de faire preuve de respect en rangeant sa chaise, son clavier, sa souris et ses feuilles de brouillon, de déconnecter la session ouverte sur le poste et de sortir en silence.\n- Si vous avez des besoins spéciaux et que le staff a été mis au courant dites le dès le début aux surveillants.\n\n---\n**LES INFRACTIONS SUIVANTES ENTRAÎNERONT AUTOMATIQUEMENT, AU MOINS, UNE EXCLUSION DE L'EXAMEN:**\n- Communication orale/autre à qui que ce soit, même à soi même\n- Tout objet sur vous (sauf liste au dessus)\n- Appareil électronique allumé dans un sac\n- Se connecter avec l'identifiant d'un.e autre étudiant.e\n- Regarder un autre écran que le sien\n- Brouillon non vierge avant le début de l'examen\n- Commencer à coder avant le début de l'examen\n- Multiple récidive d'une même infraction\n- Le non-respect des gestes barrières contre le COVID en salle d'exam.",
        "EN": "# Machine Exams Rules\n`\nAny failure to comply with one of the following rules will result in exclusion from the exam, a mark of -42 and may be followed by additional sanctions.\n`\n\n- Entry must be done calmly and without rushing.\n\n- Upon entry, you will have to present your card to the APIs, without a card access to the exam session will be refused.\n\n- It is forbidden to connect to your personal session in the cluster reserved for the exam, after entering it and before leaving it.\n\n- You must use the exam login and the exam password.\n\n- Once the exam has started, it is forbidden to enter the room. No latecomers will be allowed.\n\n- Telephones, connected watches and other objects (connected or not) are prohibited, they must be switched off and stored in bags or placed in the box at the entrance to the cluster. Not in silent mode. Switched off.\n\n- Headphones, wired or not, are connected objects and must be stored in bags. Not in pockets, nor in ears.\n\n- You are not allowed to keep any objects on you (Nor in your pockets). Only the following are allowed on your desk:\n - Paper (3 sheets max)\n - one and only one pen/pencil\n - a mechanical watch (== with hands and nothing else)\n - handkerchiefs\n - earplugs\n\n- Bags and coats must be left in the place indicated by the APIs.\n- It is forbidden to place them in front of fire extinguishers, under works of art and ventilation openings.\n- Student cards must be placed visibly on the tables.\n- Your pockets must be empty. Any other object found on you will lead to suspicion of cheating.\n- Any personal connected device (keyboard, mouse, etc.) is prohibited in the exam.\n- You are only entitled to blank sheets of paper as a draft (no notebook), a pen or pencil, as well as a closed bottle of water on the floor. If you need additional items regarding your health, please notify one of your supervisors.\n- Your sheets must be blank until the start of the exam. You are not allowed to code before the start of the exam.\n- Any attempt to communicate with other students whether oral, written or otherwise is prohibited, this will be considered as an attempt to cheat and will result in an exam exit.\n- It is forbidden to connect with the identifiers of another student.\n- You must turn off the sound of your iMac as soon as you arrive, once the exam has started anyone who voluntarily makes their mac \"ring\" will be excluded from the exam without prior warning.\n- It is forbidden to move around, except to leave the exam session.\n- APIs and their decisions must be respected.\n- If you wish to go to the toilet, you will have to wait for an API to make an announcement. In case of extreme urgency, get up and wait for an API to ask him. If you are sick, notify one of the supervisors.\n- For any question, you will have to GET UP AND WAIT for an API.\n- The general rules of the clusters apply to exams.\n- Check that you don't forget anything when leaving, forgotten cards will have to be picked up at the bocal, the rest will be reported to the lost and found.\n- Once the exam is over, please show respect by tidying up your chair, keyboard, mouse and draft sheets, disconnecting the session open on the computer and leaving in silence.\n- If you have special needs and the staff has been informed, tell the supervisors from the beginning.\n\n---\n**THE FOLLOWING INFRACTIONS WILL AUTOMATICALLY RESULT IN, AT LEAST, EXCLUSION FROM THE EXAM:**\n- Oral/other communication to anyone, even to oneself\n- Any object on you (except list above)\n- Electronic device switched on in a bag\n- Connecting with the identifier of another student\n- Looking at another screen than your own\n- Non-blank draft before the start of the exam\n- Starting to code before the start of the exam\n- Multiple recidivism of the same offense\n- Failure to comply with barrier gestures against COVID in the exam room."
      },
      "mandatorySections": [
        {
          "description": {
            "EN": "# Levels\n\nPossible exercises:\n| Level 1                         | \n| ----------------------- |\n| ft_printf                      |\n| get_next_line             | \n",
            "FR": "# Niveaux\n\nExercices possibles :\n| Niveau 1                         | \n| ----------------------- |\n| ft_printf                      |\n| get_next_line             | \n"
          },
          "yes_no": false,
          "separator": "border-t-8",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "# Level 1\n\n---\n\n## ft_printf\n\n---\n\n### Subject:\n```text\nAssignment name  : ft_printf\nExpected files   : ft_printf.c\nAllowed functions: malloc, free, write, va_start, va_arg, va_copy, va_end\n--------------------------------------------------------------------------------\n\nWrite a function named `ft_printf` that will mimic the real printf but \nit will manage only the following conversions: s,d and x.\n\nYour function must be declared as follows:\n\nint ft_printf(const char *, ... );\n\nBefore you start we advise you to read the `man 3 printf` and the `man va_arg`.\nTo test your program compare your results with the true printf.\n\nExemples of the function output:\n\ncall: ft_printf(\"%s\\n\", \"toto\");\nout: toto$\n\ncall: ft_printf(\"Magic %s is %d\", \"number\", 42);\nout: Magic number is 42%\n\ncall: ft_printf(\"Hexadecimal for %d is %x\\n\", 42, 42);\nout: Hexadecimal for 42 is 2a$\n```\n### Code:\n```c\n#include <stdarg.h> // For va_lis, va_start, va_arg, va_copy, va_end\n#include <unistd.h> // For malloc, free, write\n\nvoid\tput_str(char *str, int *len)\n{\n\tif (!str)\n\t\tstr = \"(null)\";\n\twhile (*str)\n\t\t*len += write(1, str++, 1);\n}\n\nvoid\tput_digit(long long int nbr, int base, int *len)\n{\n\tif (nbr < 0)\n\t{\n\t\tnbr *= -1;\n\t\t*len += write(1, \"-\", 1);\n\t}\n\tif (nbr >= base)\n\t\tput_digit((nbr / base), base, len);\n\t*len += write(1, &\"0123456789abcdef\"[nbr % base], 1);\n}\n\nint\tft_printf(const char *format, ...)\n{\n\tint\t\t\tlen;\n\tva_list\t\tptr;\n\n\tlen = 0;\n\tva_start(ptr, format);\n\twhile (*format)\n\t{\n\t\tif ((*format == '%') && *(format + 1))\n\t\t{\n\t\t\tformat++;\n\t\t\tif (*format == 's')\n\t\t\t\tput_str(va_arg(ptr, char *), &len);\n\t\t\telse if (*format == 'd')\n\t\t\t\tput_digit((long long int)va_arg(ptr, int), 10, &len);\n\t\t\telse if (*format == 'x')\n\t\t\t\tput_digit((long long int)va_arg(ptr, unsigned int), 16, &len);\n\t\t}\n\t\telse\n\t\t\tlen += write(1, format, 1);\n\t\tformat++;\n\t}\n\treturn (va_end(ptr), len);\n}\n```\n### Code (other version):\n```c\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n\nvoid\tft_putnbr(int nb, int *count)\n{\n\tint div;\n\tint mod;\n\n\tdiv = nb / 10;\n\tmod = nb % 10;\n\tif (div)\n\t\tft_putnbr(div, count);\n\tif (nb < 0)\n\t{\n\t\tmod = -mod;\n\t\tif (!div)\n\t\t{\n\t\t\twrite(1, \"-\", 1);\n\t\t\t(*count)++;\n\t\t}\n\t}\n\tmod = mod + '0';\n\twrite(1, &mod, 1);\n\t(*count)++;\n}\n\nvoid\tft_putstr(const char *src, int *count)\n{\n\tif (!src)\n\t\tsrc = \"(null)\";\n\twhile(*src)\n\t{\n\t\twrite(1, src++, 1);\n\t\t(*count)++;\n\t}\n}\n\nvoid\tft_puthex(unsigned int nb, int *count)\n{\n\tchar\t*hex = \"0123456789abcdef\";\n\n\tif (nb >= 16)\n\t\tft_puthex(nb / 16, count);\n\twrite(1, &hex[nb % 16], 1);\n\t(*count)++;\n}\n\nint\tft_printf(const char *format, ...)\n{\n\tva_list args;\n\tint\tcount;\n\n\tva_start(args, format);\n\tcount = 0;\n\twhile(*format)\n\t{\n\t\tif (*format == '%' && *(format + 1))\n\t\t{\n\t\t\tformat++;\n\t\t\tif(*format == 'd')\n\t\t\t\tft_putnbr(va_arg(args, int), &count);\n\t\t\telse if(*format == 's')\n\t\t\t\tft_putstr(va_arg(args, char *), &count);\n\t\t\telse if(*format == 'x')\n\t\t\t\tft_puthex(va_arg(args, unsigned int), &count);\n\t\t\telse\n\t\t\t{\n\t\t\t\twrite(1, format, 1);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twrite(1, format, 1);\n\t\t\tcount++;\n\t\t}\n\t\tformat++;\n\t}\n\tva_end(args);\n\treturn (count);\n}\n\nint main ()\n{\n\tint cnt;\n\n\tcnt = ft_printf(\"%d\\n\", 42);\n\tprintf(\"cnt:%d\\n\" , cnt);\n\treturn 0;\n}\n```",
            "FR": "# Niveau 1\n\n---\n\n## ft_printf\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : ft_printf\nFichiers attendus : ft_printf.c\nFonctions autorisées : malloc, free, write, va_start, va_arg, va_copy, va_end\n--------------------------------------------------------------------------------\n\nÉcrivez une fonction nommée `ft_printf` qui imitera le vrai printf mais\nelle ne gérera que les conversions suivantes : s,d et x.\n\nVotre fonction doit être déclarée comme suit :\n\nint ft_printf(const char *, ... );\n\nAvant de commencer, nous vous conseillons de lire `man 3 printf` et `man va_arg`.\nPour tester votre programme, comparez vos résultats avec le vrai printf.\n\nExemples de sortie de la fonction :\n\nappel : ft_printf(\"%s\\n\", \"toto\");\nsortie : toto$\n\nappel : ft_printf(\"Magic %s is %d\", \"number\", 42);\nsortie : Magic number is 42%\n\nappel : ft_printf(\"Hexadecimal for %d is %x\\n\", 42, 42);\nsortie : Hexadecimal for 42 is 2a$\n```\n### Code:\n```c\n#include <stdarg.h> // Pour va_lis, va_start, va_arg, va_copy, va_end\n#include <unistd.h> // Pour malloc, free, write\n\nvoid\tput_str(char *str, int *len)\n{\n\tif (!str)\n\t\tstr = \"(null)\";\n\twhile (*str)\n\t\t*len += write(1, str++, 1);\n}\n\nvoid\tput_digit(long long int nbr, int base, int *len)\n{\n\tif (nbr < 0)\n\t{\n\t\tnbr *= -1;\n\t\t*len += write(1, \"-\", 1);\n\t}\n\tif (nbr >= base)\n\t\tput_digit((nbr / base), base, len);\n\t*len += write(1, &\"0123456789abcdef\"[nbr % base], 1);\n}\n\nint\tft_printf(const char *format, ...)\n{\n\tint\t\t\tlen;\n\tva_list\t\tptr;\n\n\tlen = 0;\n\tva_start(ptr, format);\n\twhile (*format)\n\t{\n\t\tif ((*format == '%') && *(format + 1))\n\t\t{\n\t\t\tformat++;\n\t\t\tif (*format == 's')\n\t\t\t\tput_str(va_arg(ptr, char *), &len);\n\t\t\telse if (*format == 'd')\n\t\t\t\tput_digit((long long int)va_arg(ptr, int), 10, &len);\n\t\t\telse if (*format == 'x')\n\t\t\t\tput_digit((long long int)va_arg(ptr, unsigned int), 16, &len);\n\t\t}\n\t\telse\n\t\t\tlen += write(1, format, 1);\n\t\tformat++;\n\t}\n\treturn (va_end(ptr), len);\n}\n```\n### Code (autre version):\n```c\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n\nvoid\tft_putnbr(int nb, int *count)\n{\n\tint div;\n\tint mod;\n\n\tdiv = nb / 10;\n\tmod = nb % 10;\n\tif (div)\n\t\tft_putnbr(div, count);\n\tif (nb < 0)\n\t{\n\t\tmod = -mod;\n\t\tif (!div)\n\t\t{\n\t\t\twrite(1, \"-\", 1);\n\t\t\t(*count)++;\n\t\t}\n\t}\n\tmod = mod + '0';\n\twrite(1, &mod, 1);\n\t(*count)++;\n}\n\nvoid\tft_putstr(const char *src, int *count)\n{\n\tif (!src)\n\t\tsrc = \"(null)\";\n\twhile(*src)\n\t{\n\t\twrite(1, src++, 1);\n\t\t(*count)++;\n\t}\n}\n\nvoid\tft_puthex(unsigned int nb, int *count)\n{\n\tchar\t*hex = \"0123456789abcdef\";\n\n\tif (nb >= 16)\n\t\tft_puthex(nb / 16, count);\n\twrite(1, &hex[nb % 16], 1);\n\t(*count)++;\n}\n\nint\tft_printf(const char *format, ...)\n{\n\tva_list args;\n\tint\tcount;\n\n\tva_start(args, format);\n\tcount = 0;\n\twhile(*format)\n\t{\n\t\tif (*format == '%' && *(format + 1))\n\t\t{\n\t\t\tformat++;\n\t\t\tif(*format == 'd')\n\t\t\t\tft_putnbr(va_arg(args, int), &count);\n\t\t\telse if(*format == 's')\n\t\t\t\tft_putstr(va_arg(args, char *), &count);\n\t\t\telse if(*format == 'x')\n\t\t\t\tft_puthex(va_arg(args, unsigned int), &count);\n\t\t\telse\n\t\t\t{\n\t\t\t\twrite(1, format, 1);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twrite(1, format, 1);\n\t\t\tcount++;\n\t\t}\n\t\tformat++;\n\t}\n\tva_end(args);\n\treturn (count);\n}\n\nint main ()\n{\n\tint cnt;\n\n\tcnt = ft_printf(\"%d\\n\", 42);\n\tprintf(\"cnt:%d\\n\" , cnt);\n\treturn 0;\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## get_next_line\n\n---\n\n### Subject:\n```text\nAssignment name : get_next_line\nExpected files : get_next_line.c\nAllowed functions: read, free, malloc\n--------------------------------------------------------------------------------\n\nWrite a function named get_next_line which prototype should be:\n\nchar *get_next_line(int fd);\n\n\nYour function must return a line that has been read from the file descriptor passed as parameter. What we call a \"line that has been read\" is a succesion of 0 to n characters that end with '\\n' (ascii code 0x0a) or with End Of File (EOF).\n\nThe line should be returned including the '\\n' in case there is one at the end of the line that has been read. When you've reached the EOF, you must store the current buffer in a char * and return it. If the buffer is empty you must return NULL.\n\nIn case of error return NULL. In case of not returning NULL, the pointer should be free-able. Your program will be compiled with the flag -D BUFFER_SIZE=xx, which has to be used as the buffer size for the read calls in your functions.\n\nYour function must be memory leak free. When you've reached the EOF, your function should keep 0 memory allocated with malloc, except the line that has been returned.\n\nCalling your function get_next_line in a loop will therefore allow you to read the text available on a file descriptor one line at a time until the end of the text, no matter the size od either the text or one of its lines.\n\nMake sure that your function behaves well when it reads from a file, from the standard output, from a redirection, etc...\n\nNo call to another function will be done on the file descriptor between 2 calls of get_next_line. Finally we consider that get_next_line has an undefined behaviour when reading from a binary file.\n```\n### Code:\n```c\n#include \"get_next_line.h\"\n\nchar\t*get_next_line(int fd)\n{\n\tint\t\ti;\n\tint\t\trd;\n\tchar\t*buf;\n\tchar\tc;\n\n\tif ((fd < 0) || (BUFFER_SIZE <= 0))\n\t\treturn (NULL);\n\ti = 0;\n\trd = read(fd, &c, 1);\n\tbuf = (char *)malloc(sizeof(char) * (BUFFER_SIZE + 1));\n\twhile (rd > 0)\n\t{\n\t\tbuf[i++] = c;\n\t\tif (c == '\\n')\n\t\t\tbreak ;\n\t\trd = read(fd, &c, 1);\n\t}\n\tif ((rd < 0) && (i == 0))\n\t\treturn (free(buf), NULL);\n\tbuf[i] = '\\0';\n\treturn (buf);\n}\n\nint main()\n{\n\tint i = 0;\n\tint a = open(\"a.txt\",O_RDWR,0);\n\tchar *b = get_next_line(a); \n\twhile(get_next_line(a))\n\t{\n\t\tprintf(\"%s\",get_next_line(a));\n\t}\n}\n```\n### Code .h (for make your test don't submit to exam!):\n```c\n#ifndef GET_NEXT_LINE_H\n# define GET_NEXT_LINE_H\n\n# include <unistd.h> //For write STDOUT_FILENO read\n# include <stdlib.h> //For EXIT_SUCCESS malloc free\n\n#ifndef BUFFER_SIZE\n# define BUFFER_SIZE 42\n#endif\n\nchar\t*get_next_line(int fd);\n\n#endif\n```\n### Code (other version):\n```c\n#include \"get_next_line.h\"\n\nchar\t*ft_strdup(const char *str)\n{\n\tint\ti;\n\tchar *rest;\n\n\ti = 0;\n\twhile(str[i])\n\t\ti++;\n\trest = malloc(sizeof(char) * (i + 1));\n\ti = 0;\n\twhile(str[i])\n\t{\n\t\trest[i] = str[i];\n\t\ti++;\n\t}\n\trest[i] = '\\0';\n\treturn (rest);\n}\n\nchar\t*get_next_line(int fd)\n{\n\tstatic int buf_pos;\n\tstatic int buf_read;\n\tstatic char buffer[BUFFER_SIZE];\n\tchar\tline[776767];\n\tint\ti;\n\n\ti = 0;\n\tif (fd < 0 || BUFFER_SIZE <= 0)\n\t\treturn(NULL);\n\twhile (777)\n\t{\n\t\tif (buf_pos >= buf_read)\n\t\t{\n\t\t\tbuf_read = read(fd, buffer, BUFFER_SIZE);\n\t\t\tbuf_pos = 0;\n\t\t\tif (buf_read <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tline[i++] = buffer[buf_pos++];\n\t\tif (buffer[buf_pos] == '\\n')\n\t\t\tbreak;\n\t}\n\tline[i] = '\\0';\n\tif (i == 0)\n\t\treturn (NULL);\n\treturn (ft_strdup(line));\n}\n\nint\tmain()\n{\n\tint fd = open(\"test\", O_RDONLY);\n\tint k = 0;\n\tchar\t*line;\n\twhile(k < 3)\n\t{\n\t\tline = get_next_line(fd);\n\t\tprintf(\"%s\\n\", line);\n\t\tfree(line);\n\t\tk++;\n\t}\n\treturn 0;\n}\n```",
            "FR": "## get_next_line\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : get_next_line\nFichiers attendus : get_next_line.c\nFonctions autorisées : read, free, malloc\n--------------------------------------------------------------------------------\n\nÉcrivez une fonction nommée get_next_line dont le prototype devrait être :\n\nchar *get_next_line(int fd);\n\nVotre fonction doit renvoyer une ligne qui a été lue à partir du descripteur de fichier passé en paramètre. Ce que nous appelons une \"ligne qui a été lue\" est une succession de 0 à n caractères qui se termine par '\\n' (code ascii 0x0a) ou par la fin de fichier (EOF).\n\nLa ligne doit être renvoyée en incluant le '\\n' au cas où il y en aurait un à la fin de la ligne qui a été lue. Lorsque vous avez atteint l'EOF, vous devez stocker le tampon actuel dans un char * et le renvoyer. Si le tampon est vide, vous devez renvoyer NULL.\n\nEn cas d'erreur, renvoyez NULL. Si vous ne renvoyez pas NULL, le pointeur doit être libérable. Votre programme sera compilé avec le drapeau -D BUFFER_SIZE=xx, qui doit être utilisé comme taille de tampon pour les appels de lecture dans vos fonctions.\n\nVotre fonction ne doit pas avoir de fuites de mémoire. Lorsque vous avez atteint l'EOF, votre fonction doit conserver 0 mémoire allouée avec malloc, à l'exception de la ligne qui a été renvoyée.\n\nAppeler votre fonction get_next_line dans une boucle vous permettra donc de lire le texte disponible sur un descripteur de fichier une ligne à la fois jusqu'à la fin du texte, quelle que soit la taille du texte ou de l'une de ses lignes.\n\nAssurez-vous que votre fonction se comporte bien lorsqu'elle lit à partir d'un fichier, à partir de la sortie standard, à partir d'une redirection, etc...\n\nAucun appel à une autre fonction ne sera effectué sur le descripteur de fichier entre 2 appels de get_next_line. Enfin, nous considérons que get_next_line a un comportement indéfini lors de la lecture à partir d'un fichier binaire.\n```\n### Code:\n```c\n#include \"get_next_line.h\"\n\nchar\t*get_next_line(int fd)\n{\n\tint\t\ti;\n\tint\t\trd;\n\tchar\t*buf;\n\tchar\tc;\n\n\tif ((fd < 0) || (BUFFER_SIZE <= 0))\n\t\treturn (NULL);\n\ti = 0;\n\trd = read(fd, &c, 1);\n\tbuf = (char *)malloc(sizeof(char) * (BUFFER_SIZE + 1));\n\twhile (rd > 0)\n\t{\n\t\tbuf[i++] = c;\n\t\tif (c == '\\n')\n\t\t\tbreak ;\n\t\trd = read(fd, &c, 1);\n\t}\n\tif ((rd < 0) && (i == 0))\n\t\treturn (free(buf), NULL);\n\tbuf[i] = '\\0';\n\treturn (buf);\n}\n\nint main()\n{\n\tint i = 0;\n\tint a = open(\"a.txt\",O_RDWR,0);\n\tchar *b = get_next_line(a); \n\twhile(get_next_line(a))\n\t{\n\t\tprintf(\"%s\",get_next_line(a));\n\t}\n}\n```\n### Code .h (pour faire vos tests, ne pas soumettre à l'examen !):\n```c\n#ifndef GET_NEXT_LINE_H\n# define GET_NEXT_LINE_H\n\n# include <unistd.h> //Pour write STDOUT_FILENO read\n# include <stdlib.h> //Pour EXIT_SUCCESS malloc free\n\n#ifndef BUFFER_SIZE\n# define BUFFER_SIZE 42\n#endif\n\nchar\t*get_next_line(int fd);\n\n#endif\n```\n### Code (autre version):\n```c\n#include \"get_next_line.h\"\n\nchar\t*ft_strdup(const char *str)\n{\n\tint\ti;\n\tchar *rest;\n\n\ti = 0;\n\twhile(str[i])\n\t\ti++;\n\trest = malloc(sizeof(char) * (i + 1));\n\ti = 0;\n\twhile(str[i])\n\t{\n\t\trest[i] = str[i];\n\t\ti++;\n\t}\n\trest[i] = '\\0';\n\treturn (rest);\n}\n\nchar\t*get_next_line(int fd)\n{\n\tstatic int buf_pos;\n\tstatic int buf_read;\n\tstatic char buffer[BUFFER_SIZE];\n\tchar\tline[776767];\n\tint\ti;\n\n\ti = 0;\n\tif (fd < 0 || BUFFER_SIZE <= 0)\n\t\treturn(NULL);\n\twhile (777)\n\t{\n\t\tif (buf_pos >= buf_read)\n\t\t{\n\t\t\tbuf_read = read(fd, buffer, BUFFER_SIZE);\n\t\t\tbuf_pos = 0;\n\t\t\tif (buf_read <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tline[i++] = buffer[buf_pos++];\n\t\tif (buffer[buf_pos] == '\\n')\n\t\t\tbreak;\n\t}\n\tline[i] = '\\0';\n\tif (i == 0)\n\t\treturn (NULL);\n\treturn (ft_strdup(line));\n}\n\nint\tmain()\n{\n\tint fd = open(\"test\", O_RDONLY);\n\tint k = 0;\n\tchar\t*line;\n\twhile(k < 3)\n\t{\n\t\tline = get_next_line(fd);\n\t\tprintf(\"%s\\n\", line);\n\t\tfree(line);\n\t\tk++;\n\t}\n\treturn 0;\n}\n```"
          },
          "yes_no": false,
          "separator": false,
          "type": "mandatory"
        }
      ],
      "bonusSections": [],
      "attachments": [],
      "updated_at": "2023-07-31T22:00:00.000Z",
      "gradingOptions": [
        {
          "ok": false,
          "outstanding": false,
          "empty_work": false,
          "incomplete_work": false,
          "invalid_compilation": false,
          "norme": false,
          "cheat": false,
          "crash": false,
          "concerning_situations": false,
          "leaks": false,
          "forbidden_functions": false,
          "cannot_support": false
        }
      ]
    }
  ],
  "message": "Sheet created successfully"
}