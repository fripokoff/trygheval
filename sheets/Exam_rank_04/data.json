{
  "success": true,
  "data": [
    {
      "id": 15,
      "milestone": 5,
      "hours": 3,
      "countHour" : false,
      "project_title": "Exam_rank_04",
      "finish": true,
      "attachments": [],
      "cursus_id": "1",
      "updated_at": "2023-07-31T22:00:00.000Z",
      "students": 1,
      "eval_points": 0,
      "time": 180,
      "mandatorySections": [
        {
          "description": {
            "EN": "# Levels\n\nPossible exercises:\n| Level 1                         | \n| ----------------------- |\n| microshell                   |",
            "FR": "# Niveaux\n\nExercices possibles :\n| Niveau 1                         | \n| ----------------------- |\n| microshell                      |"
          },
          "yes_no": false,
          "separator": "border-t-8",
          "type": "mandatory"
        },
        {
            "description": {
              "EN": "# Level 1\n\n---\n\n## microshell\n\n---\n\n### Subject:\n```text\nAssignment name  : microshell\nExpected files   : microshell.c\nAllowed functions: malloc, free, write, close, fork, waitpid, signal, kill, exit, chdir, execve, dup, dup2, pipe, strcmp, strncmp\n--------------------------------------------------------------------------------------\n\nWrite a program that will behave like executing a shell command\n- The command line to execute will be the arguments of this program\n- Executable's path will be absolute or relative but your program must not build a path (from the PATH variable for example)\n- You must implement \"|\" and \";\" like in bash\n\t- we will never try a \"|\" immediately followed or preceded by nothing or \"|\" or \";\"\n- Your program must implement the built-in command cd only with a path as argument (no '-' or without parameters)\n\t- if cd has the wrong number of argument your program should print in STDERR \"error: cd: bad arguments\" followed by a '\\n'\n\t- if cd failed your program should print in STDERR \"error: cd: cannot change directory to path_to_change\" followed by a '\\n' with path_to_change replaced by the argument to cd\n\t- a cd command will never be immediately followed or preceded by a \"|\"\n- You don't need to manage any type of wildcards (*, ~ etc...)\n- You don't need to manage environment variables ($BLA ...)\n- If a system call, except execve and chdir, returns an error your program should immediatly print \"error: fatal\" in STDERR followed by a '\\n' and the program should exit\n- If execve failed you should print \"error: cannot execute executable_that_failed\" in STDERR followed by a '\\n' with executable_that_failed replaced with the path of the failed executable (It should be the first argument of execve)\n- Your program should be able to manage more than hundreds of \"|\" even if we limit the number of \"open files\" to less than 30.\n\nfor example this should work:\n$>./microshell /bin/ls \"|\" /usr/bin/grep microshell \";\" /bin/echo i love my microshell\nmicroshell\ni love my microshell\n$>\n\nHints:\nDon't forget to pass the environment variable to execve\n\nHints:\nDo not leak file descriptors!\n```\n### Code:\n```c\n#include <unistd.h>     // write, chdir, dup2, close, execve\n#include <sys/wait.h>   // waitpid\n#include <stdlib.h>     // exit\n#include <string.h>     // strcmp\n\n// Function to print an error msg to stderr\nvoid ft_print_error(char *msg)\n{\n\twhile (*msg)\n\t\twrite(STDERR_FILENO, msg++, 1);\n}\n\n// Function to change directory\nint ft_execute_cd(char **arg, int arg_count)\n{\n\tif (arg_count != 2)\n\t\treturn (ft_print_error(\"error: cd: bad arg\\n\"), 1);\n\tif (chdir(arg[1]) == -1)\n\t\treturn (ft_print_error(\"error: cd: cannot change directory to \"), \\\n\t\t\tft_print_error(arg[1]), ft_print_error(\"\\n\"), 1);\n\treturn (0);\n}\n\n// Function to set up a pipe if needed\nvoid ft_configure_pipe(int has_pipe, int *pipe_fds, int end)\n{\n\tif (has_pipe && (dup2(pipe_fds[end], end) == -1 || \\\n\t\tclose(pipe_fds[0]) == -1 || close(pipe_fds[1]) == -1))\n\t\tft_print_error(\"error: fatal\\n\"), exit(EXIT_FAILURE);\n}\n\n// Function to execute commands and handle pipes\nint ft_execute_command(char **arg, int arg_count, char **env)\n{\n\tint has_pipe, pipe_fds[2], pid, code;\n\n\thas_pipe = arg[arg_count] && !strcmp(arg[arg_count], \"|\");\n\tif (!has_pipe && !strcmp(*arg, \"cd\"))\n\t\treturn (ft_execute_cd(arg, arg_count));\n\tif (has_pipe && pipe(pipe_fds) == -1)\n\t\tft_print_error(\"error: fatal\\n\"), exit(EXIT_FAILURE);\n\tif ((pid = fork()) == -1)\n\t\tft_print_error(\"error: fatal\\n\"), exit(EXIT_FAILURE);\n\tif (pid == 0)\n\t{\n\t\targ[arg_count] = NULL;\n\t\tft_configure_pipe(has_pipe, pipe_fds, STDOUT_FILENO);\n\t\tif (!strcmp(*arg, \"cd\"))\n\t\t\texit(ft_execute_cd(arg, arg_count));\n\t\texecve(arg[0], arg, env);\n\t\tft_print_error(\"error: cannot execute \"), ft_print_error(arg[0]), \\\n\t\tft_print_error(\"\\n\"), exit(EXIT_FAILURE);\n\t}\n\twaitpid(pid, &code, 0);\n\tft_configure_pipe(has_pipe, pipe_fds, STDIN_FILENO);\n\treturn (WIFEXITED(code) && WEXITcode(code));\n}\n\n// Main function to parse and execute commands\nint main(int argc, char **argv, char **env)\n{\n\t(void)argc;\n\tint index = 0, code = 0;\n\n\twhile (argv[index])\n\t{\n\t\targv += index + 1;\n\t\tindex = 0;\n\t\twhile (argv[index] && strcmp(argv[index], \"|\") && \\\n\t\tstrcmp(argv[index], \";\"))\n\t\t\tindex++;\n\t\tif (index)\n\t\t\tcode = ft_execute_command(argv, index, env);\n\t}\n\treturn (code);\n}\n```\n\n### Code (other version):\n```c\n#include <sys/wait.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint\tg_fd;\n\nstatic int\tprint(char *string)\n{\n\tint\tlength = 0;\n\n\twhile (string[length])\n\t\tlength++;\n\twrite(2, string, length);\n\treturn (1);\n}\n\nstatic int\texecutor(char **argv, int i, char **env)\n{\n\tint\tstatus;\n\tint\tfd[2];\n\tint\tpid;\n\tint\tnext = 0;\n\n\tif (argv[i] && strcmp(argv[i], \"|\") == 0)\n\t\tnext = 1;\n\tif (argv[i] == *argv)\n\t\treturn (0);\n\tif (pipe(fd) == -1)\n\t\treturn (print(\"error: fatal\\n\"));\n\tpid = fork();\n\tif (pid == -1)\n\t\treturn (print(\"error: fatal\\n\"));\n\telse if (pid == 0)\n\t{\n\t\tclose(fd[0]);\n\t\tdup2(g_fd, 0);\n\t\targv[i] = 0;\n\t\tif (next)\n\t\t\tdup2(fd[1], 1);\n\t\tif (g_fd != 0)\n\t\t\tclose(g_fd);\n\t\tclose(fd[1]);\n\t\tif (execve(*argv, argv, env) == -1)\n\t\t{\n\t\t\tprint(\"error: cannot execute \");\n\t\t\tprint(*argv);\n\t\t\tprint(\"\\n\");\n\t\t\texit(0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tclose(fd[1]);\n\t\twaitpid(pid, &status, 0);\n\t\tif (g_fd != 0)\n\t\t\tclose(g_fd);\n\t\tif (next)\n\t\t\tg_fd = dup(fd[0]);\n\t\tclose(fd[0]);\n\t}\n\treturn (0);\n}\n\nstatic int\tbuiltin_cd(char **argv)\n{\n\tif (argv[2] && strcmp(argv[2], \"|\") != 0 && strcmp(argv[2], \";\") != 0)\n\t\treturn (print(\"error: cd: bad arguments\\n\"));\n\tif (chdir(argv[1]) == -1)\n\t\treturn (print(\"error: cannot execute cd\\n\"));\n\treturn (0);\n}\n\nint\tmain(int argc, char **argv, char **env)\n{\n\tint\ti = 1;\n\n\tif (argc == 1)\n\t\treturn (0);\n\targv[argc] = 0;\n\twhile (argv[i - 1] && argv[i])\n\t{\n\t\targv = argv + i;\n\t\ti = 0;\n\t\twhile (argv[i] && strcmp(argv[i], \"|\") != 0 && strcmp(argv[i], \";\") != 0)\n\t\t\ti++;\n\t\tif (!strcmp(*argv, \"cd\"))\n\t\t\tbuiltin_cd(argv);\n\t\telse\n\t\t\texecutor(argv, i, env);\n\t\ti++;\n\t}\n}\n```",
              "FR": "# Niveau 1\n\n---\n\n## microshell\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : microshell\nFichiers attendus : microshell.c\nFonctions autorisées: malloc, free, write, close, fork, waitpid, signal, kill, exit, chdir, execve, dup, dup2, pipe, strcmp, strncmp\n--------------------------------------------------------------------------------------\n\nÉcrire un programme qui se comportera comme l'exécution d'une commande shell\n- La ligne de commande à exécuter sera les arguments de ce programme\n- Le chemin de l'exécutable sera absolu ou relatif, mais votre programme ne doit pas construire de chemin (à partir de la variable PATH par exemple)\n- Vous devez implémenter \"|\" et \";\" comme dans bash\n\t- nous n'essaierons jamais un \"|\" immédiatement suivi ou précédé de rien ou \"|\" ou \";\"\n- Votre programme doit implémenter la commande intégrée cd uniquement avec un chemin comme argument (pas de '-' ou sans paramètres)\n\t- si cd a le mauvais nombre d'arguments, votre programme doit afficher dans STDERR \"error: cd: bad arguments\" suivi d'un '\\n'\n\t- si cd échoue, votre programme doit afficher dans STDERR \"error: cd: cannot change directory to path_to_change\" suivi d'un '\\n' avec path_to_change remplacé par l'argument de cd\n\t- une commande cd ne sera jamais immédiatement suivie ou précédée d'un \"|\"\n- Vous n'avez pas besoin de gérer les types de caractères génériques (*, ~ etc...)\n- Vous n'avez pas besoin de gérer les variables d'environnement ($BLA ...)\n- Si un appel système, à l'exception de execve et chdir, renvoie une erreur, votre programme doit immédiatement afficher \"error: fatal\" dans STDERR suivi d'un '\\n' et le programme doit quitter\n- Si execve échoue, vous devez afficher \"error: cannot execute executable_that_failed\" dans STDERR suivi d'un '\\n' avec executable_that_failed remplacé par le chemin de l'exécutable ayant échoué (il doit s'agir du premier argument de execve)\n- Votre programme doit être capable de gérer plus de centaines de \"|\" même si nous limitons le nombre de \"fichiers ouverts\" à moins de 30.\n\npar exemple, cela devrait fonctionner :\n$>./microshell /bin/ls \"|\" /usr/bin/grep microshell \";\" /bin/echo i love my microshell\nmicroshell\ni love my microshell\n$>\n\nConseils :\nN'oubliez pas de transmettre la variable d'environnement à execve\n\nConseils :\nNe fuyez pas les descripteurs de fichiers !\n```\n### Code:\n```c\n#include <unistd.h>     // write, chdir, dup2, close, execve\n#include <sys/wait.h>   // waitpid\n#include <stdlib.h>     // exit\n#include <string.h>     // strcmp\n\n// Fonction pour afficher un message d'erreur sur stderr\nvoid ft_print_error(char *msg)\n{\n\twhile (*msg)\n\t\twrite(STDERR_FILENO, msg++, 1);\n}\n\n// Fonction pour changer de répertoire\nint ft_execute_cd(char **arg, int arg_count)\n{\n\tif (arg_count != 2)\n\t\treturn (ft_print_error(\"error: cd: bad arg\\n\"), 1);\n\tif (chdir(arg[1]) == -1)\n\t\treturn (ft_print_error(\"error: cd: cannot change directory to \"), \\\n\t\t\tft_print_error(arg[1]), ft_print_error(\"\\n\"), 1);\n\treturn (0);\n}\n\n// Fonction pour configurer un pipe si nécessaire\nvoid ft_configure_pipe(int has_pipe, int *pipe_fds, int end)\n{\n\tif (has_pipe && (dup2(pipe_fds[end], end) == -1 || \\\n\t\tclose(pipe_fds[0]) == -1 || close(pipe_fds[1]) == -1))\n\t\tft_print_error(\"error: fatal\\n\"), exit(EXIT_FAILURE);\n}\n\n// Fonction pour exécuter des commandes et gérer les pipes\nint ft_execute_command(char **arg, int arg_count, char **env)\n{\n\tint has_pipe, pipe_fds[2], pid, code;\n\n\thas_pipe = arg[arg_count] && !strcmp(arg[arg_count], \"|\");\n\tif (!has_pipe && !strcmp(*arg, \"cd\"))\n\t\treturn (ft_execute_cd(arg, arg_count));\n\tif (has_pipe && pipe(pipe_fds) == -1)\n\t\tft_print_error(\"error: fatal\\n\"), exit(EXIT_FAILURE);\n\tif ((pid = fork()) == -1)\n\t\tft_print_error(\"error: fatal\\n\"), exit(EXIT_FAILURE);\n\tif (pid == 0)\n\t{\n\t\targ[arg_count] = NULL;\n\t\tft_configure_pipe(has_pipe, pipe_fds, STDOUT_FILENO);\n\t\tif (!strcmp(*arg, \"cd\"))\n\t\t\texit(ft_execute_cd(arg, arg_count));\n\t\texecve(arg[0], arg, env);\n\t\tft_print_error(\"error: cannot execute \"), ft_print_error(arg[0]), \\\n\t\tft_print_error(\"\\n\"), exit(EXIT_FAILURE);\n\t}\n\twaitpid(pid, &code, 0);\n\tft_configure_pipe(has_pipe, pipe_fds, STDIN_FILENO);\n\treturn (WIFEXITED(code) && WEXITcode(code));\n}\n\n// Fonction principale pour analyser et exécuter les commandes\nint main(int argc, char **argv, char **env)\n{\n\t(void)argc;\n\tint index = 0, code = 0;\n\n\twhile (argv[index])\n\t{\n\t\targv += index + 1;\n\t\tindex = 0;\n\t\twhile (argv[index] && strcmp(argv[index], \"|\") && \\\n\t\tstrcmp(argv[index], \";\"))\n\t\t\tindex++;\n\t\tif (index)\n\t\t\tcode = ft_execute_command(argv, index, env);\n\t}\n\treturn (code);\n}\n```\n\n### Code (autre version):\n```c\n#include <sys/wait.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint\tg_fd;\n\nstatic int\tprint(char *string)\n{\n\tint\tlength = 0;\n\n\twhile (string[length])\n\t\tlength++;\n\twrite(2, string, length);\n\treturn (1);\n}\n\nstatic int\texecutor(char **argv, int i, char **env)\n{\n\tint\tstatus;\n\tint\tfd[2];\n\tint\tpid;\n\tint\tnext = 0;\n\n\tif (argv[i] && strcmp(argv[i], \"|\") == 0)\n\t\tnext = 1;\n\tif (argv[i] == *argv)\n\t\treturn (0);\n\tif (pipe(fd) == -1)\n\t\treturn (print(\"error: fatal\\n\"));\n\tpid = fork();\n\tif (pid == -1)\n\t\treturn (print(\"error: fatal\\n\"));\n\telse if (pid == 0)\n\t{\n\t\tclose(fd[0]);\n\t\tdup2(g_fd, 0);\n\t\targv[i] = 0;\n\t\tif (next)\n\t\t\tdup2(fd[1], 1);\n\t\tif (g_fd != 0)\n\t\t\tclose(g_fd);\n\t\tclose(fd[1]);\n\t\tif (execve(*argv, argv, env) == -1)\n\t\t{\n\t\t\tprint(\"error: cannot execute \");\n\t\t\tprint(*argv);\n\t\t\tprint(\"\\n\");\n\t\t\texit(0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tclose(fd[1]);\n\t\twaitpid(pid, &status, 0);\n\t\tif (g_fd != 0)\n\t\t\tclose(g_fd);\n\t\tif (next)\n\t\t\tg_fd = dup(fd[0]);\n\t\tclose(fd[0]);\n\t}\n\treturn (0);\n}\n\nstatic int\tbuiltin_cd(char **argv)\n{\n\tif (argv[2] && strcmp(argv[2], \"|\") != 0 && strcmp(argv[2], \";\") != 0)\n\t\treturn (print(\"error: cd: bad arguments\\n\"));\n\tif (chdir(argv[1]) == -1)\n\t\treturn (print(\"error: cannot execute cd\\n\"));\n\treturn (0);\n}\n\nint\tmain(int argc, char **argv, char **env)\n{\n\tint\ti = 1;\n\n\tif (argc == 1)\n\t\treturn (0);\n\targv[argc] = 0;\n\twhile (argv[i - 1] && argv[i])\n\t{\n\t\targv = argv + i;\n\t\ti = 0;\n\t\twhile (argv[i] && strcmp(argv[i], \"|\") != 0 && strcmp(argv[i], \";\") != 0)\n\t\t\ti++;\n\t\tif (!strcmp(*argv, \"cd\"))\n\t\t\tbuiltin_cd(argv);\n\t\telse\n\t\t\texecutor(argv, i, env);\n\t\ti++;\n\t}\n}\n```"
            },
          "yes_no": false,
          "separator": false,
          "type": "mandatory"
        }
      ],
      "bonusSections": [],
      "gradingOptions": [
        {
          "ok": false,
          "outstanding": false,
          "empty_work": false,
          "incomplete_work": false,
          "invalid_compilation": false,
          "norme": false,
          "cheat": false,
          "crash": false,
          "concerning_situations": false,
          "leaks": false,
          "forbidden_functions": false,
          "cannot_support": false
        }
      ],
      "languages": [
        "EN",
        "FR"
      ],
      "language": "EN",
      "introduction": {
        "FR": "# Avant l'exam\nLes exams ont une durée de 3H. Ils sont théoriquement disponibles 2 fois par semaine :\n\n- Une session le mardi matin de 10h à 13h\n- Une deuxième le jeudi soir de 16h à 19h\n\nCependant ces dates peuvent être amenées à être modifiées selon les contraintes de la vie de l'école et du staff (piscine, events, etc...). Les événements disponibles sur votre intra font foi !\n\nLe cluster est précisé dans l'event de l'intra.\n\nVous devez toujours vous inscrire à l'évènement ET au projet.\n\nIl n'est pas possible de venir travailler en cluster d'examen sur un de ses projets pendant le déroulement d'un exam. Les tuteurs et tutrices sont responsables de la gestion de l'examen, et peuvent à tout moment vous demander de quitter le cluster si vous n'êtes pas inscrits à l'exam. \n\n---\n\n# Pendant l'exam\n\n- Si vous avez changé de mot de passe intra entre votre inscription et le début de l'exam, il faut utiliser votre ancien mot de passe.\n- Si votre exercice est faux, vous devez retenter le même exercice et cela jusqu'à sa validation.\n- Le temps entre chaque commande grademe devient incremental (suivant la suite de fibonnacci 1,2,3,5,8,13 etc.). Attention à bien tester avant de faire un grademe.",
        "EN": "# Before the exam\nExams last 3 hours. They are theoretically available twice a week:\n\n- One session on Tuesday morning from 10 a.m. to 1 p.m.\n- A second on Thursday evening from 4 p.m. to 7 p.m.\n\nHowever, these dates may be subject to change depending on the constraints of school life and staff (swimming pool, events, etc.). The events available on your intra are authoritative!\n\nThe cluster is specified in the intra event.\n\nYou must always register for the event AND the project.\n\nIt is not possible to come and work in an exam cluster on one of its projects during an exam. Tutors are responsible for managing the exam, and may ask you to leave the cluster at any time if you are not registered for the exam.\n\n---\n\n# During the exam\n\n- If you have changed your intra password between your registration and the start of the exam, you must use your old password.\n- If your exercise is wrong, you must try the same exercise again until it is validated.\n- The time between each grademe command becomes incremental (following the Fibonacci sequence 1,2,3,5,8,13 etc.). Be sure to test well before doing a grademe."
      },
      "guidelines": {
        "FR": "# Règles Exams Machine\n`\nTout manquement à l'une des règles suivantes entraînera l'exclusion de l'examen, la note -42 et pourra être suivi de sanction supplémentaire.\n`\n\n- L'entrée s'effectue dans le calme et sans précipitation.\n\n- A l'entrée, vous devrez présenter votre carte aux API, sans carte l'accès à la session d'examen vous sera refusé.\n\n- Il est interdit de se connecter sur sa session personnelle dans le cluster réservé pour l'exam, après y être entré et avant en être sorti.\n\n- Vous devez vous utiliser le login exam et le password exam.\n\n- Une fois l'examen commencé, il est interdit de rentrer dans la salle. Aucun retardataire ne sera admis.\n\n- Les téléphones, montres connectées et autres objets (connectés ou non) sont interdits, ils devront être éteint et rangé dans les sacs ou déposés dans la boîte à l'entrée du cluster. Pas en silencieux. Éteints.\n\n- Les écouteurs, filaires ou non, sont des objets connectés et doivent être rangés dans les sacs. Pas dans les poches, ni dans les oreilles.\n\n- Vous n'êtes autorisés à garder aucun objet sur vous (Ni dans vos poches). Sont uniquement autorisés sur votre bureau :\n  - Papier (3 feuilles max)\n  - un et un seul stylo/crayon\n  - une montre mécanique (== avec des aiguilles et rien d'autre)\n  - mouchoirs\n  - boule quiès\n\n- Les sacs et manteaux devront être déposés à l'endroit indiqué par les API.\n- Il est interdit de les déposer devant les extincteurs, sous les oeuvres et bouches d'aération.\n- Les cartes d'étudiant·e·s doivent être posées en évidence sur les tables.\n- Vos poches doivent être vides. Tout autre objet trouvé sur vous entraîne une suspicion de triche.\n- Tout périphérique personnel connecté (clavier, souris, etc) sont interdits en examen.\n- Vous avez le droit uniquement à des feuilles vierges volantes en guise de brouillon (pas de carnet), à un stylo ou un crayon, ainsi qu'une bouteille d'eau fermée au sol. Si vous avez besoin d'objets supplémentaires concernant votre santé, prévenez l'un de vos surveillants.\n- Vos feuilles doivent être vierges jusqu'au début de l'examen. Vous n'avez pas le droit de coder avant le début de l'examen.\n- Toute tentative de communication avec d'autres étudiant·e·s que ce soit oral, écrit ou autre est prohibée, ce sera considéré comme une tentative de triche et entrainera une sortie d'exam.\n- Il est interdit de se connecter avec les identifiants d'un autre étudiant.\n- Vous devez désactiver le son de vos iMac dès votre arrivée, une fois l'examen commencé toute personne faisant \"sonner\" volontairement son mac sera exclue de l'examen sans avertissement préalable.\n- Il est interdit de se déplacer, sauf pour quitter la session d'examen.\n- Les API ainsi que leurs décisions doivent être respectés.\n- Si vous souhaitez aller aux toilettes, vous devrez attendre qu'un API fasse une annonce. En cas d'extrême urgence, levez vous et attendez un API pour lui demander. Si vous êtes malade, prévenez l'un des surveillants.\n- Pour toute question, vous devrez vous LEVER ET ATTENDRE un API.\n- Les règles générales des clusters s'appliquent aux examens.\n- Vérifiez que vous n'oubliez rien en sortant, les cartes oubliées seront à récupérer au bocal, le reste sera rapporté aux objets trouvés.\n- Une fois l'examen terminé merci de faire preuve de respect en rangeant sa chaise, son clavier, sa souris et ses feuilles de brouillon, de déconnecter la session ouverte sur le poste et de sortir en silence.\n- Si vous avez des besoins spéciaux et que le staff a été mis au courant dites le dès le début aux surveillants.\n\n---\n**LES INFRACTIONS SUIVANTES ENTRAÎNERONT AUTOMATIQUEMENT, AU MOINS, UNE EXCLUSION DE L'EXAMEN:**\n- Communication orale/autre à qui que ce soit, même à soi même\n- Tout objet sur vous (sauf liste au dessus)\n- Appareil électronique allumé dans un sac\n- Se connecter avec l'identifiant d'un.e autre étudiant.e\n- Regarder un autre écran que le sien\n- Brouillon non vierge avant le début de l'examen\n- Commencer à coder avant le début de l'examen\n- Multiple récidive d'une même infraction\n- Le non-respect des gestes barrières contre le COVID en salle d'exam.",
        "EN": "# Machine Exams Rules\n`\nAny failure to comply with one of the following rules will result in exclusion from the exam, a mark of -42 and may be followed by additional sanctions.\n`\n\n- Entry must be done calmly and without rushing.\n\n- Upon entry, you will have to present your card to the APIs, without a card access to the exam session will be refused.\n\n- It is forbidden to connect to your personal session in the cluster reserved for the exam, after entering it and before leaving it.\n\n- You must use the exam login and the exam password.\n\n- Once the exam has started, it is forbidden to enter the room. No latecomers will be allowed.\n\n- Telephones, connected watches and other objects (connected or not) are prohibited, they must be switched off and stored in bags or placed in the box at the entrance to the cluster. Not in silent mode. Switched off.\n\n- Headphones, wired or not, are connected objects and must be stored in bags. Not in pockets, nor in ears.\n\n- You are not allowed to keep any objects on you (Nor in your pockets). Only the following are allowed on your desk:\n - Paper (3 sheets max)\n - one and only one pen/pencil\n - a mechanical watch (== with hands and nothing else)\n - handkerchiefs\n - earplugs\n\n- Bags and coats must be left in the place indicated by the APIs.\n- It is forbidden to place them in front of fire extinguishers, under works of art and ventilation openings.\n- Student cards must be placed visibly on the tables.\n- Your pockets must be empty. Any other object found on you will lead to suspicion of cheating.\n- Any personal connected device (keyboard, mouse, etc.) is prohibited in the exam.\n- You are only entitled to blank sheets of paper as a draft (no notebook), a pen or pencil, as well as a closed bottle of water on the floor. If you need additional items regarding your health, please notify one of your supervisors.\n- Your sheets must be blank until the start of the exam. You are not allowed to code before the start of the exam.\n- Any attempt to communicate with other students whether oral, written or otherwise is prohibited, this will be considered as an attempt to cheat and will result in an exam exit.\n- It is forbidden to connect with the identifiers of another student.\n- You must turn off the sound of your iMac as soon as you arrive, once the exam has started anyone who voluntarily makes their mac \"ring\" will be excluded from the exam without prior warning.\n- It is forbidden to move around, except to leave the exam session.\n- APIs and their decisions must be respected.\n- If you wish to go to the toilet, you will have to wait for an API to make an announcement. In case of extreme urgency, get up and wait for an API to ask him. If you are sick, notify one of the supervisors.\n- For any question, you will have to GET UP AND WAIT for an API.\n- The general rules of the clusters apply to exams.\n- Check that you don't forget anything when leaving, forgotten cards will have to be picked up at the bocal, the rest will be reported to the lost and found.\n- Once the exam is over, please show respect by tidying up your chair, keyboard, mouse and draft sheets, disconnecting the session open on the computer and leaving in silence.\n- If you have special needs and the staff has been informed, tell the supervisors from the beginning.\n\n---\n**THE FOLLOWING INFRACTIONS WILL AUTOMATICALLY RESULT IN, AT LEAST, EXCLUSION FROM THE EXAM:**\n- Oral/other communication to anyone, even to oneself\n- Any object on you (except list above)\n- Electronic device switched on in a bag\n- Connecting with the identifier of another student\n- Looking at another screen than your own\n- Non-blank draft before the start of the exam\n- Starting to code before the start of the exam\n- Multiple recidivism of the same offense\n- Failure to comply with barrier gestures against COVID in the exam room."
      }
    }
  ],
  "message": "Sheet created successfully"
}