{
  "success": true,
  "data": [
    {
      "id": 5,
      "milestone": 3,
      "hours": 3,
      "countHour" : false,	
      "project_title": "Exam_rank_02",
      "finish": true,
      "attachments": [],
      "cursus_id": "1",
      "updated_at": "2023-07-31T22:00:00.000Z",
      "students": 1,
      "eval_points": 0,
      "time": 180,
      "mandatorySections": [
        {
          "description": {
            "EN": "# Levels\n\nPossible exercises:\n| Level 1                         |  Level 2               |  Level 3                |  Level 4               |\n| ----------------------- | ------------------ | ------------------ | ------------------ |\n| first_word                   | alpha_mirror      | epur_str              | fprime                 |\n| fizzbuzz                       | camel_to_snake | expand_str         | ft_itoa                 |\n| ft_strcpy                     | ft_atoi                  | ft_atoi_base       | ft_list_foreach   |\n| repeat_alpha             | ft_strcmp             | ft_list_size          | ft_split                |\n| rev_print                    | ft_strcspn             | hidenp                | rev_wstr             |\n| rot_13                         | ft_strdup               | lcm                      | rostring              |\n| rotone                        | ft_strpbrk             | paramsum          | sort_int_tab       |\n| search_and_replace | ft_strrev                | pgcd                    | sort_list              |\n| ulstr                           | is_power_of_2      | print_hex            |                             |\n|                                    | last_word              | rstr_capitalizer   |                             |\n|                                    | max                        | str_capitalizer    |                             |\n|                                    | reverse_bits          | tab_mult             |                             |\n|                                    | snake_to_camel    |                             |                             |\n|                                    | swap_bits             |                              |                             |",
            "FR": "# Niveaux\n\nExercices possibles :\n| Level 1                         |  Level 2               |  Level 3                |  Level 4               |\n| ----------------------- | ------------------ | ------------------ | ------------------ |\n| first_word                   | alpha_mirror      | epur_str              | fprime                 |\n| fizzbuzz                       | camel_to_snake | expand_str         | ft_itoa                 |\n| ft_strcpy                     | ft_atoi                  | ft_atoi_base       | ft_list_foreach   |\n| repeat_alpha             | ft_strcmp             | ft_list_size          | ft_split                |\n| rev_print                    | ft_strcspn             | hidenp                | rev_wstr             |\n| rot_13                         | ft_strdup               | lcm                      | rostring              |\n| rotone                        | ft_strpbrk             | paramsum          | sort_int_tab       |\n| search_and_replace | ft_strrev                | pgcd                    | sort_list              |\n| ulstr                           | is_power_of_2      | print_hex            |                             |\n|                                    | last_word              | rstr_capitalizer   |                             |\n|                                    | max                        | str_capitalizer    |                             |\n|                                    | reverse_bits          | tab_mult             |                             |\n|                                    | snake_to_camel    |                             |                             |\n|                                    | swap_bits             |                              |                             |"
          },
          "yes_no": false,
          "separator": "border-t-8",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "# Level 1\n\n---\n\n## first_word\n\n---\n\n### Subject:\n```text\nAssignment name  : first_word\nExpected files   : first_word.c\nAllowed functions: write\n--------------------------------------------------------------------------------\n\nWrite a program that takes a string and displays its first word, followed by a\nnewline.\n\nA word is a section of string delimited by spaces/tabs or by the start/end of\nthe string.\n\nIf the number of parameters is not 1, or if there are no words, simply display\na newline.\n\nExamples:\n\n$> ./first_word \"FOR PONY\" | cat -e\nFOR$\n$> ./first_word \"this        ...       is sparta, then again, maybe    not\" | cat -e\nthis$\n$> ./first_word \"   \" | cat -e\n$\n$> ./first_word \"a\" \"b\" | cat -e\n$\n$> ./first_word \"  lorem,ipsum  \" | cat -e\nlorem,ipsum$\n$>\n```\n### Code:\n```c\n#include <unistd.h>\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\n\ti = 0;\n\tif (ac == 2)\n\t{\n\t\twhile (av[1][i] == ' ' || av[1][i] == '\\t')\n\t\t\ti++;\n\t\twhile (av[1][i] != '\\0' && av[1][i] != ' ' && av[1][i] != '\\t')\n\t\t{\n\t\t\twrite(1, &av[1][i], 1);\n\t\t\ti++;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```",
            "FR": "# Level 1\n\n---\n\n## first_word\n\n---\n\n### Sujet :\n```text\nNom de l'assignation : first_word\nFichiers attendus : first_word.c\nFonctions autorisées : write\n--------------------------------------------------------------------------------\n\nÉcrire un programme qui prend une chaîne de caractères et affiche son premier mot, suivi d'une\nnouvelle ligne.\n\nUn mot est une section de chaîne délimitée par des espaces/tabulations ou par le début/fin de\nla chaîne.\n\nSi le nombre de paramètres n'est pas 1, ou s'il n'y a pas de mots, affiche simplement\nune nouvelle ligne.\n\nExemples :\n\n$> ./first_word \"FOR PONY\" | cat -e\nFOR$\n$> ./first_word \"this ... is sparta, then again, maybe not\" | cat -e\nthis$\n$> ./first_word \" \" | cat -e\n$\n$> ./first_word \"a\" \"b\" | cat -e\n$\n$> ./first_word \" lorem,ipsum \" | cat -e\nlorem,ipsum$\n$>\n```\n### Code :\n```c\n#include <unistd.h>\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\n\ti = 0;\n\tif (ac == 2)\n\t{\n\t\twhile (av[1][i] == ' ' || av[1][i] == '\\t')\n\t\t\ti++;\n\t\twhile (av[1][i] != '\\0' && av[1][i] != ' ' && av[1][i] != '\\t')\n\t\t{\n\t\t\twrite(1, &av[1][i], 1);\n\t\t\ti++;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## fizzbuzz\n\n---\n\n### Subject:\n```text\nAssignment name  : fizzbuzz\nExpected files   : fizzbuzz.c\nAllowed functions: write\n--------------------------------------------------------------------------------\n\nWrite a program that prints the numbers from 1 to 100, each separated by a\nnewline.\n\nIf the number is a multiple of 3, it prints 'fizz' instead.\n\nIf the number is a multiple of 5, it prints 'buzz' instead.\n\nIf the number is both a multiple of 3 and a multiple of 5, it prints 'fizzbuzz' instead.\n\nExample:\n\n$>./fizzbuzz\n1\n2\nfizz\n4\nbuzz\nfizz\n7\n8\nfizz\nbuzz\n11\nfizz\n13\n14\nfizzbuzz\n[...]\n97\n98\nfizz\nbuzz\n$>\n```\n### Code:\n```c\n#include <unistd.h>\n\nvoid\tft_write_number(int number)\n{\n\tif (number > 9)\n\t\tft_write_number(number / 10);\n\twrite(1, &\"0123456789\"[number % 10], 1);\n}\n\nint\tmain(void)\n{\n\tint\tnumber;\n\n\tnumber = 1;\n\twhile (number <= 100)\n\t{\n\t\tif (number % 3 == 0 && number % 5 == 0)\n\t\t\twrite(1, \"fizzbuzz\", 8);\n\t\telse if (number % 3 == 0)\n\t\t\twrite(1, \"fizz\", 4);\n\t\telse if (number % 5 == 0)\n\t\t\twrite(1, \"buzz\", 4);\n\t\telse\n\t\t\tft_write_number(number);\n\t\twrite(1, \"\\n\", 1);\n\t\tnumber++;\n\t}\n}\n```",
            "FR": "## fizzbuzz\n\n---\n\n### Sujet :\n```text\nNom de l'assignation : fizzbuzz\nFichiers attendus : fizzbuzz.c\nFonctions autorisées : write\n--------------------------------------------------------------------------------\n\nÉcrire un programme qui affiche les nombres de 1 à 100, chacun séparé par une\nnouvelle ligne.\n\nSi le nombre est un multiple de 3, il affiche 'fizz' à la place.\n\nSi le nombre est un multiple de 5, il affiche 'buzz' à la place.\n\nSi le nombre est à la fois un multiple de 3 et un multiple de 5, il affiche 'fizzbuzz' à la place.\n\nExemple :\n\n$>./fizzbuzz\n1\n2\nfizz\n4\nbuzz\nfizz\n7\n8\nfizz\nbuzz\n11\nfizz\n13\n14\nfizzbuzz\n[...]\n97\n98\nfizz\nbuzz\n$>\n```\n### Code :\n```c\n#include <unistd.h>\n\nvoid\tft_write_number(int number)\n{\n\tif (number > 9)\n\t\tft_write_number(number / 10);\n\twrite(1, &\"0123456789\"[number % 10], 1);\n}\n\nint\tmain(void)\n{\n\tint\tnumber;\n\n\tnumber = 1;\n\twhile (number <= 100)\n\t{\n\t\tif (number % 3 == 0 && number % 5 == 0)\n\t\t\twrite(1, \"fizzbuzz\", 8);\n\t\telse if (number % 3 == 0)\n\t\t\twrite(1, \"fizz\", 4);\n\t\telse if (number % 5 == 0)\n\t\t\twrite(1, \"buzz\", 4);\n\t\telse\n\t\t\tft_write_number(number);\n\t\twrite(1, \"\\n\", 1);\n\t\tnumber++;\n\t}\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## ft_strcpy\n\n---\n\n### Subject:\n```text\nAssignment name  : ft_strcpy\nExpected files   : ft_strcpy.c\nAllowed functions: \n--------------------------------------------------------------------------------\n\nReproduce the behavior of the function strcpy (man strcpy).\n\nYour function must be declared as follows:\n\nchar    *ft_strcpy(char *s1, char *s2);\n\n```\n### Code:\n```c\n#include <unistd.h>\n\nchar\t*ft_strcpy(char *s1, char *s2)\n{\n\tint i;\n\n\ti = 0;\n\twhile (s2[i] != '\\0')\n\t{\n\t\ts1[i] = s2[i];\n\t\ti++;\n\t}\n\ts1[i] = '\\0';\n\treturn (s1);\n}\n\n```",
            "FR": "## ft_strcpy\n\n---\n\n### Sujet :\n```text\nNom de l'assignation : ft_strcpy\nFichiers attendus : ft_strcpy.c\nFonctions autorisées :\n--------------------------------------------------------------------------------\n\nReproduire le comportement de la fonction strcpy (man strcpy).\n\nVotre fonction doit être déclarée comme suit :\n\nchar *ft_strcpy(char *s1, char *s2);\n\n```\n### Code :\n```c\n#include <unistd.h>\n\nchar\t*ft_strcpy(char *s1, char *s2)\n{\n\tint i;\n\n\ti = 0;\n\twhile (s2[i] != '\\0')\n\t{\n\t\ts1[i] = s2[i];\n\t\ti++;\n\t}\n\ts1[i] = '\\0';\n\treturn (s1);\n}\n\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## repeat_alpha\n\n---\n\n### Subject:\n```text\nAssignment name  : repeat_alpha\nExpected files   : repeat_alpha.c\nAllowed functions: write\n--------------------------------------------------------------------------------\n\nWrite a program called repeat_alpha that takes a string and display it\nrepeating each alphabetical character as many times as its alphabetical index,\nfollowed by a newline.\n\n'a' becomes 'a', 'b' becomes 'bb', 'e' becomes 'eeeee', etc...\n\nCase remains unchanged.\n\nIf the number of arguments is not 1, just display a newline.\n\nExamples:\n\n$>./repeat_alpha \"abc\"\nabbccc\n$>./repeat_alpha \"Alex.\" | cat -e\nAlllllllllllleeeeexxxxxxxxxxxxxxxxxxxxxxxx.$\n$>./repeat_alpha 'abacadaba 42!' | cat -e\nabbacccaddddabba 42!$\n$>./repeat_alpha | cat -e\n$\n$>\n$>./repeat_alpha \"\" | cat -e\n$\n$>\n```\n### Code:\n```c\n#include <unistd.h>\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\tint count;\n\n\ti = 0;\n\tcount = 0;\n\tif (ac == 2)\n\t{\n\t\twhile (av[1][i] != '\\0')\n\t\t{\n\t\t\tif (av[1][i] >= 'A' && av[1][i] <= 'Z')\n\t\t\t\tcount = av[1][i] - 64;\n\t\t\telse if (av[1][i] >= 'a' && av[1][i] <= 'z')\n\t\t\t\tcount = av[1][i] - 96;\n\t\t\twhile (count)\n\t\t\t{\n\t\t\t\twrite(1, &av[1][i], 1);\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\tcount = 1;\n\t\t\ti++;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```",
            "FR": "## repeat_alpha\n\n---\n\n### Sujet :\n```text\nNom de l'assignation : repeat_alpha\nFichiers attendus : repeat_alpha.c\nFonctions autorisées : write\n--------------------------------------------------------------------------------\n\nÉcrire un programme appelé repeat_alpha qui prend une chaîne de caractères et l'affiche\nrépétant chaque caractère alphabétique autant de fois que son index alphabétique,\nsuivi d'une nouvelle ligne.\n\n'a' devient 'a', 'b' devient 'bb', 'e' devient 'eeeee', etc...\n\nLa casse reste inchangée.\n\nSi le nombre d'arguments n'est pas 1, affiche simplement une nouvelle ligne.\n\nExemples :\n\n$>./repeat_alpha \"abc\"\nabbccc\n$>./repeat_alpha \"Alex.\" | cat -e\nAlllllllllllleeeeexxxxxxxxxxxxxxxxxxxxxxxx.$\n$>./repeat_alpha 'abacadaba 42!' | cat -e\nabbacccaddddabba 42!$\n$>./repeat_alpha | cat -e\n$\n$>\n$>./repeat_alpha \"\" | cat -e\n$\n$>\n```\n### Code :\n```c\n#include <unistd.h>\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\tint count;\n\n\ti = 0;\n\tcount = 0;\n\tif (ac == 2)\n\t{\n\t\twhile (av[1][i] != '\\0')\n\t\t{\n\t\t\tif (av[1][i] >= 'A' && av[1][i] <= 'Z')\n\t\t\t\tcount = av[1][i] - 64;\n\t\t\telse if (av[1][i] >= 'a' && av[1][i] <= 'z')\n\t\t\t\tcount = av[1][i] - 96;\n\t\t\twhile (count)\n\t\t\t{\n\t\t\t\twrite(1, &av[1][i], 1);\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\tcount = 1;\n\t\t\ti++;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## rev_print\n\n---\n\n### Subject:\n```text\nAssignment name  : rev_print\nExpected files   : rev_print.c\nAllowed functions: write\n--------------------------------------------------------------------------------\n\nWrite a program that takes a string, and displays the string in reverse\nfollowed by a newline.\n\nIf the number of parameters is not 1, the program displays a newline.\n\nExamples:\n\n$> ./rev_print \"zaz\" | cat -e\nzaz$\n$> ./rev_print \"dub0 a POIL\" | cat -e\nLIOP a 0bud$\n$> ./rev_print | cat -e\n$\n```\n### Code:\n```c\n#include <unistd.h>\n\nint\tmain(int argc, char **argv)\n{\n\tint\ti = 0;\n\n\tif (argc == 2)\n\t{\n\t\twhile (argv[1][i] != '\\0')\n\t\t\ti++;//go till the end\n\t\ti--;//remove '\\0'\n\t\twhile (i >= 0)\n\t\t{\n\t\t\twrite(1, &argv[1][i], 1);\n\t\t\ti--;//go back and put it\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```",
            "FR": "## rev_print\n\n---\n\n### Sujet :\n```text\nNom de l'assignation : rev_print\nFichiers attendus : rev_print.c\nFonctions autorisées : write\n--------------------------------------------------------------------------------\n\nÉcrire un programme qui prend une chaîne de caractères et affiche la chaîne en sens inverse\nsuivie d'une nouvelle ligne.\n\nSi le nombre de paramètres n'est pas 1, le programme affiche une nouvelle ligne.\n\nExemples :\n\n$> ./rev_print \"zaz\" | cat -e\nzaz$\n$> ./rev_print \"dub0 a POIL\" | cat -e\nLIOP a 0bud$\n$> ./rev_print | cat -e\n$\n```\n### Code :\n```c\n#include <unistd.h>\n\nint\tmain(int argc, char **argv)\n{\n\tint\ti = 0;\n\n\tif (argc == 2)\n\t{\n\t\twhile (argv[1][i] != '\\0')\n\t\t\ti++;//aller jusqu'à la fin\n\t\ti--;//supprimer '\\0'\n\t\twhile (i >= 0)\n\t\t{\n\t\t\twrite(1, &argv[1][i], 1);\n\t\t\ti--;//revenir en arrière et le mettre\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## rot_13\n\n---\n\n### Subject:\n```text\nAssignment name  : rot_13\nExpected files   : rot_13.c\nAllowed functions: write\n--------------------------------------------------------------------------------\n\nWrite a program that takes a string and displays it, replacing each of its\nletters by the letter 13 spaces ahead in alphabetical order.\n\n'z' becomes 'm' and 'Z' becomes 'M'. Case remains unaffected.\n\nThe output will be followed by a newline.\n\nIf the number of arguments is not 1, the program displays a newline.\n\nExample:\n\n$>./rot_13 \"abc\"\nnop\n$>./rot_13 \"My horse is Amazing.\" | cat -e\nZl ubefr vf Nznmvat.$\n$>./rot_13 \"AkjhZ zLKIJz , 23y \" | cat -e\nNxwuM mYXVWm , 23l $\n$>./rot_13 | cat -e\n$\n$>\n$>./rot_13 \"\" | cat -e\n$\n$>\n```\n### Code:\n```c\n#include <unistd.h>\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\n\ti = 0;\n\tif (ac == 2)\n\t{\n\t\twhile (av[1][i] != '\\0')\n\t\t{\n\t\t\tif (av[1][i] >= 'A' && av[1][i] <= 'M')\n\t\t\t\tav[1][i] += 13;\n\t\t\telse if (av[1][i] >= 'N' && av[1][i] <= 'Z')\n\t\t\t\tav[1][i] -= 13;\n\t\t\telse if (av[1][i] >= 'a' && av[1][i] <= 'm')\n\t\t\t\tav[1][i] += 13;\n\t\t\telse if (av[1][i] >= 'n' && av[1][i] <= 'z')\n\t\t\t\tav[1][i] -= 13;\n\t\t\twrite(1, &av[1][i], 1);\n\t\t\ti++;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```",
            "FR": "## rot_13\n\n---\n\n### Sujet :\n```text\nNom de l'assignation : rot_13\nFichiers attendus : rot_13.c\nFonctions autorisées : write\n--------------------------------------------------------------------------------\n\nÉcrire un programme qui prend une chaîne de caractères et l'affiche, en remplaçant chacune de ses\nlettres par la lettre 13 espaces plus loin dans l'ordre alphabétique.\n\n'z' devient 'm' et 'Z' devient 'M'. La casse reste inchangée.\n\nLa sortie sera suivie d'une nouvelle ligne.\n\nSi le nombre d'arguments n'est pas 1, le programme affiche une nouvelle ligne.\n\nExemple :\n\n$>./rot_13 \"abc\"\nnop\n$>./rot_13 \"My horse is Amazing.\" | cat -e\nZl ubefr vf Nznmvat.$\n$>./rot_13 \"AkjhZ zLKIJz , 23y \" | cat -e\nNxwuM mYXVWm , 23l $\n$>./rot_13 | cat -e\n$\n$>\n$>./rot_13 \"\" | cat -e\n$\n$>\n```\n### Code :\n```c\n#include <unistd.h>\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\n\ti = 0;\n\tif (ac == 2)\n\t{\n\t\twhile (av[1][i] != '\\0')\n\t\t{\n\t\t\tif (av[1][i] >= 'A' && av[1][i] <= 'M')\n\t\t\t\tav[1][i] += 13;\n\t\t\telse if (av[1][i] >= 'N' && av[1][i] <= 'Z')\n\t\t\t\tav[1][i] -= 13;\n\t\t\telse if (av[1][i] >= 'a' && av[1][i] <= 'm')\n\t\t\t\tav[1][i] += 13;\n\t\t\telse if (av[1][i] >= 'n' && av[1][i] <= 'z')\n\t\t\t\tav[1][i] -= 13;\n\t\t\twrite(1, &av[1][i], 1);\n\t\t\ti++;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## rotone\n\n---\n\n### Subject:\n```text\nAssignment name  : rotone\nExpected files   : rotone.c\nAllowed functions: write\n--------------------------------------------------------------------------------\n\nWrite a program that takes a string and displays it, replacing each of its\nletters by the next one in alphabetical order.\n\n'z' becomes 'a' and 'Z' becomes 'A'. Case remains unaffected.\n\nThe output will be followed by a \\n.\n\nIf the number of arguments is not 1, the program displays \\n.\n\nExample:\n\n$>./rotone \"abc\"\nbcd\n$>./rotone \"Les stagiaires du staff ne sentent pas toujours tres bon.\" | cat -e\nMft tubhjbjsft ev tubgg of tfoufou qbt upvkpvst usft cpo.$\n$>./rotone \"AkjhZ zLKIJz , 23y \" | cat -e\nBlkiA aMLJKa , 23z $\n$>./rotone | cat -e\n$\n$>\n$>./rotone \"\" | cat -e\n$\n$>\n```\n### Code:\n```c\n#include <unistd.h>\n\nint\tmain(int argc, char **argv)\n{\n\tint\ti = 0;\n\n\tif (argc == 2)\n\t{\n\t\twhile (argv[1][i] != '\\0')\n\t\t{\n\t\t\tif (argv[1][i] == 'z' || argv[1][i] == 'Z')//z->a || Z-A\n\t\t\t\targv[1][i] -= 25;\n\t\t\telse if (argv[1][i] >= 'a' && argv[1][i] < 'z')\n\t\t\t\targv[1][i] += 1;//go 1 letter forward\n\t\t\telse if (argv[1][i] >= 'A' && argv[1][i] < 'Z')\n\t\t\t\targv[1][i] += 1;\n\t\t\twrite(1, &argv[1][i], 1);\n\t\t\ti++;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```",
            "FR": "## rotone\n\n---\n\n### Sujet :\n```text\nNom de l'assignation : rotone\nFichiers attendus : rotone.c\nFonctions autorisées : write\n--------------------------------------------------------------------------------\n\nÉcrire un programme qui prend une chaîne de caractères et l'affiche, en remplaçant chacune de ses\nlettres par la suivante dans l'ordre alphabétique.\n\n'z' devient 'a' et 'Z' devient 'A'. La casse reste inchangée.\n\nLa sortie sera suivie d'un \\n.\n\nSi le nombre d'arguments n'est pas 1, le programme affiche \\n.\n\nExemple :\n\n$>./rotone \"abc\"\nbcd\n$>./rotone \"Les stagiaires du staff ne sentent pas toujours tres bon.\" | cat -e\nMft tubhjbjsft ev tubgg of tfoufou qbt upvkpvst usft cpo.$\n$>./rotone \"AkjhZ zLKIJz , 23y \" | cat -e\nBlkiA aMLJKa , 23z $\n$>./rotone | cat -e\n$\n$>\n$>./rotone \"\" | cat -e\n$\n$>\n```\n### Code :\n```c\n#include <unistd.h>\n\nint\tmain(int argc, char **argv)\n{\n\tint\ti = 0;\n\n\tif (argc == 2)\n\t{\n\t\twhile (argv[1][i] != '\\0')\n\t\t{\n\t\t\tif (argv[1][i] == 'z' || argv[1][i] == 'Z')//z->a || Z-A\n\t\t\t\targv[1][i] -= 25;\n\t\t\telse if (argv[1][i] >= 'a' && argv[1][i] < 'z')\n\t\t\t\targv[1][i] += 1;//avancer d'une lettre\n\t\t\telse if (argv[1][i] >= 'A' && argv[1][i] < 'Z')\n\t\t\t\targv[1][i] += 1;\n\t\t\twrite(1, &argv[1][i], 1);\n\t\t\ti++;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## search_and_replace\n\n---\n\n### Subject:\n```text\nAssignment name  : search_and_replace\nExpected files   : search_and_replace.c\nAllowed functions: write, exit\n--------------------------------------------------------------------------------\n\nWrite a program called search_and_replace that takes 3 arguments, the first \narguments is a string in which to replace a letter (2nd argument) by\nanother one (3rd argument).\n\nIf the number of arguments is not 3, just display a newline.\n\nIf the second argument is not contained in the first one (the string)\nthen the program simply rewrites the string followed by a newline.\n\nExamples:\n$>./search_and_replace \"Papache est un sabre\" \"a\" \"o\"\nPopoche est un sobre\n$>./search_and_replace \"zaz\" \"art\" \"zul\" | cat -e\n$\n$>./search_and_replace \"zaz\" \"r\" \"u\" | cat -e\nzaz$\n$>./search_and_replace \"jacob\" \"a\" \"b\" \"c\" \"e\" | cat -e\n$\n$>./search_and_replace \"ZoZ eT Dovid oiME le METol.\" \"o\" \"a\" | cat -e\nZaZ eT David aiME le METal.$\n$>./search_and_replace \"wNcOre Un ExEmPle Pas Facilw a Ecrirw \" \"w\" \"e\" | cat -e\neNcOre Un ExEmPle Pas Facile a Ecrire $\n```\n### Code:\n```c\n#include <unistd.h>\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\n\ti = 0;\n\tif (ac == 4)\n\t{\n\t\twhile (av[1][i] != '\\0')\n\t\t{\n\t\t\t\n\t\t\tif (av[2][1] == '\\0' && av[3][1] == '\\0')\n\t\t\t{\n\t\t\t\tif (av[1][i] == av[2][0])\n\t\t\t\t\twrite(1, &av[3][0], 1);\n\t\t\t\telse\n\t\t\t\t\twrite(1, &av[1][i], 1);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```",
            "FR": "## search_and_replace\n\n---\n\n### Sujet :\n```text\nNom de l'assignation : search_and_replace\nFichiers attendus : search_and_replace.c\nFonctions autorisées : write, exit\n--------------------------------------------------------------------------------\n\nÉcrire un programme appelé search_and_replace qui prend 3 arguments, le premier \nargument est une chaîne dans laquelle remplacer une lettre (2ème argument) par\nune autre (3ème argument).\n\nSi le nombre d'arguments n'est pas 3, affichez simplement une nouvelle ligne.\n\nSi le deuxième argument n'est pas contenu dans le premier (la chaîne),\nalors le programme réécrit simplement la chaîne suivie d'une nouvelle ligne.\n\nExemples :\n$>./search_and_replace \"Papache est un sabre\" \"a\" \"o\"\nPopoche est un sobre\n$>./search_and_replace \"zaz\" \"art\" \"zul\" | cat -e\n$\n$>./search_and_replace \"zaz\" \"r\" \"u\" | cat -e\nzaz$\n$>./search_and_replace \"jacob\" \"a\" \"b\" \"c\" \"e\" | cat -e\n$\n$>./search_and_replace \"ZoZ eT Dovid oiME le METol.\" \"o\" \"a\" | cat -e\nZaZ eT David aiME le METal.$\n$>./search_and_replace \"wNcOre Un ExEmPle Pas Facilw a Ecrirw \" \"w\" \"e\" | cat -e\neNcOre Un ExEmPle Pas Facile a Ecrire $\n```\n### Code :\n```c\n#include <unistd.h>\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\n\ti = 0;\n\tif (ac == 4)\n\t{\n\t\twhile (av[1][i] != '\\0')\n\t\t{\n\t\t\t\n\t\t\tif (av[2][1] == '\\0' && av[3][1] == '\\0')\n\t\t\t{\n\t\t\t\tif (av[1][i] == av[2][0])\n\t\t\t\t\twrite(1, &av[3][0], 1);\n\t\t\t\telse\n\t\t\t\t\twrite(1, &av[1][i], 1);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## ulstr\n\n---\n\n### Subject:\n```text\nAssignment name  : ulstr\nExpected files   : ulstr.c\nAllowed functions: write\n--------------------------------------------------------------------------------\n\nWrite a program that takes a string and reverses the case of all its letters.\nOther characters remain unchanged.\n\nYou must display the result followed by a '\\n'.\n\nIf the number of arguments is not 1, the program displays '\\n'.\n\nExamples :\n\n$>./ulstr \"L'eSPrit nE peUt plUs pRogResSer s'Il staGne et sI peRsIsTent VAnIte et auto-justification.\" | cat -e\nl'EspRIT Ne PEuT PLuS PrOGrESsER S'iL STAgNE ET Si PErSiStENT vaNiTE ET AUTO-JUSTIFICATION.$\n$>./ulstr \"S'enTOuRer dE sECreT eSt uN sIGnE De mAnQuE De coNNaiSSanCe.  \" | cat -e\ns'ENtoUrER De SecREt EsT Un SigNe dE MaNqUe dE COnnAIssanCe.  $\n$>./ulstr \"3:21 Ba  tOut  moUn ki Ka di KE m'en Ka fe fot\" | cat -e\n3:21 bA  ToUT  MOuN KI kA DI ke M'EN kA FE FOT$\n$>./ulstr | cat -e\n$\n```\n### Code:\n```c\n#include <unistd.h>\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\n\ti = 0;\n\tif (ac == 2)\n\t{\n\t\twhile (av[1][i] != '\\0')\n\t\t{\n\t\t\tif (av[1][i] >= 'A' && av[1][i] <= 'Z')\n\t\t\t\tav[1][i] += 32;\n\t\t\telse if (av[1][i] >= 'a' && av[1][i] <= 'z')\n\t\t\t\tav[1][i] -= 32;\n\t\t\twrite(1, &av[1][i], 1);\n\t\t\ti++;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```",
            "FR": "## ulstr\n\n---\n\n### Sujet :\n```text\nNom de l'assignation : ulstr\nFichiers attendus : ulstr.c\nFonctions autorisées : write\n--------------------------------------------------------------------------------\n\nÉcrire un programme qui prend une chaîne de caractères et inverse la casse de toutes ses lettres.\nLes autres caractères restent inchangés.\n\nVous devez afficher le résultat suivi d'un '\\n'.\n\nSi le nombre d'arguments n'est pas 1, le programme affiche '\\n'.\n\nExemples :\n\n$>./ulstr \"L'eSPrit nE peUt plUs pRogResSer s'Il staGne et sI peRsIsTent VAnIte et auto-justification.\" | cat -e\nl'EspRIT Ne PEuT PLuS PrOGrESsER S'iL STAgNE ET Si PErSiStENT vaNiTE ET AUTO-JUSTIFICATION.$\n$>./ulstr \"S'enTOuRer dE sECreT eSt uN sIGnE De mAnQuE De coNNaiSSanCe.  \" | cat -e\ns'ENtoUrER De SecREt EsT Un SigNe dE MaNqUe dE COnnAIssanCe.  $\n$>./ulstr \"3:21 Ba  tOut  moUn ki Ka di KE m'en Ka fe fot\" | cat -e\n3:21 bA  ToUT  MOuN KI kA DI ke M'EN kA FE FOT$\n$>./ulstr | cat -e\n$\n```\n### Code :\n```c\n#include <unistd.h>\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\n\ti = 0;\n\tif (ac == 2)\n\t{\n\t\twhile (av[1][i] != '\\0')\n\t\t{\n\t\t\tif (av[1][i] >= 'A' && av[1][i] <= 'Z')\n\t\t\t\tav[1][i] += 32;\n\t\t\telse if (av[1][i] >= 'a' && av[1][i] <= 'z')\n\t\t\t\tav[1][i] -= 32;\n\t\t\twrite(1, &av[1][i], 1);\n\t\t\ti++;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-8",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "# Level 2\n\n---\n\n## alpha_mirror\n\n---\n\n### Subject:\n```text\nAssignment name  : alpha_mirror\nExpected files   : alpha_mirror.c\nAllowed functions: write\n--------------------------------------------------------------------------------\n\nWrite a program called alpha_mirror that takes a string and displays this string\nafter replacing each alphabetical character by the opposite alphabetical\ncharacter, followed by a newline.\n\n'a' becomes 'z', 'Z' becomes 'A'\n'd' becomes 'w', 'M' becomes 'N'\n\nand so on.\n\nCase is not changed.\n\nIf the number of arguments is not 1, display only a newline.\n\nExamples:\n\n$>./alpha_mirror \"abc\"\nzyx\n$>./alpha_mirror \"My horse is Amazing.\" | cat -e\nNb slihv rh Znzarmt.$\n$>./alpha_mirror | cat -e\n$\n$>\n```\n### Code:\n```c\n#include <unistd.h>\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\n\ti = 0;\n\tif (ac == 2)\n\t{\n\t\twhile (av[1][i] != '\\0')\n\t\t{\n\t\t\tif (av[1][i] >= 'A' && av[1][i] <= 'Z')\n\t\t\t\tav[1][i] = 'M' - (av[1][i] - 'N');\n\t\t\telse if (av[1][i] >= 'a' && av[1][i] <= 'z')\n\t\t\t\tav[1][i] = 'm' - (av[1][i] - 'n');\n\t\t\twrite(1, &av[1][i], 1);\n\t\t\ti++;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```\n",
            "FR": "# Niveau 2\n\n---\n\n## alpha_mirror\n\n---\n\n### Sujet :\n```text\nNom de l'assignation : alpha_mirror\nFichiers attendus : alpha_mirror.c\nFonctions autorisées : write\n--------------------------------------------------------------------------------\n\nÉcrire un programme appelé alpha_mirror qui prend une chaîne de caractères et affiche cette chaîne\naprès avoir remplacé chaque caractère alphabétique par le caractère alphabétique opposé,\nsuivi d'une nouvelle ligne.\n\n'a' devient 'z', 'Z' devient 'A'\n'd' devient 'w', 'M' devient 'N'\n\net ainsi de suite.\n\nLa casse n'est pas modifiée.\n\nSi le nombre d'arguments n'est pas 1, afficher uniquement une nouvelle ligne.\n\nExemples :\n\n$>./alpha_mirror \"abc\"\nzyx\n$>./alpha_mirror \"My horse is Amazing.\" | cat -e\nNb slihv rh Znzarmt.$\n$>./alpha_mirror | cat -e\n$\n$>\n```\n### Code :\n```c\n#include <unistd.h>\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\n\ti = 0;\n\tif (ac == 2)\n\t{\n\t\twhile (av[1][i] != '\\0')\n\t\t{\n\t\t\tif (av[1][i] >= 'A' && av[1][i] <= 'Z')\n\t\t\t\tav[1][i] = 'M' - (av[1][i] - 'N');\n\t\t\telse if (av[1][i] >= 'a' && av[1][i] <= 'z')\n\t\t\t\tav[1][i] = 'm' - (av[1][i] - 'n');\n\t\t\twrite(1, &av[1][i], 1);\n\t\t\ti++;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```\n"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## camel_to_snake\n\n---\n\n### Subject:\n```text\nAssignment name  : camel_to_snake\nExpected files   : camel_to_snake.c\nAllowed functions: malloc, free, realloc, write\n--------------------------------------------------------------------------------\n\nWrite a program that takes a single string in lowerCamelCase format\nand converts it into a string in snake_case format.\n\nA lowerCamelCase string is a string where each word begins with a capital letter\nexcept for the first one.\n\nA snake_case string is a string where each word is in lower case, separated by\nan underscore \"_\".\n\nExamples:\n$>./camel_to_snake \"hereIsACamelCaseWord\"\nhere_is_a_camel_case_word\n$>./camel_to_snake \"helloWorld\" | cat -e\nhello_world$\n$>./camel_to_snake | cat -e\n$\n```\n### Code:\n```c\n#include <unistd.h>\n\nint\t\tmain(int argc, char **argv)\n{\n\tint\ti = 0;\n\n\tif (argc == 2)\n\t\twhile (argv[1][i] != '\\0')\n\t\t{\n\t\t\tif (argv[1][i] >= 'A' && argv[1][i] <= 'Z')\n\t\t\t{\n\t\t\t\twrite(1, \"_\", 1);\n\t\t\t\targv[1][i] = argv[1][i] + ('a' - 'A');//put space\n\t\t\t}\n\t\t\twrite(1, &argv[1][i], 1);\n\t\t\ti++;\n\t\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```\n",
            "FR": "## camel_to_snake\n\n---\n\n### Sujet :\n```text\nNom de l'assignation : camel_to_snake\nFichiers attendus : camel_to_snake.c\nFonctions autorisées : malloc, free, realloc, write\n--------------------------------------------------------------------------------\n\nÉcrire un programme qui prend une seule chaîne de caractères au format lowerCamelCase\net la convertit en une chaîne au format snake_case.\n\nUne chaîne lowerCamelCase est une chaîne où chaque mot commence par une lettre majuscule\nsauf le premier.\n\nUne chaîne snake_case est une chaîne où chaque mot est en minuscule, séparé par\nun underscore \"_\".\n\nExemples :\n$>./camel_to_snake \"hereIsACamelCaseWord\"\nhere_is_a_camel_case_word\n$>./camel_to_snake \"helloWorld\" | cat -e\nhello_world$\n$>./camel_to_snake | cat -e\n$\n```\n### Code :\n```c\n#include <unistd.h>\n\nint\t\tmain(int argc, char **argv)\n{\n\tint\ti = 0;\n\n\tif (argc == 2)\n\t\twhile (argv[1][i] != '\\0')\n\t\t{\n\t\t\tif (argv[1][i] >= 'A' && argv[1][i] <= 'Z')\n\t\t\t{\n\t\t\t\twrite(1, \"_\", 1);\n\t\t\t\targv[1][i] = argv[1][i] + ('a' - 'A');//put space\n\t\t\t}\n\t\t\twrite(1, &argv[1][i], 1);\n\t\t\ti++;\n\t\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```\n"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## ft_atoi\n\n---\n\n### Subject:\n```text\nAssignment name  : ft_atoi\nExpected files   : ft_atoi.c\nAllowed functions: None\n--------------------------------------------------------------------------------\n\nWrite a function that converts the string argument str to an integer (type int)\nand returns it.\n\nIt works much like the standard atoi(const char *str) function, see the man.\n\nYour function must be declared as follows:\n\nint\tft_atoi(const char *str);\n```\n### Code:\n```c\nint\t\tft_atoi(const char *str)\n{\n\tint i;\n\tint n;\n\tint result;\n\n\ti = 0;\n\tn = 1;\n\tresult = 0;\n\twhile (str[i] <= 32)\n\t\ti++;\n\tif (str[i] == '-')\n\t{\n\t\tn = -1;\n\t\ti++;\n\t}\n\telse if (str[i] == '+')\n\t\ti++;\n\twhile (str[i] != '\\0' && str[i] >= '0' && str[i] <= '9')\n\t{\n\t\tresult *= 10;\n\t\tresult += str[i] - '0';\n\t\ti++;\n\t}\n\treturn (result * n);\n}\n```\n",
            "FR": "## ft_atoi\n\n---\n\n### Sujet :\n```text\nNom de l'assignation : ft_atoi\nFichiers attendus : ft_atoi.c\nFonctions autorisées : None\n--------------------------------------------------------------------------------\n\nÉcrire une fonction qui convertit l'argument de chaîne str en un entier (type int)\net le retourne.\n\nElle fonctionne de la même manière que la fonction standard atoi(const char *str), voir le man.\n\nVotre fonction doit être déclarée comme suit :\n\nint\tft_atoi(const char *str);\n```\n### Code :\n```c\nint\t\tft_atoi(const char *str)\n{\n\tint i;\n\tint n;\n\tint result;\n\n\ti = 0;\n\tn = 1;\n\tresult = 0;\n\twhile (str[i] <= 32)\n\t\ti++;\n\tif (str[i] == '-')\n\t{\n\t\tn = -1;\n\t\ti++;\n\t}\n\telse if (str[i] == '+')\n\t\ti++;\n\twhile (str[i] != '\\0' && str[i] >= '0' && str[i] <= '9')\n\t{\n\t\tresult *= 10;\n\t\tresult += str[i] - '0';\n\t\ti++;\n\t}\n\treturn (result * n);\n}\n```\n"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## ft_strcmp\n\n---\n\n### Subject:\n```text\nAssignment name  : ft_strcmp\nExpected files   : ft_strcmp.c\nAllowed functions: \n--------------------------------------------------------------------------------\n\nReproduce the behavior of the function strcmp (man strcmp).\n\nYour function must be declared as follows:\n\nint    ft_strcmp(char *s1, char *s2);\n```\n### Code:\n```c\nint\t\tft_strcmp(char *s1, char *s2)\n{\n\tint i;\n\n\ti = 0;\n\twhile (s1[i] != '\\0' && s2[i] != '\\0' && s1[i] == s2[i])\n\t\ti++;\n\treturn (s1[i] - s2[i]);\n}\n```\n",
            "FR": "## ft_strcmp\n\n---\n\n### Sujet :\n```text\nNom de l'assignation : ft_strcmp\nFichiers attendus : ft_strcmp.c\nFonctions autorisées :\n--------------------------------------------------------------------------------\n\nReproduire le comportement de la fonction strcmp (man strcmp).\n\nVotre fonction doit être déclarée comme suit :\n\nint ft_strcmp(char *s1, char *s2);\n```\n### Code :\n```c\nint\t\tft_strcmp(char *s1, char *s2)\n{\n\tint i;\n\n\ti = 0;\n\twhile (s1[i] != '\\0' && s2[i] != '\\0' && s1[i] == s2[i])\n\t\ti++;\n\treturn (s1[i] - s2[i]);\n}\n```\n"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## ft_strcspn\n\n---\n\n### Subject:\n```text\nAssignment name\t: ft_strcspn\nExpected files\t: ft_strcspn.c\nAllowed functions: None\n---------------------------------------------------------------\n\nReproduce exactly the behavior of the function strcspn\n(man strcspn).\n\nThe function should be prototyped as follows:\n\nsize_t\tft_strcspn(const char *s, const char *reject);\n\n---------------------------------------------------------------\n\n#include <stdio.h>\n\nint\tmain()\n{\n\tchar str[] = \"abcDEFghijklmDEFnopqrstuvwxyz\";\n\t//char fnd[] = \"\";\n\tchar fnd[] = \"DEF\";\n\tprintf(\"%d\", ft_strcspn(str, fnd));\n\treturn (0);\n}\n```\n### Code:\n```c\nsize_t ft_strcspn(const char *s1, const char *s2)\n{\n\tint\ti = 0;\n\tint\tj = 0;\n\n\twhile (s1[i] != '\\0')\n\t{\n\t\tj = 0;\n\t\twhile (s2[j] != '\\0')\n\t\t{\n\t\t\tif (s1[i] == s2[j])\n\t\t\t\treturn (i);\n\t\t\tj++;\n\t\t}\n\t\ti++;\n\t}\n\ti = 0;\n\twhile (s1[i] != '\\0')\n\t\ti++;\n\treturn (i);\n}\n```\n",
            "FR": "## ft_strcspn\n\n---\n\n### Sujet :\n```text\nNom de l'assignation : ft_strcspn\nFichiers attendus : ft_strcspn.c\nFonctions autorisées : None\n---------------------------------------------------------------\n\nReproduire exactement le comportement de la fonction strcspn\n(man strcspn).\n\nLa fonction doit être prototypée comme suit :\n\nsize_t\tft_strcspn(const char *s, const char *reject);\n```\n### Code :\n```c\nsize_t ft_strcspn(const char *s1, const char *s2)\n{\n\tint\ti = 0;\n\tint\tj = 0;\n\n\twhile (s1[i] != '\\0')\n\t{\n\t\tj = 0;\n\t\twhile (s2[j] != '\\0')\n\t\t{\n\t\t\tif (s1[i] == s2[j])\n\t\t\t\treturn (i);\n\t\t\tj++;\n\t\t}\n\t\ti++;\n\t}\n\ti = 0;\n\twhile (s1[i] != '\\0')\n\t\ti++;\n\treturn (i);\n}\n```\n"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## ft_strdup\n\n---\n\n### Subject:\n```text\nAssignment name  : ft_strdup\nExpected files   : ft_strdup.c\nAllowed functions: malloc\n--------------------------------------------------------------------------------\n\nReproduce the behavior of the function strdup (man strdup).\n\nYour function must be declared as follows:\n\nchar    *ft_strdup(char *src);\n\n--------------------------------------------------------------------------------\n\n#include<stdio.h>\n#include<string.h>\n \nint main()\n{\n    char source[] = \"GeeksForGeeks\";\n \n    // A copy of source is created dynamically\n    // and pointer to copy is returned.\n    char* target = strdup(source);\n \n    printf(\"%s\", target);\n    return 0;\n}\n```\n### Code:\n```c\n#include <stdlib.h>\n\nchar\t*ft_strdup(char *s1)\n{\n\tchar\t*dup;\n\tint\t\ti = 0;\n\n\tdup = (char *)malloc(sizeof(*s1) - 1);\n\twhile (s1[i])\n\t{\n\t\tdup[i] = s1[i];\n\t\ti++;\n\t}\n\tdup[i] = '\\0';\n\treturn (dup);\n}\n```\n",
            "FR": "## ft_strdup\n\n---\n\n### Sujet :\n```text\nNom de l'assignation : ft_strdup\nFichiers attendus : ft_strdup.c\nFonctions autorisées : malloc\n--------------------------------------------------------------------------------\n\nReproduire le comportement de la fonction strdup (man strdup).\n\nVotre fonction doit être déclarée comme suit :\n\nchar    *ft_strdup(char *src);\n```\n### Code :\n```c\n#include <stdlib.h>\n\nchar\t*ft_strdup(char *s1)\n{\n\tchar\t*dup;\n\tint\t\ti = 0;\n\n\tdup = (char *)malloc(sizeof(*s1) - 1);\n\twhile (s1[i])\n\t{\n\t\tdup[i] = s1[i];\n\t\ti++;\n\t}\n\tdup[i] = '\\0';\n\treturn (dup);\n}\n```\n"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## ft_strpbrk\n\n---\n\n### Subject:\n```text\nAssignment name\t: ft_strpbrk\nExpected files\t: ft_strpbrk.c\nAllowed functions: None\n---------------------------------------------------------------\n\nReproduce exactly the behavior of the function strpbrk\n(man strpbrk).\n\nThe function should be prototyped as follows:\n\nchar\t*ft_strpbrk(const char *s1, const char *s2);\n```\n### Code:\n```c\n#include<string.h>\n\nchar\t*ft_strpbrk(const char *s1, const char *s2)\n{\n\tint\ti;\n\tint\tc;\n\n\ti = 0;\n\tc = 0;\n\twhile (s1[i])\n\t{\n\t\twhile (s2[c])\n\t\t{\n\t\t\tif (s1[i] == s2[c])\n\t\t\t\treturn ((char *)&s1[i]);\n\t\t\tc++;\n\t\t}\n\t\tc = 0;\n\t\ti++;\n\t}\n\treturn (NULL);\n}\n```\n",
            "FR": "## ft_strpbrk\n\n---\n\n### Sujet :\n```text\nNom de l'assignation : ft_strpbrk\nFichiers attendus : ft_strpbrk.c\nFonctions autorisées : None\n---------------------------------------------------------------\n\nReproduire exactement le comportement de la fonction strpbrk\n(man strpbrk).\n\nLa fonction doit être prototypée comme suit :\n\nchar\t*ft_strpbrk(const char *s1, const char *s2);\n```\n### Code :\n```c\n#include<string.h>\n\nchar\t*ft_strpbrk(const char *s1, const char *s2)\n{\n\tint\ti;\n\tint\tc;\n\n\ti = 0;\n\tc = 0;\n\twhile (s1[i])\n\t{\n\t\twhile (s2[c])\n\t\t{\n\t\t\tif (s1[i] == s2[c])\n\t\t\t\treturn ((char *)&s1[i]);\n\t\t\tc++;\n\t\t}\n\t\tc = 0;\n\t\ti++;\n\t}\n\treturn (NULL);\n}\n```\n"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## ft_strrev\n\n---\n\n### Subject:\n```text\nAssignment name  : ft_strrev\nExpected files   : ft_strrev.c\nAllowed functions: \n--------------------------------------------------------------------------------\n\nWrite a function that reverses (in-place) a string.\n\nIt must return its parameter.\n\nYour function must be declared as follows:\n\nchar    *ft_strrev(char *str);\n```\n### Code:\n```c\nint\t\tft_strlen(char *str)\n{\n\tint i;\n\n\ti = 0;\n\twhile (str[i] != '\\0')\n\t\ti++;\n\treturn (i);\n}\n\nchar\t*ft_strrev(char *str)\n{\n\tint i;\n\tint len;\n\tchar tmp;\n\n\ti = 0;\n\tlen = ft_strlen(str) - 1;\n\twhile (len > i)\n\t{\n\t\ttmp = str[i];\n\t\tstr[i] = str[len];\n\t\tstr[len] = tmp;\n\t\ti++;\n\t\tlen--;\n\t}\n\treturn (str);\n}\n```",
            "FR": "## ft_strrev\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : ft_strrev\nFichiers attendus : ft_strrev.c\nFonctions autorisées :\n--------------------------------------------------------------------------------\n\nÉcrire une fonction qui inverse (en place) une chaîne de caractères.\n\nElle doit retourner son paramètre.\n\nVotre fonction doit être déclarée comme suit :\n\nchar    *ft_strrev(char *str);\n```\n### Code:\n```c\nint\t\tft_strlen(char *str)\n{\n\tint i;\n\n\ti = 0;\n\twhile (str[i] != '\\0')\n\t\ti++;\n\treturn (i);\n}\n\nchar\t*ft_strrev(char *str)\n{\n\tint i;\n\tint len;\n\tchar tmp;\n\n\ti = 0;\n\tlen = ft_strlen(str) - 1;\n\twhile (len > i)\n\t{\n\t\ttmp = str[i];\n\t\tstr[i] = str[len];\n\t\tstr[len] = tmp;\n\t\ti++;\n\t\tlen--;\n\t}\n\treturn (str);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## is_power_of_2\n\n---\n\n### Subject:\n```text\nAssignment name  : is_power_of_2\nExpected files   : is_power_of_2.c\nAllowed functions: None\n--------------------------------------------------------------------------------\n\nWrite a function that determines if a given number is a power of 2.\n\nThis function returns 1 if the given number is a power of 2, otherwise it returns 0.\n\nYour function must be declared as follows:\n\nint\t    is_power_of_2(unsigned int n);\n```\n### Code:\n```c\nint\tis_power_of_2(unsigned int n)\n{\n\tint\ti;\n\n\ti = 1;\n\twhile (i <= n)\n\t{\n\t\tif (i == n)\n\t\t\treturn (1);\n\t\ti = i * 2;\n\t}\n\treturn (0);\n}\n```",
            "FR": "## is_power_of_2\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : is_power_of_2\nFichiers attendus : is_power_of_2.c\nFonctions autorisées : None\n--------------------------------------------------------------------------------\n\nÉcrire une fonction qui détermine si un nombre donné est une puissance de 2.\n\nCette fonction retourne 1 si le nombre donné est une puissance de 2, sinon elle retourne 0.\n\nVotre fonction doit être déclarée comme suit :\n\nint\t    is_power_of_2(unsigned int n);\n```\n### Code:\n```c\nint\tis_power_of_2(unsigned int n)\n{\n\tint\ti;\n\n\ti = 1;\n\twhile (i <= n)\n\t{\n\t\tif (i == n)\n\t\t\treturn (1);\n\t\ti = i * 2;\n\t}\n\treturn (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## last_word\n\n---\n\n### Subject:\n```text\nAssignment name  : last_word\nExpected files   : last_word.c\nAllowed functions: write\n--------------------------------------------------------------------------------\n\nWrite a program that takes a string and displays its last word followed by a \\n.\n\nA word is a section of string delimited by spaces/tabs or by the start/end of\nthe string.\n\nIf the number of parameters is not 1, or there are no words, display a newline.\n\nExample:\n\n$> ./last_word \"FOR PONY\" | cat -e\nPONY$\n$> ./last_word \"this        ...       is sparta, then again, maybe    not\" | cat -e\nnot$\n$> ./last_word \"   \" | cat -e\n$\n$> ./last_word \"a\" \"b\" | cat -e\n$\n$> ./last_word \"  lorem,ipsum  \" | cat -e\nlorem,ipsum$\n$>\n```\n### Code:\n```c\n#include <unistd.h>\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\tchar *lw;\n\n\ti = 0;\n\tif (ac == 2)\n\t{\n\t\twhile (av[1][i] != '\\0')\n\t\t{\n\t\t\tif (av[1][i] <= 32 && av[1][i + 1] > 32)\n\t\t\t\tlw = &av[1][i + 1];\n\t\t\ti++;\n\t\t}\n\t\ti = 0;\n\t\twhile (lw && lw[i] > 32)\n\t\t{\n\t\t\twrite(1, &lw[i], 1);\n\t\t\ti++;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```",
            "FR": "## last_word\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : last_word\nFichiers attendus : last_word.c\nFonctions autorisées : write\n--------------------------------------------------------------------------------\n\nÉcrire un programme qui prend une chaîne de caractères et affiche son dernier mot suivi d'un \\n.\n\nUn mot est une section de chaîne délimitée par des espaces/tabulations ou par le début/fin de\nla chaîne.\n\nSi le nombre de paramètres n'est pas 1, ou s'il n'y a pas de mots, afficher une nouvelle ligne.\n\nExemple:\n\n$> ./last_word \"FOR PONY\" | cat -e\nPONY$\n$> ./last_word \"this        ...       is sparta, then again, maybe    not\" | cat -e\nnot$\n$> ./last_word \"   \" | cat -e\n$\n$> ./last_word \"a\" \"b\" | cat -e\n$\n$> ./last_word \"  lorem,ipsum  \" | cat -e\nlorem,ipsum$\n$>\n```\n### Code:\n```c\n#include <unistd.h>\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\tchar *lw;\n\n\ti = 0;\n\tif (ac == 2)\n\t{\n\t\twhile (av[1][i] != '\\0')\n\t\t{\n\t\t\tif (av[1][i] <= 32 && av[1][i + 1] > 32)\n\t\t\t\tlw = &av[1][i + 1];\n\t\t\ti++;\n\t\t}\n\t\ti = 0;\n\t\twhile (lw && lw[i] > 32)\n\t\t{\n\t\t\twrite(1, &lw[i], 1);\n\t\t\ti++;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## max\n\n---\n\n### Subject:\n```text\nAssignment name  : max\nExpected files   : max.c\nAllowed functions: \n--------------------------------------------------------------------------------\n\nWrite the following function:\n\nint\t\tmax(int* tab, unsigned int len);\n\nThe first parameter is an array of int, the second is the number of elements in\nthe array.\n\nThe function returns the largest number found in the array.\n\nIf the array is empty, the function returns 0.\n```\n### Code:\n```c\nint\tmax(int *tab, unsigned int len)\n{\n\tint\ti;\n\tint\ttmp;\n\n\ti = 0;\n\tif (len == 0)\n\t\treturn (0);\n\twhile (i < len - 1)\n\t{\n\t\tif (tab[i] > tab[i + 1])\n\t\t{\n\t\t\ttmp = tab[i];\n\t\t\ttab[i] = tab[i + 1];\n\t\t\ttab[i + 1] = tmp;\n\t\t}\n\t\ti++;\n\t}\n\treturn (tab[len - 1]);\n}\n```",
            "FR": "## max\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : max\nFichiers attendus : max.c\nFonctions autorisées :\n--------------------------------------------------------------------------------\n\nÉcrire la fonction suivante :\n\nint\t\tmax(int* tab, unsigned int len);\n\nLe premier paramètre est un tableau d'entiers, le second est le nombre d'éléments dans\nle tableau.\n\nLa fonction retourne le plus grand nombre trouvé dans le tableau.\n\nSi le tableau est vide, la fonction retourne 0.\n```\n### Code:\n```c\nint\tmax(int *tab, unsigned int len)\n{\n\tint\ti;\n\tint\ttmp;\n\n\ti = 0;\n\tif (len == 0)\n\t\treturn (0);\n\twhile (i < len - 1)\n\t{\n\t\tif (tab[i] > tab[i + 1])\n\t\t{\n\t\t\ttmp = tab[i];\n\t\t\ttab[i] = tab[i + 1];\n\t\t\ttab[i + 1] = tmp;\n\t\t}\n\t\ti++;\n\t}\n\treturn (tab[len - 1]);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## reverse_bits\n\n---\n\n### Subject:\n```text\nAssignment name  : reverse_bits\nExpected files   : reverse_bits.c\nAllowed functions:\n--------------------------------------------------------------------------------\n\nWrite a function that takes a byte, reverses it, bit by bit (like the\nexample) and returns the result.\n\nYour function must be declared as follows:\n\nunsigned char\treverse_bits(unsigned char octet);\n\nExample:\n\n  1 byte\n_____________\n 0100  0001\n     ||\n     \\/\n 1000  0010\n\n--------------------------------------------------------------------------------\n\n #include <unistd.h>\nint\tmain(void)\n{\n\tunsigned char c = '.';\n\twrite(1, &c, 1);\n\twrite(1, \"\\n\", 1);\n\tc = reverse_bits(c);\n\twrite(1, &c, 1);\n\twrite(1, \"\\n\", 1);\n}\n```\n### Code:\n```c\nunsigned char\treverse_bits(unsigned char octet)\n{\n\tunsigned char\tout = 0;\n\n\tout = out | ((octet & 128) >> 7);\n\tout = out | ((octet & 64) >> 5);\n\tout = out | ((octet & 32) >> 3);\n\tout = out | ((octet & 16) >> 1);\n\tout = out | ((octet & 8) << 1);\n\tout = out | ((octet & 4) << 3);\n\tout = out | ((octet & 2) << 5);\n\tout = out | ((octet & 1) << 7);\n\treturn (out);\n}\n```",
            "FR": "## reverse_bits\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : reverse_bits\nFichiers attendus : reverse_bits.c\nFonctions autorisées :\n--------------------------------------------------------------------------------\n\nÉcrire une fonction qui prend un octet, l'inverse bit par bit (comme l'exemple) et retourne le résultat.\n\nVotre fonction doit être déclarée comme suit :\n\nunsigned char\treverse_bits(unsigned char octet);\n\nExemple:\n\n  1 byte\n_____________\n 0100  0001\n     ||\n     \\/\n 1000  0010\n\n--------------------------------------------------------------------------------\n\n #include <unistd.h>\nint\tmain(void)\n{\n\tunsigned char c = '.';\n\twrite(1, &c, 1);\n\twrite(1, \"\\n\", 1);\n\tc = reverse_bits(c);\n\twrite(1, &c, 1);\n\twrite(1, \"\\n\", 1);\n}\n```\n### Code:\n```c\nunsigned char\treverse_bits(unsigned char octet)\n{\n\tunsigned char\tout = 0;\n\n\tout = out | ((octet & 128) >> 7);\n\tout = out | ((octet & 64) >> 5);\n\tout = out | ((octet & 32) >> 3);\n\tout = out | ((octet & 16) >> 1);\n\tout = out | ((octet & 8) << 1);\n\tout = out | ((octet & 4) << 3);\n\tout = out | ((octet & 2) << 5);\n\tout = out | ((octet & 1) << 7);\n\treturn (out);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## snake_to_camel\n\n---\n\n### Subject:\n```text\nAssignment name  : snake_to_camel\nExpected files   : snake_to_camel.c\nAllowed functions: malloc, free, realloc, write\n--------------------------------------------------------------------------------\n\nWrite a program that takes a single string in snake_case format\nand converts it into a string in lowerCamelCase format.\n\nA snake_case string is a string where each word is in lower case, separated by\nan underscore \"_\".\n\nA lowerCamelCase string is a string where each word begins with a capital letter\nexcept for the first one.\n\nExamples:\n$>./camel_to_snake \"here_is_a_snake_case_word\"\nhereIsASnakeCaseWord\n$>./camel_to_snake \"hello_world\" | cat -e\nhelloWorld$\n$>./camel_to_snake | cat -e\n$\n```\n### Code:\n```c\n#include <unistd.h>\n\nint\t\tmain(int argc, char **argv)\n{\n\tint\ti = 0;\n\n\tif (argc == 2)\n\t\twhile (argv[1][i] != '\\0')\n\t\t{\n\t\t\tif (argv[1][i] == '_')\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t\targv[1][i] = argv[1][i] - ('a' - 'A');//put space\n\t\t\t}\n\t\t\twrite(1, &argv[1][i], 1);\n\t\t\ti++;\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```",
            "FR": "## snake_to_camel\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : snake_to_camel\nFichiers attendus : snake_to_camel.c\nFonctions autorisées : malloc, free, realloc, write\n--------------------------------------------------------------------------------\n\nÉcrire un programme qui prend une seule chaîne de caractères au format snake_case\net la convertit en une chaîne au format lowerCamelCase.\n\nUne chaîne snake_case est une chaîne où chaque mot est en minuscule, séparé par\nun underscore \"_\".\n\nUne chaîne lowerCamelCase est une chaîne où chaque mot commence par une lettre majuscule\nsauf le premier.\n\nExemples:\n$>./camel_to_snake \"here_is_a_snake_case_word\"\nhereIsASnakeCaseWord\n$>./camel_to_snake \"hello_world\" | cat -e\nhelloWorld$\n$>./camel_to_snake | cat -e\n$\n```\n### Code:\n```c\n#include <unistd.h>\n\nint\t\tmain(int argc, char **argv)\n{\n\tint\ti = 0;\n\n\tif (argc == 2)\n\t\twhile (argv[1][i] != '\\0')\n\t\t{\n\t\t\tif (argv[1][i] == '_')\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t\targv[1][i] = argv[1][i] - ('a' - 'A');//put space\n\t\t\t}\n\t\t\twrite(1, &argv[1][i], 1);\n\t\t\ti++;\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## swap_bits\n\n---\n\n### Subject:\n```text\nAssignment name  : swap_bits\nExpected files   : swap_bits.c\nAllowed functions:\n--------------------------------------------------------------------------------\n\nWrite a function that takes a byte, swaps its halves (like the example) and\nreturns the result.\n\nYour function must be declared as follows:\n\nunsigned char\tswap_bits(unsigned char octet);\n\nExample:\n\n  1 byte\n_____________\n 0100 | 0001\n     \\ /\n     / \\\n 0001 | 0100\n\n--------------------------------------------------------------------------------\n\n#include <stdio.h>\nint\t\t\t\tmain(void)\n{\n\tunsigned char test = 192;\n\tprintf(\"Should be 12: %d\\n\", swap_bits(test));\n}\n```\n### Code:\n```c\nunsigned\tchar swap_bits(unsigned char octet)\n{\n\treturn ((octet >> 4) | (octet << 4));\n}\n```",
            "FR": "## swap_bits\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : swap_bits\nFichiers attendus : swap_bits.c\nFonctions autorisées :\n--------------------------------------------------------------------------------\n\nÉcrire une fonction qui prend un octet, échange ses moitiés (comme l'exemple) et retourne le résultat.\n\nVotre fonction doit être déclarée comme suit :\n\nunsigned char\tswap_bits(unsigned char octet);\n\nExemple:\n\n  1 byte\n_____________\n 0100 | 0001\n     \\ /\n     / \\\n 0001 | 0100\n\n--------------------------------------------------------------------------------\n\n#include <stdio.h>\nint\t\t\t\tmain(void)\n{\n\tunsigned char test = 192;\n\tprintf(\"Should be 12: %d\\n\", swap_bits(test));\n}\n```\n### Code:\n```c\nunsigned\tchar swap_bits(unsigned char octet)\n{\n\treturn ((octet >> 4) | (octet << 4));\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-8",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "# Level 3\n\n---\n\n## epur_str\n\n---\n\n### Subject:\n```text\nAssignment name  : epur_str\nExpected files   : epur_str.c\nAllowed functions: write\n--------------------------------------------------------------------------------\n\nWrite a program that takes a string, and displays this string with exactly one\nspace between words, with no spaces or tabs either at the beginning or the end,\nfollowed by a \\n.\n\nA \"word\" is defined as a part of a string delimited either by spaces/tabs, or\nby the start/end of the string.\n\nIf the number of arguments is not 1, or if there are no words to display, the\nprogram displays \\n.\n\nExample:\n\n$> ./epur_str \"vous voyez c'est facile d'afficher la meme chose\" | cat -e\nvous voyez c'est facile d'afficher la meme chose$\n$> ./epur_str \" seulement          la c'est      plus dur \" | cat -e\nseulement la c'est plus dur$\n$> ./epur_str \"comme c'est cocasse\" \"vous avez entendu, Mathilde ?\" | cat -e\n$\n$> ./epur_str \"\" | cat -e\n$\n$>\n```\n### Code:\n```c\n#include <unistd.h>\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\n\ti = 0;\n\tif (ac == 2)\n\t{\n\t\twhile (av[1][i] == ' ' || av[1][i] == '\\t')\n\t\t\ti++;\n\t\twhile (av[1][i] != '\\0')\n\t\t{\n\t\t\tif (av[1][i] == ' ' || av[1][i] == '\\t')\n\t\t\t{\n\t\t\t\tif (av[1][i + 1] > 32 && av[1][i + 1] != '\\0')\n\t\t\t\t\twrite(1, \" \", 1);\n\t\t\t}\n\t\t\telse if (av[1][i] != ' ' && av[1][i] != '\\t')\n\t\t\t\twrite(1, &av[1][i], 1);\n\t\t\ti++;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```",
            "FR": "# Niveau 3\n\n---\n\n## epur_str\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : epur_str\nFichiers attendus : epur_str.c\nFonctions autorisées : write\n--------------------------------------------------------------------------------\n\nÉcrire un programme qui prend une chaîne de caractères et affiche cette chaîne avec exactement un espace entre les mots, sans espaces ni tabulations au début ou à la fin, suivi d'un \\n.\n\nUn \"mot\" est défini comme une partie d'une chaîne délimitée soit par des espaces/tabulations, soit par le début/la fin de la chaîne.\n\nSi le nombre d'arguments n'est pas 1, ou s'il n'y a pas de mots à afficher, le programme affiche \\n.\n\nExemple:\n\n$> ./epur_str \"vous voyez c'est facile d'afficher la meme chose\" | cat -e\nvous voyez c'est facile d'afficher la meme chose$\n$> ./epur_str \" seulement          la c'est      plus dur \" | cat -e\nseulement la c'est plus dur$\n$> ./epur_str \"comme c'est cocasse\" \"vous avez entendu, Mathilde ?\" | cat -e\n$\n$> ./epur_str \"\" | cat -e\n$\n$>\n```\n### Code:\n```c\n#include <unistd.h>\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\n\ti = 0;\n\tif (ac == 2)\n\t{\n\t\twhile (av[1][i] == ' ' || av[1][i] == '\\t')\n\t\t\ti++;\n\t\twhile (av[1][i] != '\\0')\n\t\t{\n\t\t\tif (av[1][i] == ' ' || av[1][i] == '\\t')\n\t\t\t{\n\t\t\t\tif (av[1][i + 1] > 32 && av[1][i + 1] != '\\0')\n\t\t\t\t\twrite(1, \" \", 1);\n\t\t\t}\n\t\t\telse if (av[1][i] != ' ' && av[1][i] != '\\t')\n\t\t\t\twrite(1, &av[1][i], 1);\n\t\t\ti++;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## expand_str\n\n---\n\n### Subject:\n```text\nAssignment name  : expand_str\nExpected files   : expand_str.c\nAllowed functions: write\n--------------------------------------------------------------------------------\n\nWrite a program that takes a string and displays it with exactly three spaces\nbetween each word, with no spaces or tabs either at the beginning or the end,\nfollowed by a newline.\n\nA word is a section of string delimited either by spaces/tabs, or by the\nstart/end of the string.\n\nIf the number of parameters is not 1, or if there are no words, simply display\na newline.\n\nExamples:\n\n$> ./expand_str \"vous   voyez   c'est   facile   d'afficher   la   meme   chose\" | cat -e\nvous   voyez   c'est   facile   d'afficher   la   meme   chose$\n$> ./expand_str \" seulement          la c'est      plus dur \" | cat -e\nseulement   la   c'est   plus   dur$\n$> ./expand_str \"comme c'est cocasse\" \"vous avez entendu, Mathilde ?\" | cat -e\n$\n$> ./expand_str \"\" | cat -e\n$\n$>\n```\n### Code:\n```c\n#include <unistd.h>\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\n\ti = 0;\n\tif (ac == 2)\n\t{\n\t\twhile (av[1][i] == ' ' || av[1][i] == '\\t')\n\t\t\ti++;\n\t\twhile (av[1][i] != '\\0')\n\t\t{\n\t\t\tif (av[1][i] == ' ' || av[1][i] == '\\t')\n\t\t\t{\n\t\t\t\tif (av[1][i + 1] > 32 && av[1][i + 1] != '\\0')\n\t\t\t\t\twrite(1, \"   \", 3);\n\t\t\t}\n\t\t\telse if (av[1][i] != ' ' && av[1][i] != '\\t')\n\t\t\t\twrite(1, &av[1][i], 1);\n\t\t\ti++;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```",
            "FR": "## expand_str\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : expand_str\nFichiers attendus : expand_str.c\nFonctions autorisées : write\n--------------------------------------------------------------------------------\n\nÉcrire un programme qui prend une chaîne de caractères et l'affiche avec exactement trois espaces entre chaque mot, sans espaces ni tabulations au début ou à la fin, suivi d'une nouvelle ligne.\n\nUn mot est une section de chaîne délimitée soit par des espaces/tabulations, soit par le début/la fin de la chaîne.\n\nSi le nombre de paramètres n'est pas 1, ou s'il n'y a pas de mots, afficher simplement une nouvelle ligne.\n\nExemples:\n\n$> ./expand_str \"vous   voyez   c'est   facile   d'afficher   la   meme   chose\" | cat -e\nvous   voyez   c'est   facile   d'afficher   la   meme   chose$\n$> ./expand_str \" seulement          la c'est      plus dur \" | cat -e\nseulement   la   c'est   plus   dur$\n$> ./expand_str \"comme c'est cocasse\" \"vous avez entendu, Mathilde ?\" | cat -e\n$\n$> ./expand_str \"\" | cat -e\n$\n$>\n```\n### Code:\n```c\n#include <unistd.h>\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\n\ti = 0;\n\tif (ac == 2)\n\t{\n\t\twhile (av[1][i] == ' ' || av[1][i] == '\\t')\n\t\t\ti++;\n\t\twhile (av[1][i] != '\\0')\n\t\t{\n\t\t\tif (av[1][i] == ' ' || av[1][i] == '\\t')\n\t\t\t{\n\t\t\t\tif (av[1][i + 1] > 32 && av[1][i + 1] != '\\0')\n\t\t\t\t\twrite(1, \"   \", 3);\n\t\t\t}\n\t\t\telse if (av[1][i] != ' ' && av[1][i] != '\\t')\n\t\t\t\twrite(1, &av[1][i], 1);\n\t\t\ti++;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## ft_atoi_base\n\n---\n\n### Subject:\n```text\nAssignment name  : ft_atoi_base\nExpected files   : ft_atoi_base.c\nAllowed functions: None\n--------------------------------------------------------------------------------\n\nWrite a function that converts the string argument str (base N <= 16)\nto an integer (base 10) and returns it.\n\nThe characters recognized in the input are: 0123456789abcdef\nThose are, of course, to be trimmed according to the requested base. For\nexample, base 4 recognizes \"0123\" and base 16 recognizes \"0123456789abcdef\".\n\nUppercase letters must also be recognized: \"12fdb3\" is the same as \"12FDB3\".\n\nMinus signs ('-') are interpreted only if they are the first character of the\nstring.\n\nYour function must be declared as follows:\n\nint\tft_atoi_base(const char *str, int str_base);\n```\n### Code:\n```c\nint\t\tft_atoi_base(const char *str, int str_base)\n{\n\tint i;\n\tint n;\n\tint len;\n\tint result;\n\n\ti = 0;\n\tn = 1;\n\tresult = 0;\n\tif (str[i] == '-')\n\t{\n\t\tn = -1;\n\t\ti++;\n\t}\n\twhile (str[i] != '\\0')\n\t{\n\t\tresult *= str_base;\n\t\tif (str[i] >= '0' && str[i] <= '9')\n\t\t\tresult += str[i] - 48;\n\t\telse if (str[i] >= 'A' && str[i] <= 'Z')\n\t\t\tresult += str[i] - 55;\n\t\telse if (str[i] >= 'a' && str[i] <= 'z')\n\t\t\tresult += str[i] - 87;\n\t\ti++;\n\t}\n\treturn (result * n);\n}\n```",
            "FR": "## ft_atoi_base\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : ft_atoi_base\nFichiers attendus : ft_atoi_base.c\nFonctions autorisées : None\n--------------------------------------------------------------------------------\n\nÉcrire une fonction qui convertit l'argument de chaîne str (base N <= 16) en un entier (base 10) et le retourne.\n\nLes caractères reconnus en entrée sont : 0123456789abcdef\nCeux-ci doivent bien sûr être ajustés en fonction de la base demandée. Par exemple, la base 4 reconnaît \"0123\" et la base 16 reconnaît \"0123456789abcdef\".\n\nLes lettres majuscules doivent également être reconnues : \"12fdb3\" est identique à \"12FDB3\".\n\nLes signes moins ('-') ne sont interprétés que s'ils sont le premier caractère de la chaîne.\n\nVotre fonction doit être déclarée comme suit :\n\nint\tft_atoi_base(const char *str, int str_base);\n```\n### Code:\n```c\nint\t\tft_atoi_base(const char *str, int str_base)\n{\n\tint i;\n\tint n;\n\tint len;\n\tint result;\n\n\ti = 0;\n\tn = 1;\n\tresult = 0;\n\tif (str[i] == '-')\n\t{\n\t\tn = -1;\n\t\ti++;\n\t}\n\twhile (str[i] != '\\0')\n\t{\n\t\tresult *= str_base;\n\t\tif (str[i] >= '0' && str[i] <= '9')\n\t\t\tresult += str[i] - 48;\n\t\telse if (str[i] >= 'A' && str[i] <= 'Z')\n\t\t\tresult += str[i] - 55;\n\t\telse if (str[i] >= 'a' && str[i] <= 'z')\n\t\t\tresult += str[i] - 87;\n\t\ti++;\n\t}\n\treturn (result * n);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## ft_list_size\n\n---\n\n### Subject:\n```text\nAssignment name  : ft_list_size\nExpected files   : ft_list_size.c, ft_list.h\nAllowed functions: \n--------------------------------------------------------------------------------\n\nWrite a function that returns the number of elements in the linked list that's\npassed to it.\n\nIt must be declared as follows:\n\nint\tft_list_size(t_list *begin_list);\n\nYou must use the following structure, and turn it in as a file called\nft_list.h:\n\ntypedef struct    s_list\n{\n    struct s_list *next;\n    void          *data;\n}                 t_list;\n```\n### Code:\n```c\nint\t\tft_list_size(t_list *begin_list)\n{\n\tt_list *list;\n\tint i;\n\n\tlist = begin_list;\n\ti = 0;\n\twhile (list)\n\t{\n\t\tlist = list->next;\n\t\ti++;\n\t}\n\treturn (i);\n}\n```",
            "FR": "## ft_list_size\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : ft_list_size\nFichiers attendus : ft_list_size.c, ft_list.h\nFonctions autorisées :\n--------------------------------------------------------------------------------\n\nÉcrire une fonction qui renvoie le nombre d'éléments dans la liste chaînée qui lui est passée.\n\nElle doit être déclarée comme suit :\n\nint\tft_list_size(t_list *begin_list);\n\nVous devez utiliser la structure suivante et la rendre dans un fichier appelé ft_list.h :\n\ntypedef struct    s_list\n{\n    struct s_list *next;\n    void          *data;\n}                 t_list;\n```\n### Code:\n```c\nint\t\tft_list_size(t_list *begin_list)\n{\n\tt_list *list;\n\tint i;\n\n\tlist = begin_list;\n\ti = 0;\n\twhile (list)\n\t{\n\t\tlist = list->next;\n\t\ti++;\n\t}\n\treturn (i);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## hidenp\n\n---\n\n### Subject:\n```text\nAssignment name  : hidenp\nExpected files   : hidenp.c\nAllowed functions: write\n--------------------------------------------------------------------------------\n\nWrite a program named hidenp that takes two strings and displays 1\nfollowed by a newline if the first string is hidden in the second one,\notherwise displays 0 followed by a newline.\n\nLet s1 and s2 be strings. We say that s1 is hidden in s2 if it's possible to\nfind each character from s1 in s2, in the same order as they appear in s1.\nAlso, the empty string is hidden in any string.\n\nIf the number of parameters is not 2, the program displays a newline.\n\nExamples :\n\n$>./hidenp \"fgex.;\" \"tyf34gdgf;'ektufjhgdgex.;.;rtjynur6\" | cat -e\n1$\n$>./hidenp \"abc\" \"2altrb53c.sse\" | cat -e\n1$\n$>./hidenp \"abc\" \"btarc\" | cat -e\n0$\n$>./hidenp | cat -e\n$\n$>\n```\n### Code:\n```c\n#include <unistd.h>\n\nint main(int ac, char **av)\n{\n\tint i = 0;\n\tint j = 0;\n\n\tif (ac == 3)\n\t{\n\t\twhile (av[1][i] != '\\0')\n\t\t{\n\t\t\tif (av[1][i] == av[2][j])\n\t\t\t\ti++;\n\t\t\tif (av[2][j] == '\\0')\n\t\t\t{\n\t\t\t\twrite(1, \"0\\n\", 2);\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\twrite(1, \"1\", 1);\n\t}\n\twrite (1, \"\\n\", 1);\n\treturn (0);\n}\n```",
            "FR": "## hidenp\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : hidenp\nFichiers attendus : hidenp.c\nFonctions autorisées : write\n--------------------------------------------------------------------------------\n\nÉcrire un programme nommé hidenp qui prend deux chaînes de caractères et affiche 1 suivi d'une nouvelle ligne si la première chaîne est cachée dans la seconde, sinon affiche 0 suivi d'une nouvelle ligne.\n\nSoient s1 et s2 des chaînes de caractères. On dit que s1 est cachée dans s2 s'il est possible de trouver chaque caractère de s1 dans s2, dans le même ordre que leur apparition dans s1. De plus, la chaîne vide est cachée dans n'importe quelle chaîne.\n\nSi le nombre de paramètres n'est pas 2, le programme affiche une nouvelle ligne.\n\nExemples :\n\n$>./hidenp \"fgex.;\" \"tyf34gdgf;'ektufjhgdgex.;.;rtjynur6\" | cat -e\n1$\n$>./hidenp \"abc\" \"2altrb53c.sse\" | cat -e\n1$\n$>./hidenp \"abc\" \"btarc\" | cat -e\n0$\n$>./hidenp | cat -e\n$\n$>\n```\n### Code:\n```c\n#include <unistd.h>\n\nint main(int ac, char **av)\n{\n\tint i = 0;\n\tint j = 0;\n\n\tif (ac == 3)\n\t{\n\t\twhile (av[1][i] != '\\0')\n\t\t{\n\t\t\tif (av[1][i] == av[2][j])\n\t\t\t\ti++;\n\t\t\tif (av[2][j] == '\\0')\n\t\t\t{\n\t\t\t\twrite(1, \"0\\n\", 2);\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\twrite(1, \"1\", 1);\n\t}\n\twrite (1, \"\\n\", 1);\n\treturn (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## lcm\n\n---\n\n### Subject:\n```text\nAssignment name  : lcm\nExpected files   : lcm.c\nAllowed functions:\n--------------------------------------------------------------------------------\n\nWrite a function who takes two unsigned int as parameters and returns the \ncomputed LCM of those parameters.\n\nLCM (Lowest Common Multiple) of two non-zero integers is the smallest postive\ninteger divisible by the both integers.\n\nA LCM can be calculated in two ways:\n\n- You can calculate every multiples of each integers until you have a common\nmultiple other than 0\n\n- You can use the HCF (Highest Common Factor) of these two integers and \ncalculate as follows:\n\n\tLCM(x, y) = | x * y | / HCF(x, y)\n  \n  | x * y | means \"Absolute value of the product of x by y\"\n\nIf at least one integer is null, LCM is equal to 0.\n\nYour function must be prototyped as follows:\n\n  unsigned int    lcm(unsigned int a, unsigned int b);```\n### Code:\n```c\nunsigned int\tlcm(unsigned int a, unsigned int b)\n{\n\tunsigned int\ti;\n\n\ti = a;\n\tif (a == 0 || b == 0)\n\t\treturn (0);\n\twhile (i >= a)\n\t{\n\t\tif (i % a == 0 && i % b == 0)\n\t\t\treturn (i);\n\t\ti++;\n\t}\n\treturn (0);\n}\n```",
            "FR": "## lcm\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : lcm\nFichiers attendus : lcm.c\nFonctions autorisées :\n--------------------------------------------------------------------------------\n\nÉcrire une fonction qui prend deux unsigned int comme paramètres et renvoie le PPCM (plus petit commun multiple) de ces paramètres.\n\nLe PPCM (plus petit commun multiple) de deux entiers non nuls est le plus petit entier positif divisible par les deux entiers.\n\nUn PPCM peut être calculé de deux manières :\n\n- Vous pouvez calculer tous les multiples de chaque entier jusqu'à ce que vous ayez un multiple commun autre que 0\n\n- Vous pouvez utiliser le PGCD (plus grand commun diviseur) de ces deux entiers et calculer comme suit :\n\nPPCM(x, y) = | x * y | / PGCD(x, y)\n\n| x * y | signifie \"Valeur absolue du produit de x par y\"\n\nSi au moins un entier est nul, le PPCM est égal à 0.\n\nVotre fonction doit être prototypée comme suit :\n\n  unsigned int    lcm(unsigned int a, unsigned int b);```\n### Code:\n```c\nunsigned int\tlcm(unsigned int a, unsigned int b)\n{\n\tunsigned int\ti;\n\n\ti = a;\n\tif (a == 0 || b == 0)\n\t\treturn (0);\n\twhile (i >= a)\n\t{\n\t\tif (i % a == 0 && i % b == 0)\n\t\t\treturn (i);\n\t\ti++;\n\t}\n\treturn (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## paramsum\n\n---\n\n### Subject:\n```text\nAssignment name  : paramsum\nExpected files   : paramsum.c\nAllowed functions: write\n--------------------------------------------------------------------------------\n\nWrite a program that displays the number of arguments passed to it, followed by\na newline.\n\nIf there are no arguments, just display a 0 followed by a newline.\n\nExample:\n\n$>./paramsum 1 2 3 5 7 24\n6\n$>./paramsum 6 12 24 | cat -e\n3$\n$>./paramsum | cat -e\n0$\n$>\n```\n### Code:\n```c\nvoid\tputnbr(int i)\n{\n\tif (i > 9)\n\t\tputnbr(i / 10);\n\ti = i % 10 + '0';\n\twrite(1, &i, 1);\n}\n\nint main(int ac, char **av)\n{\n\t(void)av;\n\tputnbr(ac - 1);\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```",
            "FR": "## paramsum\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : paramsum\nFichiers attendus : paramsum.c\nFonctions autorisées : write\n--------------------------------------------------------------------------------\n\nÉcrire un programme qui affiche le nombre d'arguments qui lui sont passés, suivi d'une nouvelle ligne.\n\nS'il n'y a pas d'arguments, afficher simplement un 0 suivi d'une nouvelle ligne.\n\nExemple:\n\n$>./paramsum 1 2 3 5 7 24\n6\n$>./paramsum 6 12 24 | cat -e\n3$\n$>./paramsum | cat -e\n0$\n$>\n```\n### Code:\n```c\nvoid\tputnbr(int i)\n{\n\tif (i > 9)\n\t\tputnbr(i / 10);\n\ti = i % 10 + '0';\n\twrite(1, &i, 1);\n}\n\nint main(int ac, char **av)\n{\n\t(void)av;\n\tputnbr(ac - 1);\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## pgcd\n\n---\n\n### Subject:\n```text\nAssignment name  : pgcd\nExpected files   : pgcd.c\nAllowed functions: printf, atoi, malloc, free\n--------------------------------------------------------------------------------\n\nWrite a program that takes two strings representing two strictly positive\nintegers that fit in an int.\n\nDisplay their highest common denominator followed by a newline (It's always a\nstrictly positive integer).\n\nIf the number of parameters is not 2, display a newline.\n\nExamples:\n\n$> ./pgcd 42 10 | cat -e\n2$\n$> ./pgcd 42 12 | cat -e\n6$\n$> ./pgcd 14 77 | cat -e\n7$\n$> ./pgcd 17 3 | cat -e \n1$\n$> ./pgcd | cat -e\n$\n```\n### Code:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid\tpgcd(int a, int b)\n{\n\tint i;\n\tint gcd;\n\n\ti = 1;\n\tgcd = 0;\n\twhile (i < a && i < b)\n\t{\n\t\tif (a % i == 0 && b % i == 0)\n\t\t\tgcd = i;\n\t\ti++;\n\t}\n\tprintf(\"%d\", gcd);\n}\n\nint\t\tmain(int ac, char **av)\n{\n\tif (ac == 3)\n\t\tpgcd(atoi(av[1]), atoi(av[2]));\n\tprintf(\"\\n\");\n\treturn (0);\n}\n```",
            "FR": "## pgcd\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : pgcd\nFichiers attendus : pgcd.c\nFonctions autorisées : printf, atoi, malloc, free\n--------------------------------------------------------------------------------\n\nÉcrire un programme qui prend deux chaînes de caractères représentant deux entiers strictement positifs qui tiennent dans un int.\n\nAffichez leur plus grand commun diviseur suivi d'une nouvelle ligne (c'est toujours un entier strictement positif).\n\nSi le nombre de paramètres n'est pas 2, afficher une nouvelle ligne.\n\nExemples:\n\n$> ./pgcd 42 10 | cat -e\n2$\n$> ./pgcd 42 12 | cat -e\n6$\n$> ./pgcd 14 77 | cat -e\n7$\n$> ./pgcd 17 3 | cat -e \n1$\n$> ./pgcd | cat -e\n$\n```\n### Code:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid\tpgcd(int a, int b)\n{\n\tint i;\n\tint gcd;\n\n\ti = 1;\n\tgcd = 0;\n\twhile (i < a && i < b)\n\t{\n\t\tif (a % i == 0 && b % i == 0)\n\t\t\tgcd = i;\n\t\ti++;\n\t}\n\tprintf(\"%d\", gcd);\n}\n\nint\t\tmain(int ac, char **av)\n{\n\tif (ac == 3)\n\t\tpgcd(atoi(av[1]), atoi(av[2]));\n\tprintf(\"\\n\");\n\treturn (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## print_hex\n\n---\n\n### Subject:\n```text\nAssignment name  : print_hex\nExpected files   : print_hex.c\nAllowed functions: write\n--------------------------------------------------------------------------------\n\nWrite a program that takes a positive (or zero) number expressed in base 10,\nand displays it in base 16 (lowercase letters) followed by a newline.\n\nIf the number of parameters is not 1, the program displays a newline.\n\nExamples:\n\n$> ./print_hex \"10\" | cat -e\na$\n$> ./print_hex \"255\" | cat -e\nff$\n$> ./print_hex \"5156454\" | cat -e\n4eae66$\n$> ./print_hex | cat -e\n$\n```\n### Code:\n```c\n#include <unistd.h>\n\nvoid\tprint_hex(int n)\n{\n\tchar\tc[] = \"0123456789abcdef\";\n\n\tif (n >= 16)\n\t\tprint_hex(n / 16);\n\twrite(1, &c[n % 16], 1);\n}\n\nint\tmain(int argc, char **argv)\n{\n\tint\ti = 0;\n\tint\tn = 0;\n\n\tif(argc == 2)\n\t{\n\t\twhile (argv[1][i] != 0)\n\t\t{\n\t\t\tn = n * 10 + (argv[1][i] - '0');\n\t\t\ti++;\n\t\t}\n\t\tprint_hex(n);\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```",
            "FR": "## print_hex\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : print_hex\nFichiers attendus : print_hex.c\nFonctions autorisées : write\n--------------------------------------------------------------------------------\n\nÉcrire un programme qui prend un nombre positif (ou zéro) exprimé en base 10,\net l'affiche en base 16 (lettres minuscules) suivi d'une nouvelle ligne.\n\nSi le nombre de paramètres n'est pas 1, le programme affiche une nouvelle ligne.\n\nExemples:\n\n$> ./print_hex \"10\" | cat -e\na$\n$> ./print_hex \"255\" | cat -e\nff$\n$> ./print_hex \"5156454\" | cat -e\n4eae66$\n$> ./print_hex | cat -e\n$\n```\n### Code:\n```c\n#include <unistd.h>\n\nvoid\tprint_hex(int n)\n{\n\tchar\tc[] = \"0123456789abcdef\";\n\n\tif (n >= 16)\n\t\tprint_hex(n / 16);\n\twrite(1, &c[n % 16], 1);\n}\n\nint\tmain(int argc, char **argv)\n{\n\tint\ti = 0;\n\tint\tn = 0;\n\n\tif(argc == 2)\n\t{\n\t\twhile (argv[1][i] != 0)\n\t\t{\n\t\t\tn = n * 10 + (argv[1][i] - '0');\n\t\t\ti++;\n\t\t}\n\t\tprint_hex(n);\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## rstr_capitalizer\n\n---\n\n### Subject:\n```text\nAssignment name  : rstr_capitalizer\nExpected files   : rstr_capitalizer.c\nAllowed functions: write\n--------------------------------------------------------------------------------\n\nWrite a program that takes one or more strings and, for each argument, puts \nthe last character of each word (if it's a letter) in uppercase and the rest\nin lowercase, then displays the result followed by a \\n.\n\nA word is a section of string delimited by spaces/tabs or the start/end of the\nstring. If a word has a single letter, it must be capitalized.\n\nIf there are no parameters, display \\n.\n\nExamples:\n\n$> ./rstr_capitalizer | cat -e\n$\n$> ./rstr_capitalizer \"Premier PETIT TesT\" | cat -e\npremieR petiT tesT$\n$> ./rstr_capitalizer \"DeuxiEmE tEST uN PEU moinS  facile\" \"   attention C'EST pas dur QUAND mEmE\" \"ALLer UN DeRNier 0123456789pour LA rouTE    E \" | cat -e\ndeuxiemE tesT uN peU moinS  facilE$\n   attentioN c'esT paS duR quanD memE$\nalleR uN dernieR 0123456789pouR lA routE    E $\n$>\n```\n### Code:\n```c\n#include <unistd.h>\n\nint\t\tft_to_lower(char c, char d)\n{\n\tif (c >= 'A' && c <= 'Z')\n\t{\n\t\tif (d != ' ' && d != '\\t' && d != '\\0')\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nint\t\tft_to_upper(char c, char d)\n{\n\tif (c >= 'a' && c <= 'z')\n\t{\n\t\tif (d == ' ' || d == '\\t' || d == '\\0')\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\tint i2;\n\n\ti = 0;\n\tif (ac > 1)\n\t{\n\t\twhile (i < ac)\n\t\t{\n\t\t\ti++;\n\t\t\ti2 = 0;\n\t\t\twhile (av[i][i2] != '\\0')\n\t\t\t{\n\t\t\t\tif (ft_to_upper(av[i][i2], av[i][i2 + 1]))\n\t\t\t\t\tav[i][i2] -= 32;\n\t\t\t\telse if (ft_to_lower(av[i][i2], av[i][i2 + 1]))\n\t\t\t\t\tav[i][i2] += 32;\n\t\t\t\twrite(1, &av[i][i2], 1);\n\t\t\t\ti2++;\n\t\t\t}\n\t\t\twrite(1, \"\\n\", 1);\n\t\t}\n\t}\n\telse\n\t\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```",
            "FR": "## rstr_capitalizer\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : rstr_capitalizer\nFichiers attendus : rstr_capitalizer.c\nFonctions autorisées : write\n--------------------------------------------------------------------------------\n\nÉcrire un programme qui prend une ou plusieurs chaînes de caractères et, pour chaque argument, met le dernier caractère de chaque mot (si c'est une lettre) en majuscule et le reste en minuscule, puis affiche le résultat suivi d'un \\n.\n\nUn mot est une section de chaîne délimitée par des espaces/tabulations ou le début/la fin de la chaîne. Si un mot n'a qu'une seule lettre, elle doit être mise en majuscule.\n\nS'il n'y a pas de paramètres, afficher \\n.\n\nExemples:\n\n$> ./rstr_capitalizer | cat -e\n$\n$> ./rstr_capitalizer \"Premier PETIT TesT\" | cat -e\npremieR petiT tesT$\n$> ./rstr_capitalizer \"DeuxiEmE tEST uN PEU moinS  facile\" \"   attention C'EST pas dur QUAND mEmE\" \"ALLer UN DeRNier 0123456789pour LA rouTE    E \" | cat -e\ndeuxiemE tesT uN peU moinS  facilE$\n   attentioN c'esT paS duR quanD memE$\nalleR uN dernieR 0123456789pouR lA routE    E $\n$>\n```\n### Code:\n```c\n#include <unistd.h>\n\nint\t\tft_to_lower(char c, char d)\n{\n\tif (c >= 'A' && c <= 'Z')\n\t{\n\t\tif (d != ' ' && d != '\\t' && d != '\\0')\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nint\t\tft_to_upper(char c, char d)\n{\n\tif (c >= 'a' && c <= 'z')\n\t{\n\t\tif (d == ' ' || d == '\\t' || d == '\\0')\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\tint i2;\n\n\ti = 0;\n\tif (ac > 1)\n\t{\n\t\twhile (i < ac)\n\t\t{\n\t\t\ti++;\n\t\t\ti2 = 0;\n\t\t\twhile (av[i][i2] != '\\0')\n\t\t\t{\n\t\t\t\tif (ft_to_upper(av[i][i2], av[i][i2 + 1]))\n\t\t\t\t\tav[i][i2] -= 32;\n\t\t\t\telse if (ft_to_lower(av[i][i2], av[i][i2 + 1]))\n\t\t\t\t\tav[i][i2] += 32;\n\t\t\t\twrite(1, &av[i][i2], 1);\n\t\t\t\ti2++;\n\t\t\t}\n\t\t\twrite(1, \"\\n\", 1);\n\t\t}\n\t}\n\telse\n\t\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## str_capitalizer\n\n---\n\n### Subject:\n```text\nAssignment name  : str_capitalizer\nExpected files   : str_capitalizer.c\nAllowed functions: write\n--------------------------------------------------------------------------------\n\nWrite a program that takes one or several strings and, for each argument,\ncapitalizes the first character of each word (If it's a letter, obviously),\nputs the rest in lowercase, and displays the result on the standard output,\nfollowed by a \\n.\n\nA \"word\" is defined as a part of a string delimited either by spaces/tabs, or\nby the start/end of the string. If a word only has one letter, it must be\ncapitalized.\n\nIf there are no arguments, the progam must display \\n.\n\nExample:\n\n$> ./str_capitalizer | cat -e\n$\n$> ./str_capitalizer \"Premier PETIT TesT\" | cat -e\nPremier Petit Test$\n$> ./str_capitalizer \"DeuxiEmE tEST uN PEU moinS  facile\" \"   attention C'EST pas dur QUAND mEmE\" \"ALLer UN DeRNier 0123456789pour LA rouTE    E \" | cat -e\nDeuxieme Test Un Peu Moins  Facile$\n   Attention C'est Pas Dur Quand Meme$\nAller Un Dernier 0123456789pour La Route    E $\n$>\n```\n### Code:\n```c\n#include <unistd.h>\n\nint\t\tft_to_lower(char c, char d, int i)\n{\n\tif (c != ' ' && c != '\\t' && i != -1)\n\t{\n\t\tif (d >= 'A' && d <= 'Z')\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nint\t\tft_to_upper(char c, char d)\n{\n\tif (c == ' ' || c == '\\t')\n\t{\n\t\tif (d >= 'a' && d <= 'z')\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\tint i2;\n\n\ti = 0;\n\tif (ac > 1)\n\t{\n\t\twhile (i < ac)\n\t\t{\n\t\t\ti++;\n\t\t\ti2 = 0;\n\t\t\twhile (av[i][i2] != '\\0')\n\t\t\t{\n\t\t\t\tif (av[i][0] >= 'a' && av[i][0] <= 'z')\n\t\t\t\t\tav[i][0] -= 32;\n\t\t\t\telse if (ft_to_lower(av[i][i2 - 1], av[i][i2], i2 - 1))\n\t\t\t\t\tav[i][i2] += 32;\n\t\t\t\telse if (ft_to_upper(av[i][i2 - 1], av[i][i2]))\n\t\t\t\t\tav[i][i2] -= 32;\n\t\t\t\twrite(1, &av[i][i2], 1);\n\t\t\t\ti2++;\n\t\t\t}\n\t\t\twrite(1, \"\\n\", 1);\n\t\t}\n\t}\n\telse\n\t\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```",
            "FR": "## str_capitalizer\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : str_capitalizer\nFichiers attendus : str_capitalizer.c\nFonctions autorisées : write\n--------------------------------------------------------------------------------\n\nÉcrire un programme qui prend une ou plusieurs chaînes de caractères et, pour chaque argument, met en majuscule la première lettre de chaque mot (si c'est une lettre, évidemment), met le reste en minuscule et affiche le résultat sur la sortie standard, suivi d'un \\n.\n\nUn \"mot\" est défini comme une partie d'une chaîne délimitée soit par des espaces/tabulations, soit par le début/la fin de la chaîne. Si un mot n'a qu'une seule lettre, elle doit être mise en majuscule.\n\nS'il n'y a pas d'arguments, le programme doit afficher \\n.\n\nExemple:\n\n$> ./str_capitalizer | cat -e\n$\n$> ./str_capitalizer \"Premier PETIT TesT\" | cat -e\nPremier Petit Test$\n$> ./str_capitalizer \"DeuxiEmE tEST uN PEU moinS  facile\" \"   attention C'EST pas dur QUAND mEmE\" \"ALLer UN DeRNier 0123456789pour LA rouTE    E \" | cat -e\nDeuxieme Test Un Peu Moins  Facile$\n   Attention C'est Pas Dur Quand Meme$\nAller Un Dernier 0123456789pour La Route    E $\n$>\n```\n### Code:\n```c\n#include <unistd.h>\n\nint\t\tft_to_lower(char c, char d, int i)\n{\n\tif (c != ' ' && c != '\\t' && i != -1)\n\t{\n\t\tif (d >= 'A' && d <= 'Z')\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nint\t\tft_to_upper(char c, char d)\n{\n\tif (c == ' ' || c == '\\t')\n\t{\n\t\tif (d >= 'a' && d <= 'z')\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\tint i2;\n\n\ti = 0;\n\tif (ac > 1)\n\t{\n\t\twhile (i < ac)\n\t\t{\n\t\t\ti++;\n\t\t\ti2 = 0;\n\t\t\twhile (av[i][i2] != '\\0')\n\t\t\t{\n\t\t\t\tif (av[i][0] >= 'a' && av[i][0] <= 'z')\n\t\t\t\t\tav[i][0] -= 32;\n\t\t\t\telse if (ft_to_lower(av[i][i2 - 1], av[i][i2], i2 - 1))\n\t\t\t\t\tav[i][i2] += 32;\n\t\t\t\telse if (ft_to_upper(av[i][i2 - 1], av[i][i2]))\n\t\t\t\t\tav[i][i2] -= 32;\n\t\t\t\twrite(1, &av[i][i2], 1);\n\t\t\t\ti2++;\n\t\t\t}\n\t\t\twrite(1, \"\\n\", 1);\n\t\t}\n\t}\n\telse\n\t\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## tab_mult\n\n---\n\n### Subject:\n```text\nAssignment name  : tab_mult\nExpected files   : tab_mult.c\nAllowed functions: write\n--------------------------------------------------------------------------------\n\nWrite a program that displays a number's multiplication table.\n\nThe parameter will always be a strictly positive number that fits in an int,\nand said number times 9 will also fit in an int.\n\nIf there are no parameters, the program displays \\n.\n\nExamples:\n\n$>./tab_mult 9\n1 x 9 = 9\n2 x 9 = 18\n3 x 9 = 27\n4 x 9 = 36\n5 x 9 = 45\n6 x 9 = 54\n7 x 9 = 63\n8 x 9 = 72\n9 x 9 = 81\n$>./tab_mult 19\n1 x 19 = 19\n2 x 19 = 38\n3 x 19 = 57\n4 x 19 = 76\n5 x 19 = 95\n6 x 19 = 114\n7 x 19 = 133\n8 x 19 = 152\n9 x 19 = 171\n$>\n$>./tab_mult | cat -e\n$\n$>\n```\n### Code:\n```c\n#include <unistd.h>\n\nvoid\tft_putnbr(int n)\n{\n\tif (n > 9)\n\t\tft_putnbr(n / 10);\n\tchar c = (n % 10) + '0';\n\twrite(1, &c, 1);\n}\n\nint\t\tmain(int argc, char **argv)\n{\n\tint n;\n\tint\ti = 0;\n\tint\tj = 1;\n\n\tif (argc == 2)\n\t{\n\t\twhile (argv[1][i] != '\\0')\n\t\t{\n\t\t\tn = n * 10 + (argv[1][i] - '0');\n\t\t\ti++;\n\t\t}\n\t\twhile (j <= 9)\n\t\t{\n\t\t\tft_putnbr(j); //put 1 to 9\n\t\t\twrite(1, \" x \", 3);\n\t\t\tft_putnbr(n); // put av[1] as int\n\t\t\twrite(1, \" = \", 3);\n\t\t\tft_putnbr(j * n); // do op\n\t\t\twrite(1, \"\\n\", 1);\n\t\t\tj++;\n\t\t}\n\t}\n\telse\n\t\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```",
            "FR": "## tab_mult\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : tab_mult\nFichiers attendus : tab_mult.c\nFonctions autorisées : write\n--------------------------------------------------------------------------------\n\nÉcrire un programme qui affiche la table de multiplication d'un nombre.\n\nLe paramètre sera toujours un nombre strictement positif qui tient dans un int, et ledit nombre multiplié par 9 tiendra également dans un int.\n\nS'il n'y a pas de paramètres, le programme affiche \\n.\n\nExemples:\n\n$>./tab_mult 9\n1 x 9 = 9\n2 x 9 = 18\n3 x 9 = 27\n4 x 9 = 36\n5 x 9 = 45\n6 x 9 = 54\n7 x 9 = 63\n8 x 9 = 72\n9 x 9 = 81\n$>./tab_mult 19\n1 x 19 = 19\n2 x 19 = 38\n3 x 19 = 57\n4 x 19 = 76\n5 x 19 = 95\n6 x 19 = 114\n7 x 19 = 133\n8 x 19 = 152\n9 x 19 = 171\n$>\n$>./tab_mult | cat -e\n$\n$>\n```\n### Code:\n```c\n#include <unistd.h>\n\nvoid\tft_putnbr(int n)\n{\n\tif (n > 9)\n\t\tft_putnbr(n / 10);\n\tchar c = (n % 10) + '0';\n\twrite(1, &c, 1);\n}\n\nint\t\tmain(int argc, char **argv)\n{\n\tint n;\n\tint\ti = 0;\n\tint\tj = 1;\n\n\tif (argc == 2)\n\t{\n\t\twhile (argv[1][i] != '\\0')\n\t\t{\n\t\t\tn = n * 10 + (argv[1][i] - '0');\n\t\t\ti++;\n\t\t}\n\t\twhile (j <= 9)\n\t\t{\n\t\t\tft_putnbr(j); //put 1 to 9\n\t\t\twrite(1, \" x \", 3);\n\t\t\tft_putnbr(n); // put av[1] as int\n\t\t\twrite(1, \" = \", 3);\n\t\t\tft_putnbr(j * n); // do op\n\t\t\twrite(1, \"\\n\", 1);\n\t\t\tj++;\n\t\t}\n\t}\n\telse\n\t\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-8",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "# Level 4\n\n---\n\n## fprime\n\n---\n\n### Subject:\n```text\nAssignment name  : fprime\nExpected files   : fprime.c\nAllowed functions: printf, atoi\n--------------------------------------------------------------------------------\n\nWrite a program that takes a positive int and displays its prime factors on the\nstandard output, followed by a newline.\n\nFactors must be displayed in ascending order and separated by '*', so that\nthe expression in the output gives the right result.\n\nIf the number of parameters is not 1, simply display a newline.\n\nThe input, when there's one, will be valid.\n\nExamples:\n\n$> ./fprime 225225 | cat -e\n3*3*5*5*7*11*13$\n$> ./fprime 8333325 | cat -e\n3*3*5*5*7*11*13*37$\n$> ./fprime 9539 | cat -e\n9539$\n$> ./fprime 804577 | cat -e\n804577$\n$> ./fprime 42 | cat -e\n2*3*7$\n$> ./fprime 1 | cat -e\n1$\n$> ./fprime | cat -e\n$\n$> ./fprime 42 21 | cat -e\n$\n```\n### Code:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid\tfprime(int nb)\n{\n\tint i;\n\n\ti = 2;\n\tif (nb == 1)\n\t{\n\t\tprintf(\"1\");\n\t\treturn ;\n\t}\n\twhile (nb >= i)\n\t{\n\t\tif (nb % i == 0)\n\t\t{\n\t\t\tprintf(\"%d\", i);\n\t\t\tif (nb != i)\n\t\t\t\tprintf(\"*\");\n\t\t\tnb /= i;\n\t\t\ti--;\n\t\t}\n\t\ti++;\n\t}\n}\n\nint\t\tmain(int ac, char **av)\n{\n\tif (ac == 2)\n\t\tfprime(atoi(av[1]));\n\tprintf(\"\\n\");\n\treturn (0);\n}\n```",
            "FR": "# Level 4\n\n---\n\n## fprime\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : fprime\nFichiers attendus : fprime.c\nFonctions autorisées : printf, atoi\n--------------------------------------------------------------------------------\n\nÉcrire un programme qui prend un entier positif et affiche ses facteurs premiers sur la sortie standard, suivi d'une nouvelle ligne.\n\nLes facteurs doivent être affichés dans l'ordre croissant et séparés par '*', de sorte que l'expression dans la sortie donne le bon résultat.\n\nSi le nombre de paramètres n'est pas 1, afficher simplement une nouvelle ligne.\n\nL'entrée, quand il y en a une, sera valide.\n\nExemples:\n\n$> ./fprime 225225 | cat -e\n3*3*5*5*7*11*13$\n$> ./fprime 8333325 | cat -e\n3*3*5*5*7*11*13*37$\n$> ./fprime 9539 | cat -e\n9539$\n$> ./fprime 804577 | cat -e\n804577$\n$> ./fprime 42 | cat -e\n2*3*7$\n$> ./fprime 1 | cat -e\n1$\n$> ./fprime | cat -e\n$\n$> ./fprime 42 21 | cat -e\n$\n```\n### Code:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid\tfprime(int nb)\n{\n\tint i;\n\n\ti = 2;\n\tif (nb == 1)\n\t{\n\t\tprintf(\"1\");\n\t\treturn ;\n\t}\n\twhile (nb >= i)\n\t{\n\t\tif (nb % i == 0)\n\t\t{\n\t\t\tprintf(\"%d\", i);\n\t\t\tif (nb != i)\n\t\t\t\tprintf(\"*\");\n\t\t\tnb /= i;\n\t\t\ti--;\n\t\t}\n\t\ti++;\n\t}\n}\n\nint\t\tmain(int ac, char **av)\n{\n\tif (ac == 2)\n\t\tfprime(atoi(av[1]));\n\tprintf(\"\\n\");\n\treturn (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## ft_itoa\n\n---\n\n### Subject:\n```text\nAssignment name  : ft_itoa\nExpected files   : ft_itoa.c\nAllowed functions: malloc\n--------------------------------------------------------------------------------\n\nWrite a function that takes an int and converts it to a null-terminated string.\nThe function returns the result in a char array that you must allocate.\n\nYour function must be declared as follows:\n\nchar\t*ft_itoa(int nbr);\n```\n### Code:\n```c\n#include<stdlib.h>\n#include<stdio.h>\n\nint\tabsolute_value(int i)\n{\n\tif (i < 0)\n\t\treturn (-i);\n\treturn (i);\n}\n\nint\tft_len(int i)\n{\n\tint\tlen;\n\n\tlen = 0;\n\tif (i <= 0)\n\t\tlen++;\n\twhile (i != 0)\n\t{\n\t\ti = i / 10;\n\t\tlen ++;\n\t}\n\treturn (len);\n}\n\nchar\t*ft_itoa(int nbr)\n{\n\tchar\t*str;\n\tint\t\tlen;\n\n\tlen = ft_len(nbr);\n\tstr = malloc(sizeof(char) * (len + 1));\n\tstr[len] = '\\0';\n\tif (nbr < 0)\n\t\tstr[0] = '-';\n\tif (nbr == 0)\n\t\tstr[0] = '0';\n\twhile (nbr != 0)\n\t{\n\t\tlen--;\n\t\tstr[len] = absolute_value(nbr % 10) + '0';\n\t\tnbr = nbr / 10;\n\t}\n\treturn (str);\n}\n```",
            "FR": "## ft_itoa\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : ft_itoa\nFichiers attendus : ft_itoa.c\nFonctions autorisées : malloc\n--------------------------------------------------------------------------------\n\nÉcrire une fonction qui prend un entier et le convertit en une chaîne de caractères terminée par un null.\nLa fonction retourne le résultat dans un tableau de caractères que vous devez allouer.\n\nVotre fonction doit être déclarée comme suit :\n\nchar\t*ft_itoa(int nbr);\n```\n### Code:\n```c\n#include<stdlib.h>\n#include<stdio.h>\n\nint\tabsolute_value(int i)\n{\n\tif (i < 0)\n\t\treturn (-i);\n\treturn (i);\n}\n\nint\tft_len(int i)\n{\n\tint\tlen;\n\n\tlen = 0;\n\tif (i <= 0)\n\t\tlen++;\n\twhile (i != 0)\n\t{\n\t\ti = i / 10;\n\t\tlen ++;\n\t}\n\treturn (len);\n}\n\nchar\t*ft_itoa(int nbr)\n{\n\tchar\t*str;\n\tint\t\tlen;\n\n\tlen = ft_len(nbr);\n\tstr = malloc(sizeof(char) * (len + 1));\n\tstr[len] = '\\0';\n\tif (nbr < 0)\n\t\tstr[0] = '-';\n\tif (nbr == 0)\n\t\tstr[0] = '0';\n\twhile (nbr != 0)\n\t{\n\t\tlen--;\n\t\tstr[len] = absolute_value(nbr % 10) + '0';\n\t\tnbr = nbr / 10;\n\t}\n\treturn (str);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## ft_list_foreach\n\n---\n\n### Subject:\n```text\nAssignment name  : ft_list_foreach\nExpected files   : ft_list_foreach.c, ft_list.h\nAllowed functions: \n--------------------------------------------------------------------------------\n\nWrite a function that takes a list and a function pointer, and applies this\nfunction to each element of the list.\n\nIt must be declared as follows:\n\nvoid    ft_list_foreach(t_list *begin_list, void (*f)(void *));\n\nThe function pointed to by f will be used as follows:\n\n(*f)(list_ptr->data);\n\nYou must use the following structure, and turn it in as a file called\nft_list.h:\n\ntypedef struct    s_list\n{\n    struct s_list *next;\n    void          *data;\n}                 t_list;\n```\n### Code:\n```c\n#include <stdlib.h>\n#include \"ft_list.h\"\n\nvoid\tft_list_foreach(t_list *begin_list, void (*f)(void *))\n{\n\twhile (begin_list != 0)\n\t{\n\t\t(*f)(begin_list->data);\n\t\tbegin_list = begin_list->next;\n\t}\n}\n```\n### Code .h :\n```c\ntypedef struct    s_list\n{\n    struct s_list *next;\n    void          *data;\n}                 t_list;\n```",
            "FR": "## ft_list_foreach\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : ft_list_foreach\nFichiers attendus : ft_list_foreach.c, ft_list.h\nFonctions autorisées : \n--------------------------------------------------------------------------------\n\nÉcrire une fonction qui prend une liste et un pointeur de fonction, et applique cette\nfonction à chaque élément de la liste.\n\nElle doit être déclarée comme suit :\n\nvoid    ft_list_foreach(t_list *begin_list, void (*f)(void *));\n\nLa fonction pointée par f sera utilisée comme suit :\n\n(*f)(list_ptr->data);\n\nVous devez utiliser la structure suivante, et la rendre dans un fichier appelé\nft_list.h :\n\ntypedef struct    s_list\n{\n    struct s_list *next;\n    void          *data;\n}                 t_list;\n```\n### Code:\n```c\n#include <stdlib.h>\n#include \"ft_list.h\"\n\nvoid\tft_list_foreach(t_list *begin_list, void (*f)(void *))\n{\n\twhile (begin_list != 0)\n\t{\n\t\t(*f)(begin_list->data);\n\t\tbegin_list = begin_list->next;\n\t}\n}\n```\n### Code .h :\n```c\ntypedef struct    s_list\n{\n    struct s_list *next;\n    void          *data;\n}                 t_list;\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## ft_split\n\n---\n\n### Subject:\n```text\nAssignment name  : ft_split\nExpected files   : ft_split.c\nAllowed functions: malloc\n--------------------------------------------------------------------------------\n\nWrite a function that takes a string, splits it into words, and returns them as\na NULL-terminated array of strings.\n\nA \"word\" is defined as a part of a string delimited either by spaces/tabs/new\nlines, or by the start/end of the string.\n\nYour function must be declared as follows:\n\nchar    **ft_split(char *str);\n\n--------------------------------------------------------------------------------\n\n#include <stdio.h>\n\nint\t\tmain(void)\n{\n\t// char test[] = \"\\njrS58VHQ\t\\n   \tp70fL\t\tKx2sRP0So3E4rC9  \\n nebpv3J5ousO84Pa1HjUQOImUhjwZpGn\t\\n \\n\tX28iT7Ap9 \tDIYAF9ZSpKcs0Rcv\\n uzO\\n\t\t\\nZ7zjEeonALOKQF5xq\t\\n   \\nQxp0b1ufFKGJ\t\\n2n8R9zUvZEtOwmqf\\n\t\";\n\tchar test[] = \"DIYAF9ZSpKcs0Rcv \\n uzO\\n\t\t\\nZ7zjEeonALOKQF5xq\t\\n   \\nQxp0b1ufFKGJ\t\\n2n8R9zUvZEtOwmqf\\n\t\";\n\n\tchar **arr = ft_split(test);\n\n\tint i = 0;\n\twhile (arr[i] != 0)\n\t{\n\t\tprintf(\"[%s]\\n\", arr[i]);\n\t\t++i;\n\t}\n}\n```\n### Code:\n```c\n#include <libc.h>\n\nchar\t**ft_split(char *str)\n{\n\tchar **tab;\n\tint i = 0;\n\tint j;\n\n\ttab = (char**)malloc(sizeof(char *) * 1000);\n\twhile (*str)\n\t{\n\t\ttab[i] = malloc(1000);\n\t\twhile (*str && (*str == ' ' || *str == '\\t'))\n\t\t\tstr++;\n\t\tj = 0;\n\t\twhile (*str && (*str != ' ' || *str != '\\t'))\n\t\t\ttab[i][j++] = *str++;\n\t\ttab[i][j] = '\\0';\n\t\ti++;\n\t}\n\ttab[i] = 0;\n\treturn (tab);\n}\n```",
            "FR": "## ft_split\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : ft_split\nFichiers attendus : ft_split.c\nFonctions autorisées : malloc\n--------------------------------------------------------------------------------\n\nÉcrire une fonction qui prend une chaîne de caractères, la divise en mots, et les retourne sous forme\nd'un tableau de chaînes de caractères terminé par NULL.\n\nUn \"mot\" est défini comme une partie d'une chaîne délimitée soit par des espaces/tabulations/nouvelles\nlignes, soit par le début/la fin de la chaîne.\n\nVotre fonction doit être déclarée comme suit :\n\nchar    **ft_split(char *str);\n```\n### Code:\n```c\n#include <libc.h>\n\nchar\t**ft_split(char *str)\n{\n\tchar **tab;\n\tint i = 0;\n\tint j;\n\n\ttab = (char**)malloc(sizeof(char *) * 1000);\n\twhile (*str)\n\t{\n\t\ttab[i] = malloc(1000);\n\t\twhile (*str && (*str == ' ' || *str == '\\t'))\n\t\t\tstr++;\n\t\tj = 0;\n\t\twhile (*str && (*str != ' ' || *str != '\\t'))\n\t\t\ttab[i][j++] = *str++;\n\t\ttab[i][j] = '\\0';\n\t\ti++;\n\t}\n\ttab[i] = 0;\n\treturn (tab);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## rev_wstr\n\n---\n\n### Subject:\n```text\nAssignment name  : rev_wstr\nExpected files   : rev_wstr.c\nAllowed functions: write, malloc, free\n--------------------------------------------------------------------------------\n\nWrite a program that takes a string as a parameter, and prints its words in \nreverse order.\n\nA \"word\" is a part of the string bounded by spaces and/or tabs, or the \nbegin/end of the string.\n\nIf the number of parameters is different from 1, the program will display \n'\\n'.\n\nIn the parameters that are going to be tested, there won't be any \"additional\" \nspaces (meaning that there won't be additionnal spaces at the beginning or at \nthe end of the string, and words will always be separated by exactly one space).\n\nExamples:\n\n$> ./rev_wstr \"You hate people! But I love gatherings. Isn't it ironic?\" | cat -e\nironic? it Isn't gatherings. love I But people! hate You$\n$>./rev_wstr \"abcdefghijklm\"\nabcdefghijklm\n$> ./rev_wstr \"Wingardium Leviosa\" | cat -e\nLeviosa Wingardium$\n$> ./rev_wstr | cat -e\n$\n$>\n```\n### Code:\n```c\n#include <unistd.h>\n#include <stdlib.h>\n\nvoid\tft_putstr(char *str)\n{\n\tint i;\n\n\ti = 0;\n\twhile (str[i] != '\\0')\n\t{\n\t\twrite(1, &str[i], 1);\n\t\ti++;\n\t}\n}\n\nchar\t**ft_split(char *str)\n{\n\tint i;\n\tint i2;\n\tint i3;\n\tchar **tab;\n\n\ti = 0;\n\ti2 = 0;\n\ttab = (char**)malloc(sizeof(char) * 100);\n\twhile (str[i] != '\\0')\n\t{\n\t\tif (str[i] > 32)\n\t\t{\n\t\t\ti3 = 0;\n\t\t\ttab[i2] = (char*)malloc(sizeof(char) * 100);\n\t\t\twhile (str[i] > 32)\n\t\t\t{\n\t\t\t\ttab[i2][i3] = str[i];\n\t\t\t\ti++;\n\t\t\t\ti3++;\n\t\t\t}\n\t\t\ttab[i2][i3] = '\\0';\n\t\t\ti2++;\n\t\t}\n\t\telse\n\t\t\ti++;\n\t}\n\ttab[i2] = 0;\n\treturn (tab);\n}\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\tchar **words;\n\n\ti = 0;\n\tif (ac == 2)\n\t{\n\t\twords = ft_split(av[1]);\n\t\twhile (words[i] != 0)\n\t\t\ti++;\n\t\ti--;\n\t\twhile (i >= 0)\n\t\t{\n\t\t\tft_putstr(words[i]);\n\t\t\tif (i > 0)\n\t\t\t\twrite(1, \" \", 1);\n\t\t\ti--;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```",
            "FR": "## rev_wstr\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : rev_wstr\nFichiers attendus : rev_wstr.c\nFonctions autorisées : write, malloc, free\n--------------------------------------------------------------------------------\n\nÉcrire un programme qui prend une chaîne de caractères en paramètre, et affiche ses mots dans\nl'ordre inverse.\n\nUn \"mot\" est une partie de la chaîne délimitée par des espaces et/ou des tabulations, ou le\ndébut/fin de la chaîne.\n\nSi le nombre de paramètres est différent de 1, le programme affichera\n'\\n'.\n\nDans les paramètres qui vont être testés, il n'y aura pas d'espaces \"supplémentaires\"\n(ce qui signifie qu'il n'y aura pas d'espaces supplémentaires au début ou à\nla fin de la chaîne, et les mots seront toujours séparés par exactement un espace).\n```\n### Code:\n```c\n#include <unistd.h>\n#include <stdlib.h>\n\nvoid\tft_putstr(char *str)\n{\n\tint i;\n\n\ti = 0;\n\twhile (str[i] != '\\0')\n\t{\n\t\twrite(1, &str[i], 1);\n\t\ti++;\n\t}\n}\n\nchar\t**ft_split(char *str)\n{\n\tint i;\n\tint i2;\n\tint i3;\n\tchar **tab;\n\n\ti = 0;\n\ti2 = 0;\n\ttab = (char**)malloc(sizeof(char) * 100);\n\twhile (str[i] != '\\0')\n\t{\n\t\tif (str[i] > 32)\n\t\t{\n\t\t\ti3 = 0;\n\t\t\ttab[i2] = (char*)malloc(sizeof(char) * 100);\n\t\t\twhile (str[i] > 32)\n\t\t\t{\n\t\t\t\ttab[i2][i3] = str[i];\n\t\t\t\ti++;\n\t\t\t\ti3++;\n\t\t\t}\n\t\t\ttab[i2][i3] = '\\0';\n\t\t\ti2++;\n\t\t}\n\t\telse\n\t\t\ti++;\n\t}\n\ttab[i2] = 0;\n\treturn (tab);\n}\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\tchar **words;\n\n\ti = 0;\n\tif (ac == 2)\n\t{\n\t\twords = ft_split(av[1]);\n\t\twhile (words[i] != 0)\n\t\t\ti++;\n\t\ti--;\n\t\twhile (i >= 0)\n\t\t{\n\t\t\tft_putstr(words[i]);\n\t\t\tif (i > 0)\n\t\t\t\twrite(1, \" \", 1);\n\t\t\ti--;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## rostring\n\n---\n\n### Subject:\n```text\nAssignment name  : rostring\nExpected files   : rostring.c\nAllowed functions: write, malloc, free\n--------------------------------------------------------------------------------\n\nWrite a program that takes a string and displays this string after rotating it\none word to the left.\n\nThus, the first word becomes the last, and others stay in the same order.\n\nA \"word\" is defined as a part of a string delimited either by spaces/tabs, or\nby the start/end of the string.\n\nWords will be separated by only one space in the output.\n\nIf there's less than one argument, the program displays \\n.\n\nExample:\n\n$>./rostring \"abc   \" | cat -e\nabc$\n$>\n$>./rostring \"Que la      lumiere soit et la lumiere fut\"\nla lumiere soit et la lumiere fut Que\n$>\n$>./rostring \"     AkjhZ zLKIJz , 23y\"\nzLKIJz , 23y AkjhZ\n$>\n$>./rostring \"first\" \"2\" \"11000000\"\nfirst\n$>\n$>./rostring | cat -e\n$\n$>\n```\n### Code:\n```c\n#include<unistd.h>\n#include<stdio.h>\n#include<stdlib.h>\n\nvoid\tft_putstr(char *str)\n{\n\tint i;\n\n\ti = 0;\n\twhile (str[i] != '\\0')\n\t{\n\t\twrite(1, &str[i], 1);\n\t\ti++;\n\t}\n}\n\nchar\t**ft_split(char *str)\n{\n\tint i;\n\tint i2;\n\tint i3;\n\tchar **tab;\n\n\ti = 0;\n\ti2 = 0;\n\ttab = (char**)malloc(sizeof(char) * 100);\n\twhile (str[i] == ' ' || str[i] == '\\t')\n\t\ti++;\n\twhile (str[i] != '\\0')\n\t{\n\t\tif (str[i] != ' ' && str[i] != '\\t')\n\t\t{\n\t\t\ti3 = 0;\n\t\t\ttab[i2] = (char*)malloc(sizeof(char) * 100);\n\t\t\twhile (str[i] != ' ' && str[i] != '\\t' && str[i])\n\t\t\t{\n\t\t\t\ttab[i2][i3] = str[i];\n\t\t\t\ti++;\n\t\t\t\ti3++;\n\t\t\t}\n\t\t\ttab[i2][i3] = '\\0';\n\t\t\ti2++;\n\t\t}\n\t\telse\n\t\t\ti++;\n\t}\n\ttab[i2] = 0;\n\treturn (tab);\n}\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\tchar **tab;\n\n\ti = 1;\n\tif (ac > 1)\n\t{\n\t\ttab = ft_split(av[1]);\n\t\twhile (tab[i])\n\t\t{\n\t\t\tft_putstr(tab[i]);\n\t\t\twrite(1, \" \", 1);\n\t\t\ti++;\n\t\t}\n\t\tft_putstr(tab[0]);\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```",
            "FR": "## rostring\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : rostring\nFichiers attendus : rostring.c\nFonctions autorisées : write, malloc, free\n--------------------------------------------------------------------------------\n\nÉcrire un programme qui prend une chaîne de caractères et affiche cette chaîne après l'avoir fait pivoter\nd'un mot vers la gauche.\n\nAinsi, le premier mot devient le dernier, et les autres restent dans le même ordre.\n\nUn \"mot\" est défini comme une partie d'une chaîne délimitée soit par des espaces/tabulations, soit\npar le début/la fin de la chaîne.\n\nLes mots seront séparés par un seul espace dans la sortie.\n\nS'il y a moins d'un argument, le programme affiche \\n.\n```\n### Code:\n```c\n#include<unistd.h>\n#include<stdio.h>\n#include<stdlib.h>\n\nvoid\tft_putstr(char *str)\n{\n\tint i;\n\n\ti = 0;\n\twhile (str[i] != '\\0')\n\t{\n\t\twrite(1, &str[i], 1);\n\t\ti++;\n\t}\n}\n\nchar\t**ft_split(char *str)\n{\n\tint i;\n\tint i2;\n\tint i3;\n\tchar **tab;\n\n\ti = 0;\n\ti2 = 0;\n\ttab = (char**)malloc(sizeof(char) * 100);\n\twhile (str[i] == ' ' || str[i] == '\\t')\n\t\ti++;\n\twhile (str[i] != '\\0')\n\t{\n\t\tif (str[i] != ' ' && str[i] != '\\t')\n\t\t{\n\t\t\ti3 = 0;\n\t\t\ttab[i2] = (char*)malloc(sizeof(char) * 100);\n\t\t\twhile (str[i] != ' ' && str[i] != '\\t' && str[i])\n\t\t\t{\n\t\t\t\ttab[i2][i3] = str[i];\n\t\t\t\ti++;\n\t\t\t\ti3++;\n\t\t\t}\n\t\t\ttab[i2][i3] = '\\0';\n\t\t\ti2++;\n\t\t}\n\t\telse\n\t\t\ti++;\n\t}\n\ttab[i2] = 0;\n\treturn (tab);\n}\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\tchar **tab;\n\n\ti = 1;\n\tif (ac > 1)\n\t{\n\t\ttab = ft_split(av[1]);\n\t\twhile (tab[i])\n\t\t{\n\t\t\tft_putstr(tab[i]);\n\t\t\twrite(1, \" \", 1);\n\t\t\ti++;\n\t\t}\n\t\tft_putstr(tab[0]);\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## sort_int_tab\n\n---\n\n### Subject:\n```text\nAssignment name  : sort_int_tab\nExpected files   : sort_int_tab.c\nAllowed functions: \n--------------------------------------------------------------------------------\n\nWrite the following function:\n\nvoid sort_int_tab(int *tab, unsigned int size);\n\nIt must sort (in-place) the 'tab' int array, that contains exactly 'size'\nmembers, in ascending order.\n\nDoubles must be preserved.\n\nInput is always coherent.\n```\n### Code:\n```c\nvoid\tsort_int_tab(int *tab, unsigned int size)\n{\n\tint\ti;\n\tint\ttmp;\n\tint\tswap;\n\n\tswap = 1;\n\twhile (swap == 1)\n\t{\n\t\ti = 0;\n\t\tswap = 0;\n\t\twhile (i < size - 1)\n\t\t{\n\t\t\tif (tab[i] > tab[i + 1])\n\t\t\t{\n\t\t\t\ttmp = tab[i];\n\t\t\t\ttab[i] = tab[i + 1];\n\t\t\t\ttab[i + 1] = tmp;\n\t\t\t\tswap = 1;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n}\n```",
            "FR": "## sort_int_tab\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : sort_int_tab\nFichiers attendus : sort_int_tab.c\nFonctions autorisées :\n--------------------------------------------------------------------------------\n\nÉcrire la fonction suivante :\n\nvoid sort_int_tab(int *tab, unsigned int size);\n\nElle doit trier (en place) le tableau d'entiers 'tab', qui contient exactement 'size'\nmembres, dans l'ordre croissant.\n\nLes doublons doivent être conservés.\n\nL'entrée est toujours cohérente.\n```\n### Code:\n```c\nvoid\tsort_int_tab(int *tab, unsigned int size)\n{\n\tint\ti;\n\tint\ttmp;\n\tint\tswap;\n\n\tswap = 1;\n\twhile (swap == 1)\n\t{\n\t\ti = 0;\n\t\tswap = 0;\n\t\twhile (i < size - 1)\n\t\t{\n\t\t\tif (tab[i] > tab[i + 1])\n\t\t\t{\n\t\t\t\ttmp = tab[i];\n\t\t\t\ttab[i] = tab[i + 1];\n\t\t\t\ttab[i + 1] = tmp;\n\t\t\t\tswap = 1;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## sort_list\n\n---\n\n### Subject:\n```text\nAssignment name  : sort_list\nExpected files   : sort_list.c\nAllowed functions: \n--------------------------------------------------------------------------------\n\nWrite the following functions:\n\nt_list\t*sort_list(t_list* lst, int (*cmp)(int, int));\n\nThis function must sort the list given as a parameter, using the function \npointer cmp to select the order to apply, and returns a pointer to the \nfirst element of the sorted list.\n\nDuplications must remain.\n\nInputs will always be consistent.\n\nYou must use the type t_list described in the file list.h \nthat is provided to you. You must include that file \n(#include \"list.h\"), but you must not turn it in. We will use our own \nto compile your assignment.\n\nFunctions passed as cmp will always return a value different from \n0 if a and b are in the right order, 0 otherwise.\n\nFor example, the following function used as cmp will sort the list in ascending order:\n\nint ascending(int a, int b)\n{\n\treturn (a <= b);\n}\n\n--------------------------------------------------------------------------------\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint ascending(int a, int b)\n{\n\treturn (a <= b);\n}\n\nint\tmain(void)\n{\n\tt_list *c = malloc(sizeof(t_list));\n\tc->next = 0;\n\tc->data = 45;\n\n\tt_list *b = malloc(sizeof(t_list));\n\tb->next = c;\n\tb->data = 73;\n\n\tt_list *a = malloc(sizeof(t_list));\n\ta->next = b;\n\ta->data = 108;\n\n\tt_list *cur = a;\n\twhile (cur)\n\t{\n\t\tprintf(\"%d, \", cur->data);\n\t\tcur = cur->next;\n\t}\n\tprintf(\"\\n\");\n\n\tcur = sort_list(a, ascending);\n\n\t// cur = a;\n\twhile (cur)\n\t{\n\t\tprintf(\"%d, \", cur->data);\n\t\tcur = cur->next;\n\t}\n\tprintf(\"\\n\");\n}\n```\n### Code:\n```c\n#include \"list.h\"\n\nt_list\t*sort_list(t_list *lst, int (*cmp)(int, int))\n{\n\tint swap;\n\tt_list *tmp = lst;\n\t\n\twhile (lst->next != 0)\n\t{\n\t\tif (((*cmp)(lst->data, lst->next->data)) == 0)\n\t\t{\n\t\t\tswap = lst->data;\n\t\t\tlst->data = lst->next->data;\n\t\t\tlst->next->data = swap;\n\t\t\tlst = tmp;\n\t\t}\n\t\telse\n\t\t\tlst = lst->next;\n\t}\n\tlst = tmp;\n\treturn (lst);\n}\n```\n### Code .h:\n```c\ntypedef struct s_list t_list;\n\nstruct s_list\n{\n\tint     data;\n\tt_list  *next;\n};\n```",
            "FR": "## sort_list\n\n---\n\n### Sujet:\n```text\nNom de l'assignation : sort_list\nFichiers attendus : sort_list.c\nFonctions autorisées :\n--------------------------------------------------------------------------------\n\nÉcrire les fonctions suivantes :\n\nt_list\t*sort_list(t_list* lst, int (*cmp)(int, int));\n\nCette fonction doit trier la liste donnée en paramètre, en utilisant le \npointeur de fonction cmp pour sélectionner l'ordre à appliquer, et renvoie un pointeur vers le \npremier élément de la liste triée.\n\nLes duplications doivent rester.\n\nLes entrées seront toujours cohérentes.\n\nVous devez utiliser le type t_list décrit dans le fichier list.h \nqui vous est fourni. Vous devez inclure ce fichier \n(#include \"list.h\"), mais vous ne devez pas le rendre. Nous utiliserons le nôtre \npour compiler votre assignation.\n\nLes fonctions passées comme cmp renverront toujours une valeur différente de \n0 si a et b sont dans le bon ordre, 0 sinon.\n\nPar exemple, la fonction suivante utilisée comme cmp triera la liste dans l'ordre croissant :\n\nint ascending(int a, int b)\n{\n\treturn (a <= b);\n}\n```\n### Code:\n```c\n#include \"list.h\"\n\nt_list\t*sort_list(t_list *lst, int (*cmp)(int, int))\n{\n\tint swap;\n\tt_list *tmp = lst;\n\t\n\twhile (lst->next != 0)\n\t{\n\t\tif (((*cmp)(lst->data, lst->next->data)) == 0)\n\t\t{\n\t\t\tswap = lst->data;\n\t\t\tlst->data = lst->next->data;\n\t\t\tlst->next->data = swap;\n\t\t\tlst = tmp;\n\t\t}\n\t\telse\n\t\t\tlst = lst->next;\n\t}\n\tlst = tmp;\n\treturn (lst);\n}\n```\n### Code .h:\n```c\ntypedef struct s_list t_list;\n\nstruct s_list\n{\n\tint     data;\n\tt_list  *next;\n};\n```"
          },
          "yes_no": false,
          "separator": false,
          "type": "mandatory"
        }
      ],
      "bonusSections": [],
      "gradingOptions": [
        {
          "ok": false,
          "outstanding": false,
          "empty_work": false,
          "incomplete_work": false,
          "invalid_compilation": false,
          "norme": false,
          "cheat": false,
          "crash": false,
          "concerning_situations": false,
          "leaks": false,
          "forbidden_functions": false,
          "cannot_support": false
        }
      ],
      "languages": [
        "EN",
        "FR"
      ],
      "language": "EN",
      "introduction": {
        "FR": "# Avant l'exam\nLes exams ont une durée de 3H. Ils sont théoriquement disponibles 2 fois par semaine :\n\n- Une session le mardi matin de 10h à 13h\n- Une deuxième le jeudi soir de 16h à 19h\n\nCependant ces dates peuvent être amenées à être modifiées selon les contraintes de la vie de l'école et du staff (piscine, events, etc...). Les événements disponibles sur votre intra font foi !\n\nLe cluster est précisé dans l'event de l'intra.\n\nVous devez toujours vous inscrire à l'évènement ET au projet.\n\nIl n'est pas possible de venir travailler en cluster d'examen sur un de ses projets pendant le déroulement d'un exam. Les tuteurs et tutrices sont responsables de la gestion de l'examen, et peuvent à tout moment vous demander de quitter le cluster si vous n'êtes pas inscrits à l'exam. \n\n---\n\n# Pendant l'exam\n\n- Si vous avez changé de mot de passe intra entre votre inscription et le début de l'exam, il faut utiliser votre ancien mot de passe.\n- Si votre exercice est faux, vous devez retenter le même exercice et cela jusqu'à sa validation.\n- Le temps entre chaque commande grademe devient incremental (suivant la suite de fibonnacci 1,2,3,5,8,13 etc.). Attention à bien tester avant de faire un grademe.",
        "EN": "# Before the exam\nExams last 3 hours. They are theoretically available twice a week:\n\n- One session on Tuesday morning from 10 a.m. to 1 p.m.\n- A second on Thursday evening from 4 p.m. to 7 p.m.\n\nHowever, these dates may be subject to change depending on the constraints of school life and staff (swimming pool, events, etc.). The events available on your intra are authoritative!\n\nThe cluster is specified in the intra event.\n\nYou must always register for the event AND the project.\n\nIt is not possible to come and work in an exam cluster on one of its projects during an exam. Tutors are responsible for managing the exam, and may ask you to leave the cluster at any time if you are not registered for the exam.\n\n---\n\n# During the exam\n\n- If you have changed your intra password between your registration and the start of the exam, you must use your old password.\n- If your exercise is wrong, you must try the same exercise again until it is validated.\n- The time between each grademe command becomes incremental (following the Fibonacci sequence 1,2,3,5,8,13 etc.). Be sure to test well before doing a grademe."
      },
      "guidelines": {
        "FR": "# Règles Exams Machine\n`\nTout manquement à l'une des règles suivantes entraînera l'exclusion de l'examen, la note -42 et pourra être suivi de sanction supplémentaire.\n`\n\n- L'entrée s'effectue dans le calme et sans précipitation.\n\n- A l'entrée, vous devrez présenter votre carte aux API, sans carte l'accès à la session d'examen vous sera refusé.\n\n- Il est interdit de se connecter sur sa session personnelle dans le cluster réservé pour l'exam, après y être entré et avant en être sorti.\n\n- Vous devez vous utiliser le login exam et le password exam.\n\n- Une fois l'examen commencé, il est interdit de rentrer dans la salle. Aucun retardataire ne sera admis.\n\n- Les téléphones, montres connectées et autres objets (connectés ou non) sont interdits, ils devront être éteint et rangé dans les sacs ou déposés dans la boîte à l'entrée du cluster. Pas en silencieux. Éteints.\n\n- Les écouteurs, filaires ou non, sont des objets connectés et doivent être rangés dans les sacs. Pas dans les poches, ni dans les oreilles.\n\n- Vous n'êtes autorisés à garder aucun objet sur vous (Ni dans vos poches). Sont uniquement autorisés sur votre bureau :\n  - Papier (3 feuilles max)\n  - un et un seul stylo/crayon\n  - une montre mécanique (== avec des aiguilles et rien d'autre)\n  - mouchoirs\n  - boule quiès\n\n- Les sacs et manteaux devront être déposés à l'endroit indiqué par les API.\n- Il est interdit de les déposer devant les extincteurs, sous les oeuvres et bouches d'aération.\n- Les cartes d'étudiant·e·s doivent être posées en évidence sur les tables.\n- Vos poches doivent être vides. Tout autre objet trouvé sur vous entraîne une suspicion de triche.\n- Tout périphérique personnel connecté (clavier, souris, etc) sont interdits en examen.\n- Vous avez le droit uniquement à des feuilles vierges volantes en guise de brouillon (pas de carnet), à un stylo ou un crayon, ainsi qu'une bouteille d'eau fermée au sol. Si vous avez besoin d'objets supplémentaires concernant votre santé, prévenez l'un de vos surveillants.\n- Vos feuilles doivent être vierges jusqu'au début de l'examen. Vous n'avez pas le droit de coder avant le début de l'examen.\n- Toute tentative de communication avec d'autres étudiant·e·s que ce soit oral, écrit ou autre est prohibée, ce sera considéré comme une tentative de triche et entrainera une sortie d'exam.\n- Il est interdit de se connecter avec les identifiants d'un autre étudiant.\n- Vous devez désactiver le son de vos iMac dès votre arrivée, une fois l'examen commencé toute personne faisant \"sonner\" volontairement son mac sera exclue de l'examen sans avertissement préalable.\n- Il est interdit de se déplacer, sauf pour quitter la session d'examen.\n- Les API ainsi que leurs décisions doivent être respectés.\n- Si vous souhaitez aller aux toilettes, vous devrez attendre qu'un API fasse une annonce. En cas d'extrême urgence, levez vous et attendez un API pour lui demander. Si vous êtes malade, prévenez l'un des surveillants.\n- Pour toute question, vous devrez vous LEVER ET ATTENDRE un API.\n- Les règles générales des clusters s'appliquent aux examens.\n- Vérifiez que vous n'oubliez rien en sortant, les cartes oubliées seront à récupérer au bocal, le reste sera rapporté aux objets trouvés.\n- Une fois l'examen terminé merci de faire preuve de respect en rangeant sa chaise, son clavier, sa souris et ses feuilles de brouillon, de déconnecter la session ouverte sur le poste et de sortir en silence.\n- Si vous avez des besoins spéciaux et que le staff a été mis au courant dites le dès le début aux surveillants.\n\n---\n**LES INFRACTIONS SUIVANTES ENTRAÎNERONT AUTOMATIQUEMENT, AU MOINS, UNE EXCLUSION DE L'EXAMEN:**\n- Communication orale/autre à qui que ce soit, même à soi même\n- Tout objet sur vous (sauf liste au dessus)\n- Appareil électronique allumé dans un sac\n- Se connecter avec l'identifiant d'un.e autre étudiant.e\n- Regarder un autre écran que le sien\n- Brouillon non vierge avant le début de l'examen\n- Commencer à coder avant le début de l'examen\n- Multiple récidive d'une même infraction\n- Le non-respect des gestes barrières contre le COVID en salle d'exam.",
        "EN": "# Machine Exams Rules\n`\nAny failure to comply with one of the following rules will result in exclusion from the exam, a mark of -42 and may be followed by additional sanctions.\n`\n\n- Entry must be done calmly and without rushing.\n\n- Upon entry, you will have to present your card to the APIs, without a card access to the exam session will be refused.\n\n- It is forbidden to connect to your personal session in the cluster reserved for the exam, after entering it and before leaving it.\n\n- You must use the exam login and the exam password.\n\n- Once the exam has started, it is forbidden to enter the room. No latecomers will be allowed.\n\n- Telephones, connected watches and other objects (connected or not) are prohibited, they must be switched off and stored in bags or placed in the box at the entrance to the cluster. Not in silent mode. Switched off.\n\n- Headphones, wired or not, are connected objects and must be stored in bags. Not in pockets, nor in ears.\n\n- You are not allowed to keep any objects on you (Nor in your pockets). Only the following are allowed on your desk:\n - Paper (3 sheets max)\n - one and only one pen/pencil\n - a mechanical watch (== with hands and nothing else)\n - handkerchiefs\n - earplugs\n\n- Bags and coats must be left in the place indicated by the APIs.\n- It is forbidden to place them in front of fire extinguishers, under works of art and ventilation openings.\n- Student cards must be placed visibly on the tables.\n- Your pockets must be empty. Any other object found on you will lead to suspicion of cheating.\n- Any personal connected device (keyboard, mouse, etc.) is prohibited in the exam.\n- You are only entitled to blank sheets of paper as a draft (no notebook), a pen or pencil, as well as a closed bottle of water on the floor. If you need additional items regarding your health, please notify one of your supervisors.\n- Your sheets must be blank until the start of the exam. You are not allowed to code before the start of the exam.\n- Any attempt to communicate with other students whether oral, written or otherwise is prohibited, this will be considered as an attempt to cheat and will result in an exam exit.\n- It is forbidden to connect with the identifiers of another student.\n- You must turn off the sound of your iMac as soon as you arrive, once the exam has started anyone who voluntarily makes their mac \"ring\" will be excluded from the exam without prior warning.\n- It is forbidden to move around, except to leave the exam session.\n- APIs and their decisions must be respected.\n- If you wish to go to the toilet, you will have to wait for an API to make an announcement. In case of extreme urgency, get up and wait for an API to ask him. If you are sick, notify one of the supervisors.\n- For any question, you will have to GET UP AND WAIT for an API.\n- The general rules of the clusters apply to exams.\n- Check that you don't forget anything when leaving, forgotten cards will have to be picked up at the bocal, the rest will be reported to the lost and found.\n- Once the exam is over, please show respect by tidying up your chair, keyboard, mouse and draft sheets, disconnecting the session open on the computer and leaving in silence.\n- If you have special needs and the staff has been informed, tell the supervisors from the beginning.\n\n---\n**THE FOLLOWING INFRACTIONS WILL AUTOMATICALLY RESULT IN, AT LEAST, EXCLUSION FROM THE EXAM:**\n- Oral/other communication to anyone, even to oneself\n- Any object on you (except list above)\n- Electronic device switched on in a bag\n- Connecting with the identifier of another student\n- Looking at another screen than your own\n- Non-blank draft before the start of the exam\n- Starting to code before the start of the exam\n- Multiple recidivism of the same offense\n- Failure to comply with barrier gestures against COVID in the exam room."
      }
    }
  ],
  "message": "Sheet created successfully"
}