{
  "success": true,
  "data": [
    {
      "id": 8,
      "status": "active",
      "project_title": "Exam_rank_05",
      "finish": true,
      "attachments": [],
      "cursus_id": "1",
      "updated_at": "2023-07-31T22:00:00.000Z",
      "students": 1,
      "eval_points": 0,
      "time": 180,
      "mandatorySections": [
        {
          "description": {
            "EN": "# Levels\n\nPossible exercises:\n| Level 1                         | \n| ----------------------- |\n| cpp_module_00         |\n| cpp_module_01         |\n| cpp_module_02         |",
            "FR": "# Niveaux\n\nExercices possibles :\n| Niveau 1                     | \n| ----------------------- |\n| cpp_module_00         |\n| cpp_module_01         |\n| cpp_module_02         |"
          },
          "yes_no": false,
          "separator": "border-t-8",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "# Level 1\n\n---\n\n## cpp_module_00\n\n---\n\n### Subject:\n```text\nAssignment name  : cpp_module_00\nExpected files   : Warlock.cpp Warlock.hpp\n--------------------------------------------------------------------------------\n\nMake a Warlock class. It has to be in Coplien's form.\n\nIt has the following private attributes :\n* name (string)\n* title (string)\n\nSince they're private, you will write the following getters :\n* getName, returns a reference to constant string\n* getTitle, returns a reference to constant string\n\nBoth these functions will have to be callable on a constant Warlock.\n\nCreate the following setter: \n* setTitle, returns void and takes a reference to constant string\n\nYour Warlock will also have, in addition to whatever's required by Coplien's\nform, a constructor that takes, in this order, its name and title. Your Warlock\nwill not be able to be copied, instantiated by copy, or instantiated without a\nname and a title.\n\nFor example :\n\nWarlock bob;                            //Does not compile\nWarlock bob(\"Bob\", \"the magnificent\");  //Compiles\nWarlock jim(\"Jim\", \"the nauseating\");   //Compiles\nbob = jim;                              //Does not compile\nWarlock jack(jim);                      //Does not compile\n\nUpon creation, the Warlock says :\n\n<NAME>: This looks like another boring day.\n\nOf course, whenever we use placeholders like <NAME>, <TITLE>, etc...\nin outputs, you will replace them by the appropriate value. Without the < and >.\n\nWhen he dies, he says:\n\n<NAME>: My job here is done!\n\nOur Warlock must also be able to introduce himself, while boasting with all its\nmight.\n\nSo you will write the following function:\n* void introduce() const;\n\nIt must display:\n\n<NAME>: I am <NAME>, <TITLE>!\n\nHere's an example of a test main function and its associated output:\n\nint main()\n{\n  Warlock const richard(\"Richard\", \"Mistress of Magma\");\n  richard.introduce();\n  std::cout << richard.getName() << \" - \" << richard.getTitle() << std::endl;\n\n  Warlock* jack = new Warlock(\"Jack\", \"the Long\");\n  jack->introduce();\n  jack->setTitle(\"the Mighty\");\n  jack->introduce();\n\n  delete jack;\n\n  return (0);\n}\n\n~$ ./a.out | cat -e\nRichard: This looks like another boring day.$\nRichard: I am Richard, Mistress of Magma!$\nRichard - Mistress of Magma$\nJack: This looks like another boring day.$\nJack: I am Jack, the Long!$\nJack: I am Jack, the Mighty!$\nJack: My job here is done!$\nRichard: My job here is done!$\n~$\n```\n### Code Warlock.cpp:\n```c++\n#include \"Warlock.hpp\"\n\nWarlock::Warlock()\n{\n}\n\nWarlock::Warlock(const std::string &name, const std::string &title)\n: _name(name), _title(title)\n{\n\tstd::cout << _name << \": This looks like another boring day.\" << std::endl;\n}\n\nWarlock::Warlock(const Warlock &src)\n{\n\t(void)src;\n}\n\nWarlock& Warlock::operator=(const Warlock &src)\n{\n\t(void)src;\n\treturn (*this);\n}\n\nWarlock::~Warlock()\n{\n\tstd::cout << _name << \": My job here is done!\" << std::endl;\n}\n\nconst std::string& Warlock::getName() const\n{\n\treturn (_name);\n}\n\nconst std::string& Warlock::getTitle() const\n{\n\treturn (_title);\n}\n\nvoid Warlock::setTitle(const std::string &title)\n{\n\t_title = title;\n}\n\nvoid Warlock::introduce() const\n{\n\tstd::cout << _name << \": I am \" << _name << \", \" << _title << \"!\" << std::endl;\n}\n```\n### Code Warlock.hpp:\n```c++\n#pragma once\n\n#include <iostream>\n#include <string>\n\nclass\tWarlock\n{\n\tpublic:\n\t\tWarlock(const std::string &name, const std::string &title);\n\t\t~Warlock();\n\n\t\tconst std::string &getName() const;\n\t\tconst std::string &getTitle() const;\n\t\tvoid setTitle(const std::string &title);\n\t\tvoid introduce() const;\n\t\n\tprivate:\n\t\tstd::string _name;\n\t\tstd::string _title;\n\n\t\tWarlock();\n\t\tWarlock(const Warlock &src);\n\t\tWarlock& operator=(const Warlock &src);\n};\n```\n### Code main.cpp\n```cpp\n#include \"Warlock.hpp\"\n\nint main()\n{\n  Warlock const richard(\"Richard\", \"Mistress of Magma\");\n  richard.introduce();\n  std::cout << richard.getName() << \" - \" << richard.getTitle() << std::endl;\n\n  Warlock* jack = new Warlock(\"Jack\", \"the Long\");\n  jack->introduce();\n  jack->setTitle(\"the Mighty\");\n  jack->introduce();\n\n  delete jack;\n\n  return (0);\n}\n```",
            "FR": "# Level 1\n\n---\n\n## cpp_module_00\n\n---\n\n### Subject:\n```text\nNom de l'assignation : cpp_module_00\nFichiers attendus : Warlock.cpp Warlock.hpp\n--------------------------------------------------------------------------------\n\nCréez une classe Warlock. Elle doit être sous la forme de Coplien.\n\nElle a les attributs privés suivants :\n* name (string)\n* title (string)\n\nPuisqu'ils sont privés, vous écrirez les getters suivants :\n* getName, retourne une référence à une chaîne constante\n* getTitle, retourne une référence à une chaîne constante\n\nCes deux fonctions devront être appelables sur un Warlock constant.\n\nCréez le setter suivant :\n* setTitle, retourne void et prend une référence à une chaîne constante\n\nVotre Warlock aura également, en plus de ce qui est requis par la forme de Coplien, un constructeur qui prend, dans cet ordre, son nom et son titre. Votre Warlock ne pourra pas être copié, instancié par copie, ou instancié sans un nom et un titre.\n\nPar exemple :\n\nWarlock bob;                            //Ne compile pas\nWarlock bob(\"Bob\", \"the magnificent\");  //Compile\nWarlock jim(\"Jim\", \"the nauseating\");   //Compile\nbob = jim;                              //Ne compile pas\nWarlock jack(jim);                      //Ne compile pas\n\nLors de la création, le Warlock dit :\n\n<NAME>: This looks like another boring day.\n\nBien sûr, chaque fois que nous utilisons des espaces réservés comme <NAME>, <TITLE>, etc...\ndans les sorties, vous les remplacerez par la valeur appropriée. Sans les < et >.\n\nQuand il meurt, il dit :\n\n<NAME>: My job here is done!\n\nNotre Warlock doit également être capable de se présenter, tout en se vantant de toutes ses forces.\n\nVous écrirez donc la fonction suivante :\n* void introduce() const;\n\nElle doit afficher :\n\n<NAME>: I am <NAME>, <TITLE>!\n\nVoici un exemple de fonction main de test et sa sortie associée :\n\nint main()\n{\n  Warlock const richard(\"Richard\", \"Mistress of Magma\");\n  richard.introduce();\n  std::cout << richard.getName() << \" - \" << richard.getTitle() << std::endl;\n\n  Warlock* jack = new Warlock(\"Jack\", \"the Long\");\n  jack->introduce();\n  jack->setTitle(\"the Mighty\");\n  jack->introduce();\n\n  delete jack;\n\n  return (0);\n}\n\n~$ ./a.out | cat -e\nRichard: This looks like another boring day.$\nRichard: I am Richard, Mistress of Magma!$\nRichard - Mistress of Magma$\nJack: This looks like another boring day.$\nJack: I am Jack, the Long!$\nJack: I am Jack, the Mighty!$\nJack: My job here is done!$\nRichard: My job here is done!$\n~$\n```\n### Code Warlock.cpp:\n```c++\n#include \"Warlock.hpp\"\n\nWarlock::Warlock()\n{\n}\n\nWarlock::Warlock(const std::string &name, const std::string &title)\n: _name(name), _title(title)\n{\n\tstd::cout << _name << \": This looks like another boring day.\" << std::endl;\n}\n\nWarlock::Warlock(const Warlock &src)\n{\n\t(void)src;\n}\n\nWarlock& Warlock::operator=(const Warlock &src)\n{\n\t(void)src;\n\treturn (*this);\n}\n\nWarlock::~Warlock()\n{\n\tstd::cout << _name << \": My job here is done!\" << std::endl;\n}\n\nconst std::string& Warlock::getName() const\n{\n\treturn (_name);\n}\n\nconst std::string& Warlock::getTitle() const\n{\n\treturn (_title);\n}\n\nvoid Warlock::setTitle(const std::string &title)\n{\n\t_title = title;\n}\n\nvoid Warlock::introduce() const\n{\n\tstd::cout << _name << \": I am \" << _name << \", \" << _title << \"!\" << std::endl;\n}\n```\n### Code Warlock.hpp:\n```c++\n#pragma once\n\n#include <iostream>\n#include <string>\n\nclass\tWarlock\n{\n\tpublic:\n\t\tWarlock(const std::string &name, const std::string &title);\n\t\t~Warlock();\n\n\t\tconst std::string &getName() const;\n\t\tconst std::string &getTitle() const;\n\t\tvoid setTitle(const std::string &title);\n\t\tvoid introduce() const;\n\t\n\tprivate:\n\t\tstd::string _name;\n\t\tstd::string _title;\n\n\t\tWarlock();\n\t\tWarlock(const Warlock &src);\n\t\tWarlock& operator=(const Warlock &src);\n};\n```\n### Code main.cpp\n```cpp\n#include \"Warlock.hpp\"\n\nint main()\n{\n  Warlock const richard(\"Richard\", \"Mistress of Magma\");\n  richard.introduce();\n  std::cout << richard.getName() << \" - \" << richard.getTitle() << std::endl;\n\n  Warlock* jack = new Warlock(\"Jack\", \"the Long\");\n  jack->introduce();\n  jack->setTitle(\"the Mighty\");\n  jack->introduce();\n\n  delete jack;\n\n  return (0);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## cpp_module_01\n\n---\n\n### Subject:\n```text\nAssignment name  : cpp_module_01\nExpected files   : Warlock.cpp Warlock.hpp\n                   ASpell.hpp ASpell.cpp\n\t\t\t\t   ATarget.hpp ATarget.cpp\n\t\t\t\t   Fwoosh.hpp Fwoosh.cpp\n\t\t\t\t   Dummy.hpp Dummy.cpp\n--------------------------------------------------------------------------------\n\nIn the Warlock class, the switch statement is FORBIDDEN and its use would\nresult in a -42.\n\nCreate an abstract class called ASpell, in Coplien's form, that has the\nfollowing protected attributes:\n\n* name (string)\n* effects (string)\n\nBoth will have getters (getName and getEffects) that return strings.\n\nAlso add a clone pure method that returns a pointer to ASpell.\n\nAll these functions can be called on a constant object.\n\nASpell has a constructor that takes its name and its effects, in that order.\n\nNow you will create an ATarget abstract class, in Coplien's form. It has a type\nattribute, which is a string, and its associated getter, getType, that return a\n\nreference to constant string.\n\nIn much the same way as ASpell, it has a clone() pure method.\n\nAll these functions can be called on a constant object.\n\nIt has a constructor that takes its type.\n\nNow, add to your ATarget a getHitBySpell function that takes a reference to\nconstant ASpell.\n\nIt will display :\n\n<TYPE> has been <EFFECTS>!\n\n<TYPE> is the ATarget's type, and <EFFECTS> is the return of the ASpell's\ngetEffects function.\n\nFinally, add to your ASpell class a launch function that takes a reference to\nconstant ATarget.\n\nThis one will simply call the getHitBySpell of the passed object, passing the\ncurrent instance as parameter.\n\nWhen all this is done, create an implementation of ASpell called Fwoosh. Its\ndefault constructor will set the name to \"Fwoosh\" and the effects to\n\"fwooshed\". You will, of course, implement the clone() method. In the case of\nFwoosh, it will return a pointer to a new Fwoosh object.\n\nIn the same way, create a concrete ATarget called Dummy, the type of which\nis \"Target Practice Dummy\". You must also implement its clone() method.\n\nAdd to the Warlock the following member functions:\n\n* learnSpell, takes a pointer to ASpell, that makes the Warlock learn a spell\n* forgetSpell, takes a string corresponding a to a spell's name, and makes the\n  Warlock forget it. If it's not a known spell, does nothing.\n* launchSpell, takes a string (a spell name) and a reference to ATarget, that\n  launches the spell on the selected target. If it's not a known spell, does\n  nothing.\n\nYou will need a new attribute to store the spells your Warlock knows. Several\ntypes fit the bill, it's up to you to choose the best one.\n\nBelow is a possible test main and its expected output:\n\nint main()\n{\n  Warlock richard(\"Richard\", \"the Titled\");\n\n  Dummy bob;\n  Fwoosh* fwoosh = new Fwoosh();\n\n  richard.learnSpell(fwoosh);\n\n  richard.introduce();\n  richard.launchSpell(\"Fwoosh\", bob);\n\n  richard.forgetSpell(\"Fwoosh\");\n  richard.launchSpell(\"Fwoosh\", bob);\n}\n\n~$ ./a.out | cat -e\nRichard: This looks like another boring day.$\nRichard: I am Richard, the Titled!$\nTarget Practice Dummy has been fwooshed!$\nRichard: My job here is done!$\n```\n### Code Warlock.cpp:\n```c++\n#include \"Warlock.hpp\"\n\nWarlock::Warlock()\n{\n}\n\nWarlock::Warlock(const std::string &name, const std::string &title)\n: _name(name), _title(title)\n{\n\tstd::cout << _name << \": This looks like another boring day.\" << std::endl;\n}\n\nWarlock::Warlock(const Warlock &src)\n{\n\t(void)src;\n}\n\nWarlock& Warlock::operator=(const Warlock &src)\n{\n\t(void)src;\n\treturn (*this);\n}\n\nWarlock::~Warlock()\n{\n\tstd::cout << _name << \": My job here is done!\" << std::endl;\n}\n\nconst std::string& Warlock::getName() const\n{\n\treturn (_name);\n}\n\nconst std::string& Warlock::getTitle() const\n{\n\treturn (_title);\n}\n\nvoid Warlock::setTitle(const std::string &title)\n{\n\t_title = title;\n}\n\nvoid Warlock::introduce() const\n{\n\tstd::cout << _name << \": I am \" << _name << \", \" << _title << \"!\" << std::endl;\n}\n\nvoid Warlock::learnSpell(ASpell *Spell)\n{\n\tif (_SpellBook.find(Spell->getName()) == _SpellBook.end())\n\t\t_SpellBook[Spell->getName()] = Spell->clone();\n}\n\nvoid Warlock::forgetSpell(std::string spellname)\n{\n\tif (_SpellBook.find(spellname) != _SpellBook.end())\n\t\t_SpellBook.erase(spellname);\n}\n\nvoid Warlock::launchSpell(std::string spellname, const ATarget &target)\n{\n\tif (_SpellBook.find(spellname) != _SpellBook.end())\n\t\t_SpellBook[spellname]->launch(target);\n}\n```\n### Code Warlock.hpp:\n```c++\n#pragma once\n\n#include <iostream>\n#include <string>\n#include <map>\n#include \"ASpell.hpp\"\n#include \"ATarget.hpp\"\n\nclass\tWarlock\n{\n\tpublic:\n\t\tWarlock(const std::string &name, const std::string &title);\n\t\t~Warlock();\n\n\t\tconst std::string &getName() const;\n\t\tconst std::string &getTitle() const;\n\t\tvoid setTitle(const std::string &title);\n\t\tvoid introduce() const;\n\n\t\tvoid learnSpell(ASpell *Spell);\n\t\tvoid forgetSpell(std::string spellname);\n\t\tvoid launchSpell(std::string spellname, const ATarget &target);\n\t\n\tprivate:\n\t\tstd::string _name;\n\t\tstd::string _title;\n\t\tstd::map<std::string, ASpell*>\t_SpellBook;\n\n\t\tWarlock();\n\t\tWarlock(const Warlock &src);\n\t\tWarlock& operator=(const Warlock &src);\n};\n```\n### Code ASpell.cpp:\n```c++\n#include \"ASpell.hpp\"\n\nASpell::ASpell()\n{\n}\n\nASpell::ASpell(const std::string &name, const std::string &effects)\n: _name(name), _effects(effects)\n{\n}\n\nASpell::ASpell(const ASpell &src)\n{\n\t_name = src._name;\n\t_effects = src._effects;\n}\n\nASpell& ASpell::operator=(const ASpell &src)\n{\n\tif (this != &src)\n\t{\n\t\t_name = src._name;\n\t\t_effects = src._effects;\n\t}\n\treturn (*this);\n}\n\nASpell::~ASpell()\n{\n}\n\nstd::string ASpell::getName() const\n{\n\treturn (_name);\n}\n\nstd::string ASpell::getEffects() const\n{\n\treturn (_effects);\n}\n\nvoid ASpell::launch(const ATarget &target) const\n{\n\ttarget.getHitBySpell(*this);\n}\n```\n### Code ASpell.hpp:\n```c++\n#pragma once\n\n#include <iostream>\n#include <string>\n#include \"ATarget.hpp\"\n\nclass\tATarget;\n\nclass\tASpell\n{\n\tpublic:\n\t\tASpell();\n\t\tASpell(const std::string &name, const std::string &effects);\n\t\tASpell(const ASpell &src);\n\t\tASpell& operator=(const ASpell &src);\n\t\tvirtual ~ASpell();\n\n\t\tstd::string getName() const;\n\t\tstd::string getEffects() const;\n\t\tvirtual ASpell* clone() const = 0;\n\n\t\tvoid launch(const ATarget &target) const;\n\n\tprotected:\n\t\tstd::string _name;\n\t\tstd::string _effects;\n};\n```\n### Code ATarget.cpp:\n```c++\n#include \"ATarget.hpp\"\n\nATarget::ATarget()\n{\n}\n\nATarget::ATarget(const std::string &type)\n: _type(type)\n{\n}\n\nATarget::ATarget(const ATarget &src)\n{\n\t_type = src._type;\n}\n\nATarget& ATarget::operator=(const ATarget &src)\n{\n\tif (this != &src)\n\t\t_type = src._type;\n\treturn (*this);\n}\n\nATarget::~ATarget()\n{\n}\n\nconst std::string& ATarget::getType() const\n{\n\treturn (_type);\n}\n\nvoid ATarget::getHitBySpell(const ASpell &spell) const\n{\n\tstd::cout << _type << \" has been \" << spell.getEffects() << \"!\" << std::endl;\n}\n```\n### Code ATarget.hpp:\n```c++\n#pragma once\n\n#include <iostream>\n#include <string>\n#include \"ASpell.hpp\"\n\nclass\tASpell;\n\nclass\tATarget\n{\n\tpublic:\n\t\tATarget();\n\t\tATarget(const std::string &type);\n\t\tATarget(const ATarget &src);\n\t\tATarget& operator=(const ATarget &src);\n\t\tvirtual ~ATarget();\n\n\t\tconst std::string &getType() const;\n\t\tvirtual ATarget* clone() const = 0;\n\t\n\t\tvoid getHitBySpell(const ASpell &spell) const;\n\n\tprotected:\n\t\tstd::string _type;\n};\n```\n### Code Fwoosh.cpp:\n```c++\n#include \"Fwoosh.hpp\"\n\nFwoosh::Fwoosh()\n: ASpell(\"Fwoosh\", \"fwooshed\")\n{\t\n}\n\nFwoosh::~Fwoosh()\n{\n}\n\nFwoosh* Fwoosh::clone() const\n{\n\treturn (new Fwoosh());\n}\n```\n### Code Fwoosh.hpp:\n```c++\n#pragma once\n\n#include \"ASpell.hpp\"\n\nclass\tFwoosh : public ASpell\n{\n\tpublic:\n\t\tFwoosh();\n\t\t~Fwoosh();\n\t\tvirtual Fwoosh* clone() const;\n};\n```\n### Code Dummy.cpp:\n```c++\n#include \"Dummy.hpp\"\n\nDummy::Dummy()\n: ATarget(\"Target Practice Dummy\")\n{\n}\n\nDummy::~Dummy()\n{\n}\n\nDummy* Dummy::clone() const\n{\n\treturn (new Dummy());\n}\n```\n### Code Dummy.hpp:\n```c++\n#pragma once\n\n#include \"ATarget.hpp\"\n\nclass\tDummy : public ATarget\n{\n\tpublic:\n\t\tDummy();\n\t\t~Dummy();\n\t\tvirtual Dummy* clone() const;\n};\n```\n### Code main.cpp:\n```c++\n#include \"Warlock.hpp\"\n#include \"ASpell.hpp\"\n#include \"ATarget.hpp\"\n#include \"Fwoosh.hpp\"\n#include \"Dummy.hpp\"\n\nint main()\n{\n  Warlock richard(\"Richard\", \"the Titled\");\n\n  Dummy bob;\n  Fwoosh* fwoosh = new Fwoosh();\n\n  richard.learnSpell(fwoosh);\n\n  richard.introduce();\n  richard.launchSpell(\"Fwoosh\", bob);\n\n  richard.forgetSpell(\"Fwoosh\");\n  richard.launchSpell(\"Fwoosh\", bob);\n}\n```",
            "FR": "## cpp_module_01\n\n---\n\n### Subject:\n```text\nNom de l'assignation : cpp_module_01\nFichiers attendus : Warlock.cpp Warlock.hpp\n                   ASpell.hpp ASpell.cpp\n                   ATarget.hpp ATarget.cpp\n                   Fwoosh.hpp Fwoosh.cpp\n                   Dummy.hpp Dummy.cpp\n--------------------------------------------------------------------------------\n\nDans la classe Warlock, l'instruction switch est INTERDITE et son utilisation entraînerait un -42.\n\nCréez une classe abstraite appelée ASpell, sous la forme de Coplien, qui a les attributs protégés suivants :\n\n* name (string)\n* effects (string)\n\nLes deux auront des getters (getName et getEffects) qui renvoient des strings.\n\nAjoutez également une méthode pure clone qui renvoie un pointeur vers ASpell.\n\nToutes ces fonctions peuvent être appelées sur un objet constant.\n\nASpell a un constructeur qui prend son nom et ses effets, dans cet ordre.\n\nMaintenant, vous allez créer une classe abstraite ATarget, sous la forme de Coplien. Elle a un attribut type, qui est une string, et son getter associé, getType, qui renvoie une référence à une string constante.\n\nDe la même manière qu'ASpell, elle a une méthode pure clone().\n\nToutes ces fonctions peuvent être appelées sur un objet constant.\n\nElle a un constructeur qui prend son type.\n\nMaintenant, ajoutez à votre ATarget une fonction getHitBySpell qui prend une référence à ASpell constant.\n\nElle affichera :\n\n<TYPE> has been <EFFECTS>!\n\n<TYPE> est le type de ATarget, et <EFFECTS> est le retour de la fonction getEffects de ASpell.\n\nEnfin, ajoutez à votre classe ASpell une fonction launch qui prend une référence à ATarget constant.\n\nCelle-ci appellera simplement getHitBySpell de l'objet passé, en passant l'instance actuelle comme paramètre.\n\nUne fois que tout cela est fait, créez une implémentation de ASpell appelée Fwoosh. Son constructeur par défaut définira le nom sur \"Fwoosh\" et les effets sur \"fwooshed\". Vous implémenterez, bien sûr, la méthode clone(). Dans le cas de Fwoosh, elle renverra un pointeur vers un nouvel objet Fwoosh.\n\nDe la même manière, créez un ATarget concret appelé Dummy, dont le type est \"Target Practice Dummy\". Vous devez également implémenter sa méthode clone().\n\nAjoutez à Warlock les fonctions membres suivantes :\n\n* learnSpell, prend un pointeur vers ASpell, qui fait apprendre un sort au Warlock\n* forgetSpell, prend une string correspondant au nom d'un sort, et fait oublier le sort au Warlock. Si ce n'est pas un sort connu, ne fait rien.\n* launchSpell, prend une string (un nom de sort) et une référence à ATarget, qui lance le sort sur la cible sélectionnée. Si ce n'est pas un sort connu, ne fait rien.\n\nVous aurez besoin d'un nouvel attribut pour stocker les sorts que votre Warlock connaît. Plusieurs types conviennent, c'est à vous de choisir le meilleur.\n\nBelow is a possible test main and its expected output:\n\nint main()\n{\n  Warlock richard(\"Richard\", \"the Titled\");\n\n  Dummy bob;\n  Fwoosh* fwoosh = new Fwoosh();\n\n  richard.learnSpell(fwoosh);\n\n  richard.introduce();\n  richard.launchSpell(\"Fwoosh\", bob);\n\n  richard.forgetSpell(\"Fwoosh\");\n  richard.launchSpell(\"Fwoosh\", bob);\n}\n\n~$ ./a.out | cat -e\nRichard: This looks like another boring day.$\nRichard: I am Richard, the Titled!$\nTarget Practice Dummy has been fwooshed!$\nRichard: My job here is done!$\n```\n### Code Warlock.cpp:\n```c++\n#include \"Warlock.hpp\"\n\nWarlock::Warlock()\n{\n}\n\nWarlock::Warlock(const std::string &name, const std::string &title)\n: _name(name), _title(title)\n{\n\tstd::cout << _name << \": This looks like another boring day.\" << std::endl;\n}\n\nWarlock::Warlock(const Warlock &src)\n{\n\t(void)src;\n}\n\nWarlock& Warlock::operator=(const Warlock &src)\n{\n\t(void)src;\n\treturn (*this);\n}\n\nWarlock::~Warlock()\n{\n\tstd::cout << _name << \": My job here is done!\" << std::endl;\n}\n\nconst std::string& Warlock::getName() const\n{\n\treturn (_name);\n}\n\nconst std::string& Warlock::getTitle() const\n{\n\treturn (_title);\n}\n\nvoid Warlock::setTitle(const std::string &title)\n{\n\t_title = title;\n}\n\nvoid Warlock::introduce() const\n{\n\tstd::cout << _name << \": I am \" << _name << \", \" << _title << \"!\" << std::endl;\n}\n\nvoid Warlock::learnSpell(ASpell *Spell)\n{\n\tif (_SpellBook.find(Spell->getName()) == _SpellBook.end())\n\t\t_SpellBook[Spell->getName()] = Spell->clone();\n}\n\nvoid Warlock::forgetSpell(std::string spellname)\n{\n\tif (_SpellBook.find(spellname) != _SpellBook.end())\n\t\t_SpellBook.erase(spellname);\n}\n\nvoid Warlock::launchSpell(std::string spellname, const ATarget &target)\n{\n\tif (_SpellBook.find(spellname) != _SpellBook.end())\n\t\t_SpellBook[spellname]->launch(target);\n}\n```\n### Code Warlock.hpp:\n```c++\n#pragma once\n\n#include <iostream>\n#include <string>\n#include <map>\n#include \"ASpell.hpp\"\n#include \"ATarget.hpp\"\n\nclass\tWarlock\n{\n\tpublic:\n\t\tWarlock(const std::string &name, const std::string &title);\n\t\t~Warlock();\n\n\t\tconst std::string &getName() const;\n\t\tconst std::string &getTitle() const;\n\t\tvoid setTitle(const std::string &title);\n\t\tvoid introduce() const;\n\n\t\tvoid learnSpell(ASpell *Spell);\n\t\tvoid forgetSpell(std::string spellname);\n\t\tvoid launchSpell(std::string spellname, const ATarget &target);\n\t\n\tprivate:\n\t\tstd::string _name;\n\t\tstd::string _title;\n\t\tstd::map<std::string, ASpell*>\t_SpellBook;\n\n\t\tWarlock();\n\t\tWarlock(const Warlock &src);\n\t\tWarlock& operator=(const Warlock &src);\n};\n```\n### Code ASpell.cpp:\n```c++\n#include \"ASpell.hpp\"\n\nASpell::ASpell()\n{\n}\n\nASpell::ASpell(const std::string &name, const std::string &effects)\n: _name(name), _effects(effects)\n{\n}\n\nASpell::ASpell(const ASpell &src)\n{\n\t_name = src._name;\n\t_effects = src._effects;\n}\n\nASpell& ASpell::operator=(const ASpell &src)\n{\n\tif (this != &src)\n\t{\n\t\t_name = src._name;\n\t\t_effects = src._effects;\n\t}\n\treturn (*this);\n}\n\nASpell::~ASpell()\n{\n}\n\nstd::string ASpell::getName() const\n{\n\treturn (_name);\n}\n\nstd::string ASpell::getEffects() const\n{\n\treturn (_effects);\n}\n\nvoid ASpell::launch(const ATarget &target) const\n{\n\ttarget.getHitBySpell(*this);\n}\n```\n### Code ASpell.hpp:\n```c++\n#pragma once\n\n#include <iostream>\n#include <string>\n#include \"ATarget.hpp\"\n\nclass\tATarget;\n\nclass\tASpell\n{\n\tpublic:\n\t\tASpell();\n\t\tASpell(const std::string &name, const std::string &effects);\n\t\tASpell(const ASpell &src);\n\t\tASpell& operator=(const ASpell &src);\n\t\tvirtual ~ASpell();\n\n\t\tstd::string getName() const;\n\t\tstd::string getEffects() const;\n\t\tvirtual ASpell* clone() const = 0;\n\n\t\tvoid launch(const ATarget &target) const;\n\n\tprotected:\n\t\tstd::string _name;\n\t\tstd::string _effects;\n};\n```\n### Code ATarget.cpp:\n```c++\n#include \"ATarget.hpp\"\n\nATarget::ATarget()\n{\n}\n\nATarget::ATarget(const std::string &type)\n: _type(type)\n{\n}\n\nATarget::ATarget(const ATarget &src)\n{\n\t_type = src._type;\n}\n\nATarget& ATarget::operator=(const ATarget &src)\n{\n\tif (this != &src)\n\t\t_type = src._type;\n\treturn (*this);\n}\n\nATarget::~ATarget()\n{\n}\n\nconst std::string& ATarget::getType() const\n{\n\treturn (_type);\n}\n\nvoid ATarget::getHitBySpell(const ASpell &spell) const\n{\n\tstd::cout << _type << \" has been \" << spell.getEffects() << \"!\" << std::endl;\n}\n```\n### Code ATarget.hpp:\n```c++\n#pragma once\n\n#include <iostream>\n#include <string>\n#include \"ASpell.hpp\"\n\nclass\tASpell;\n\nclass\tATarget\n{\n\tpublic:\n\t\tATarget();\n\t\tATarget(const std::string &type);\n\t\tATarget(const ATarget &src);\n\t\tATarget& operator=(const ATarget &src);\n\t\tvirtual ~ATarget();\n\n\t\tconst std::string &getType() const;\n\t\tvirtual ATarget* clone() const = 0;\n\t\n\t\tvoid getHitBySpell(const ASpell &spell) const;\n\n\tprotected:\n\t\tstd::string _type;\n};\n```\n### Code Fwoosh.cpp:\n```c++\n#include \"Fwoosh.hpp\"\n\nFwoosh::Fwoosh()\n: ASpell(\"Fwoosh\", \"fwooshed\")\n{\t\n}\n\nFwoosh::~Fwoosh()\n{\n}\n\nFwoosh* Fwoosh::clone() const\n{\n\treturn (new Fwoosh());\n}\n```\n### Code Fwoosh.hpp:\n```c++\n#pragma once\n\n#include \"ASpell.hpp\"\n\nclass\tFwoosh : public ASpell\n{\n\tpublic:\n\t\tFwoosh();\n\t\t~Fwoosh();\n\t\tvirtual Fwoosh* clone() const;\n};\n```\n### Code Dummy.cpp:\n```c++\n#include \"Dummy.hpp\"\n\nDummy::Dummy()\n: ATarget(\"Target Practice Dummy\")\n{\n}\n\nDummy::~Dummy()\n{\n}\n\nDummy* Dummy::clone() const\n{\n\treturn (new Dummy());\n}\n```\n### Code Dummy.hpp:\n```c++\n#pragma once\n\n#include \"ATarget.hpp\"\n\nclass\tDummy : public ATarget\n{\n\tpublic:\n\t\tDummy();\n\t\t~Dummy();\n\t\tvirtual Dummy* clone() const;\n};\n```\n### Code main.cpp:\n```c++\n#include \"Warlock.hpp\"\n#include \"ASpell.hpp\"\n#include \"ATarget.hpp\"\n#include \"Fwoosh.hpp\"\n#include \"Dummy.hpp\"\n\nint main()\n{\n  Warlock richard(\"Richard\", \"the Titled\");\n\n  Dummy bob;\n  Fwoosh* fwoosh = new Fwoosh();\n\n  richard.learnSpell(fwoosh);\n\n  richard.introduce();\n  richard.launchSpell(\"Fwoosh\", bob);\n\n  richard.forgetSpell(\"Fwoosh\");\n  richard.launchSpell(\"Fwoosh\", bob);\n}\n```"
          },
          "yes_no": false,
          "separator": "border-t-2",
          "type": "mandatory"
        },
        {
          "description": {
            "EN": "## cpp_module_02\n\n---\n\n### Subject:\n```text\nAssignment name  : cpp_module_02\nExpected files   : Warlock.cpp Warlock.hpp\n                   ASpell.hpp ASpell.cpp\n\t\t\t\t   ATarget.hpp ATarget.cpp\n\t\t\t\t   Fwoosh.hpp Fwoosh.cpp\n\t\t\t\t   Dummy.hpp Dummy.cpp\n\t\t\t\t   Fireball.hpp Fireball.cpp\n\t\t\t\t   Polymorph.hpp Polymorph.cpp\n\t\t\t\t   BrickWall.hpp BrickWall.cpp\n\t\t\t\t   SpellBook.hpp SpellBook.cpp\n\t\t\t\t   TargetGenerator.hpp TargetGenerator.cpp\n--------------------------------------------------------------------------------\n\nIn the Warlock, SpellBook and TargetGenerator classes, the switch statement is\nFORBIDDEN and its use would result in a -42.\n\nCreate the following two spells, on the same model as Fwoosh:\n\n* Fireball (Name: \"Fireball\", Effects: \"burnt to a crisp\")\n* Polymorph (Name: \"Polymorph\", Effects: \"turned into a critter\")\n\nIn addition to this, just so he won't have only dummy to attack, let's make a\nnew target for him, which will be the BrickWall (Type: \"Inconspicuous Red-brick Wall\").\n\nNow, make a SpellBook class, in canonical form, that can't be copied or instantiated\nby copy. It will have the following functions:\n\n* void learnSpell(ASpell*), that COPIES a spell in the book\n* void forgetSpell(string const &), that deletes a spell from the book, except\n  if it isn't there\n* ASpell* createSpell(string const &), that receives a string corresponding to\n  the name of a spell, creates it, and returns it.\n\nModify the Warlock, now, make it have a spell book that will be created with\nhim and destroyed with him. Also make his learnSpell and forgetSpell functions\ncall those of the spell book.\n\nThe launchSpell function will have to use the SpellBook to create the spell\nit's attempting to launch.\n\nMake a TargetGenerator class, in canonical form, and as before,\nnon-copyable.\n\nIt will have the following functions:\n\n* void learnTargetType(ATarget*), teaches a target to the generator\n\n* void forgetTargetType(string const &), that makes the generator forget a\n  target type if it's known\n\n* ATarget* createTarget(string const &), that creates a target of the\n  specified type\n\nPhew, that's done. Now here's a test main. It's not very thorough, so make sure \nto use your own aswell.\n\nint main()\n{\n  Warlock richard(\"Richard\", \"foo\");\n  richard.setTitle(\"Hello, I'm Richard the Warlock!\");\n  BrickWall model1;\n\n  Polymorph* polymorph = new Polymorph();\n  TargetGenerator tarGen;\n\n  tarGen.learnTargetType(&model1);\n  richard.learnSpell(polymorph);\n\n  Fireball* fireball = new Fireball();\n\n  richard.learnSpell(fireball);\n\n  ATarget* wall = tarGen.createTarget(\"Inconspicuous Red-brick Wall\");\n\n  richard.introduce();\n  richard.launchSpell(\"Polymorph\", *wall);\n  richard.launchSpell(\"Fireball\", *wall);\n}\n\n~$ ./a.out | cat -e\nRichard: This looks like another boring day.$\nRichard: I am Richard, Hello, I'm Richard the Warlock!!$\nInconspicuous Red-brick Wall has been turned into a critter!$\nInconspicuous Red-brick Wall has been burnt to a crisp!$\nRichard: My job here is done!$\n~$\n```\n### Code Warlock.cpp:\n```c++\n#include \"Warlock.hpp\"\n\nWarlock::Warlock()\n{\n}\n\nWarlock::Warlock(const std::string &name, const std::string &title)\n: _name(name), _title(title)\n{\n\tstd::cout << _name << \": This looks like another boring day.\" << std::endl;\n}\n\nWarlock::Warlock(const Warlock &src)\n{\n\t(void)src;\n}\n\nWarlock& Warlock::operator=(const Warlock &src)\n{\n\t(void)src;\n\treturn (*this);\n}\n\nWarlock::~Warlock()\n{\n\tstd::cout << _name << \": My job here is done!\" << std::endl;\n}\n\nconst std::string& Warlock::getName() const\n{\n\treturn (_name);\n}\n\nconst std::string& Warlock::getTitle() const\n{\n\treturn (_title);\n}\n\nvoid Warlock::setTitle(const std::string &title)\n{\n\t_title = title;\n}\n\nvoid Warlock::introduce() const\n{\n\tstd::cout << _name << \": I am \" << _name << \", \" << _title << \"!\" << std::endl;\n}\n\nvoid Warlock::learnSpell(ASpell *Spell)\n{\n\t_SpellBook.learnSpell(Spell);\n}\n\nvoid Warlock::forgetSpell(std::string spellname)\n{\n\t_SpellBook.forgetSpell(spellname);\n}\n\nvoid Warlock::launchSpell(std::string spellname, const ATarget &target)\n{\n\tstd::map<std::string, ASpell*> copy = _SpellBook.getBook();\n\tstd::map<std::string, ASpell*>::iterator it = copy.find(spellname);\n\n\tif (it != copy.end())\n\t\tit->second->launch(target);\n}\n```\n### Code Warlock.hpp:\n```c++\n#pragma once\n\n#include <iostream>\n#include <string>\n#include <map>\n#include \"ASpell.hpp\"\n#include \"ATarget.hpp\"\n#include \"SpellBook.hpp\"\n\nclass\tWarlock\n{\n\tpublic:\n\t\tWarlock(const std::string &name, const std::string &title);\n\t\t~Warlock();\n\n\t\tconst std::string &getName() const;\n\t\tconst std::string &getTitle() const;\n\t\tvoid setTitle(const std::string &title);\n\t\tvoid introduce() const;\n\n\t\tvoid learnSpell(ASpell *Spell);\n\t\tvoid forgetSpell(std::string spellname);\n\t\tvoid launchSpell(std::string spellname, const ATarget &target);\n\t\n\tprivate:\n\t\tstd::string _name;\n\t\tstd::string _title;\n\t\tSpellBook\t_SpellBook;\n\n\t\tWarlock();\n\t\tWarlock(const Warlock &src);\n\t\tWarlock& operator=(const Warlock &src);\n};\n```\n### Code ASpell.cpp:\n```c++\n#include \"ASpell.hpp\"\n\nASpell::ASpell()\n{\n}\n\nASpell::ASpell(const std::string &name, const std::string &effects)\n: _name(name), _effects(effects)\n{\n}\n\nASpell::ASpell(const ASpell &src)\n{\n\t_name = src._name;\n\t_effects = src._effects;\n}\n\nASpell& ASpell::operator=(const ASpell &src)\n{\n\tif (this != &src)\n\t{\n\t\t_name = src._name;\n\t\t_effects = src._effects;\n\t}\n\treturn (*this);\n}\n\nASpell::~ASpell()\n{\n}\n\nstd::string ASpell::getName() const\n{\n\treturn (_name);\n}\n\nstd::string ASpell::getEffects() const\n{\n\treturn (_effects);\n}\n\nvoid ASpell::launch(const ATarget &target) const\n{\n\ttarget.getHitBySpell(*this);\n}\n\n```\n### Code ASpell.hpp:\n```c++\n#pragma once\n\n#include <iostream>\n#include <string>\n#include \"ATarget.hpp\"\n\nclass\tATarget;\n\nclass\tASpell\n{\n\tpublic:\n\t\tASpell();\n\t\tASpell(const std::string &name, const std::string &effects);\n\t\tASpell(const ASpell &src);\n\t\tASpell& operator=(const ASpell &src);\n\t\tvirtual ~ASpell();\n\n\t\tstd::string getName() const;\n\t\tstd::string getEffects() const;\n\t\tvirtual ASpell* clone() const = 0;\n\n\t\tvoid launch(const ATarget &target) const;\n\n\tprotected:\n\t\tstd::string _name;\n\t\tstd::string _effects;\n};\n```\n### Code ATarget.cpp:\n```c++\n#include \"ATarget.hpp\"\n\nATarget::ATarget()\n{\n}\n\nATarget::ATarget(const std::string &type)\n: _type(type)\n{\n}\n\nATarget::ATarget(const ATarget &src)\n{\n\t_type = src._type;\n}\n\nATarget& ATarget::operator=(const ATarget &src)\n{\n\tif (this != &src)\n\t\t_type = src._type;\n\treturn (*this);\n}\n\nATarget::~ATarget()\n{\n}\n\nconst std::string& ATarget::getType() const\n{\n\treturn (_type);\n}\n\nvoid ATarget::getHitBySpell(const ASpell &spell) const\n{\n\tstd::cout << _type << \" has been \" << spell.getEffects() << \"!\" << std::endl;\n}\n```\n### Code ATarget.hpp:\n```c++\n#pragma once\n\n#include <iostream>\n#include <string>\n#include \"ASpell.hpp\"\n\nclass\tASpell;\n\nclass\tATarget\n{\n\tpublic:\n\t\tATarget();\n\t\tATarget(const std::string &type);\n\t\tATarget(const ATarget &src);\n\t\tATarget& operator=(const ATarget &src);\n\t\tvirtual ~ATarget();\n\n\t\tconst std::string &getType() const;\n\t\tvirtual ATarget* clone() const = 0;\n\t\n\t\tvoid getHitBySpell(const ASpell &spell) const;\n\n\tprotected:\n\t\tstd::string _type;\n};\n```\n### Code Fwoosh.cpp:\n```c++\n#include \"Fwoosh.hpp\"\n\nFwoosh::Fwoosh()\n: ASpell(\"Fwoosh\", \"fwooshed\")\n{\t\n}\n\nFwoosh::~Fwoosh()\n{\n}\n\nFwoosh* Fwoosh::clone() const\n{\n\treturn (new Fwoosh());\n}\n```\n### Code Fwoosh.hpp:\n```c++\n#pragma once\n\n#include \"ASpell.hpp\"\n\nclass\tFwoosh : public ASpell\n{\n\tpublic:\n\t\tFwoosh();\n\t\t~Fwoosh();\n\t\tvirtual Fwoosh* clone() const;\n};\n```\n### Code Fireball.cpp:\n```c++\n#include \"Fireball.hpp\"\n\nFireball::Fireball()\n: ASpell(\"Fireball\", \"burnt to a crisp\")\n{\n}\n\nFireball::~Fireball()\n{\n}\n\nFireball* Fireball::clone() const\n{\n\treturn (new Fireball());\n}\n```\n### Code Fireball.hpp:\n```c++\n#pragma once\n\n#include \"ASpell.hpp\"\n\nclass\tFireball : public ASpell\n{\n\tpublic:\n\t\tFireball();\n\t\t~Fireball();\n\t\tvirtual Fireball* clone() const;\n};\n```\n### Code Polymorph.cpp:\n```c++\n#include \"Polymorph.hpp\"\n\nPolymorph::Polymorph()\n: ASpell(\"Polymorph\", \"turned into a critter\")\n{\n}\n\nPolymorph::~Polymorph()\n{\n}\n\nPolymorph* Polymorph::clone() const\n{\n\treturn (new Polymorph());\n}\n```\n### Code Polymorph.hpp:\n```c++\n#pragma once\n\n#include \"ASpell.hpp\"\n\nclass\tPolymorph : public ASpell\n{\n\tpublic:\n\t\tPolymorph();\n\t\t~Polymorph();\n\t\tvirtual Polymorph* clone() const;\n};\n```\n### Code BrickWall.cpp:\n```c++\n#include \"BrickWall.hpp\"\n\nBrickWall::BrickWall()\n: ATarget(\"Inconspicuous Red-brick Wall\")\n{\n}\n\nBrickWall::~BrickWall()\n{\n}\n\nBrickWall* BrickWall::clone() const\n{\n\treturn (new BrickWall());\n}\n\n```\n### Code BrickWall.hpp:\n```c++\n#pragma once\n\n#include \"ATarget.hpp\"\n\nclass\tBrickWall : public ATarget\n{\n\tpublic:\n\t\tBrickWall();\n\t\t~BrickWall();\n\t\tvirtual BrickWall* clone() const;\n};\n```\n### Code SpellBook.cpp:\n```c++\n#include \"SpellBook.hpp\"\n\nSpellBook::SpellBook()\n{\n}\n\nSpellBook::SpellBook(const SpellBook &src)\n{\n\t(void)src;\n}\n\nSpellBook& SpellBook::operator=(const SpellBook &src)\n{\n\t(void)src;\n\treturn (*this);\n}\n\nSpellBook::~SpellBook()\n{\n\tfor (std::map<std::string, ASpell*>::iterator it = _Book.begin(); it != _Book.end(); it++)\n\t\tdelete it->second;\n\t_Book.clear();\n}\n\nvoid\tSpellBook::learnSpell(ASpell *Spell)\n{\n\tif (_Book.find(Spell->getName()) == _Book.end())\n\t\t_Book[Spell->getName()] = Spell->clone();\n}\n\nvoid\tSpellBook::forgetSpell(const std::string &spellname)\n{\n\tfor (std::map<std::string, ASpell*>::iterator it = _Book.begin(); it != _Book.end(); it++)\n\t{\n\t\tif (it->first == spellname)\n\t\t\tdelete it->second;\n\t}\n}\n\nASpell*\tSpellBook::createSpell(const std::string &spellname)\n{\n\tfor (std::map<std::string, ASpell*>::iterator it = _Book.begin(); it != _Book.end(); it++)\n\t{\n\t\tif (it->first == spellname)\n\t\t\treturn(it->second->clone());\n\t}\n\treturn (NULL);\n}\n\nconst std::map<std::string, ASpell*>&\tSpellBook::getBook() const\n{\n\treturn (_Book);\n}\n```\n### Code SpellBook.hpp:\n```c++\n#pragma once\n\n#include <iostream>\n#include <string>\n#include <map>\n#include \"ASpell.hpp\"\n\nclass\tSpellBook\n{\n\tpublic:\n\t\tSpellBook();\n\t\t~SpellBook();\n\n\t\tvoid learnSpell(ASpell *Spell);\n\t\tvoid forgetSpell(const std::string &spellname);\n\t\tASpell* createSpell(const std::string &spellname);\n\n\t\tconst std::map<std::string, ASpell*>& getBook() const;\n\t\n\tprivate:\n\t\tstd::map<std::string, ASpell*> _Book;\n\t\n\t\tSpellBook(const SpellBook &src);\n\t\tSpellBook& operator=(const SpellBook &src);\n};\n```\n### Code TargetGenerator.cpp:\n```c++\n#include \"TargetGenerator.hpp\"\n\nTargetGenerator::TargetGenerator()\n{\n}\n\nTargetGenerator::TargetGenerator(const TargetGenerator &src)\n{\n\t(void)src;\n}\n\nTargetGenerator& TargetGenerator::operator=(const TargetGenerator &src)\n{\n\t(void)src;\n\treturn (*this);\n}\n\nTargetGenerator::~TargetGenerator()\n{\n\tfor (std::map<std::string, ATarget*>::iterator it = _list.begin(); it != _list.end(); it++)\n\t\tdelete it->second;\n\t_list.clear();\n}\n\nvoid\tTargetGenerator::learnTargetType(ATarget *target)\n{\n\tif (_list.find(target->getType()) == _list.end())\n\t\t_list[target->getType()] = target->clone();\n}\n\nvoid\tTargetGenerator::forgetTargetType(const std::string &targettype)\n{\n\tfor (std::map<std::string, ATarget*>::iterator it = _list.begin(); it != _list.end(); it++)\n\t{\n\t\tif (it->first == targettype)\n\t\t\tdelete it->second;\n\t}\n}\n\nATarget*\tTargetGenerator::createTarget(const std::string &targettype)\n{\n\tif (_list.find(targettype) != _list.end())\n\t\treturn (_list[targettype]->clone());\n\treturn (NULL);\n}\n```\n### Code TargetGenerator.hpp:\n```c++\n#pragma once\n\n#include <iostream>\n#include <string>\n#include <map>\n#include \"ATarget.hpp\"\n\nclass\tTargetGenerator\n{\n\tpublic:\n\t\tTargetGenerator();\n\t\t~TargetGenerator();\n\n\t\tvoid learnTargetType(ATarget *target);\n\t\tvoid forgetTargetType(const std::string &targettype);\n\t\tATarget* createTarget(const std::string &targettype);\n\n\tprivate:\n\t\tstd::map<std::string, ATarget*>\t_list;\n\n\t\tTargetGenerator(const TargetGenerator &src);\n\t\tTargetGenerator& operator=(const TargetGenerator &src);\n};\n```\n### Code main.cpp\n```c++\n#include \"Warlock.hpp\"\n#include \"ASpell.hpp\"\n#include \"ATarget.hpp\"\n#include \"Fwoosh.hpp\"\n#include \"Dummy.hpp\"\n#include \"Fireball.hpp\"\n#include \"Polymorph.hpp\"\n#include \"BrickWall.hpp\"\n#include \"SpellBook.hpp\"\n#include \"TargetGenerator.hpp\"\n\nint main()\n{\n  Warlock richard(\"Richard\", \"foo\");\n  richard.setTitle(\"Hello, I'm Richard the Warlock!\");\n  BrickWall model1;\n\n  Polymorph* polymorph = new Polymorph();\n  TargetGenerator tarGen;\n\n  tarGen.learnTargetType(&model1);\n  richard.learnSpell(polymorph);\n\n  Fireball* fireball = new Fireball();\n\n  richard.learnSpell(fireball);\n\n  ATarget* wall = tarGen.createTarget(\"Inconspicuous Red-brick Wall\");\n\n  richard.introduce();\n  richard.launchSpell(\"Polymorph\", *wall);\n  richard.launchSpell(\"Fireball\", *wall);\n}\n```",
            "FR": "## cpp_module_02\n\n---\n\n### Subject:\n```text\nNom de l'assignation : cpp_module_02\nFichiers attendus : Warlock.cpp Warlock.hpp\n                   ASpell.hpp ASpell.cpp\n                   ATarget.hpp ATarget.cpp\n                   Fwoosh.hpp Fwoosh.cpp\n                   Dummy.hpp Dummy.cpp\n                   Fireball.hpp Fireball.cpp\n                   Polymorph.hpp Polymorph.cpp\n                   BrickWall.hpp BrickWall.cpp\n                   SpellBook.hpp SpellBook.cpp\n                   TargetGenerator.hpp TargetGenerator.cpp\n--------------------------------------------------------------------------------\n\nDans les classes Warlock, SpellBook et TargetGenerator, l'instruction switch est\nINTERDITE et son utilisation entraînerait un -42.\n\nCréez les deux sorts suivants, sur le même modèle que Fwoosh :\n\n* Fireball (Nom : \"Fireball\", Effets : \"burnt to a crisp\")\n* Polymorph (Nom : \"Polymorph\", Effets : \"turned into a critter\")\n\nDe plus, juste pour qu'il n'ait pas seulement un dummy à attaquer, créons une\nnouvelle cible pour lui, qui sera le BrickWall (Type : \"Inconspicuous Red-brick Wall\").\n\nMaintenant, créez une classe SpellBook, sous forme canonique, qui ne peut pas être copiée ou instanciée\npar copie. Elle aura les fonctions suivantes :\n\n* void learnSpell(ASpell*), qui COPIE un sort dans le livre\n* void forgetSpell(string const &), qui supprime un sort du livre, sauf\n  s'il n'y est pas\n* ASpell* createSpell(string const &), qui reçoit une string correspondant au\n  nom d'un sort, le crée et le renvoie.\n\nModifiez le Warlock, maintenant, faites en sorte qu'il ait un spell book qui sera créé avec\nlui et détruit avec lui. Faites également en sorte que ses fonctions learnSpell et forgetSpell\nappellent celles du spell book.\n\nLa fonction launchSpell devra utiliser le SpellBook pour créer le sort\nqu'elle tente de lancer.\n\nCréez une classe TargetGenerator, sous forme canonique, et comme avant,\nnon-copiable.\n\nElle aura les fonctions suivantes :\n\n* void learnTargetType(ATarget*), enseigne une cible au générateur\n\n* void forgetTargetType(string const &), qui fait oublier un type de cible au générateur\n  s'il est connu\n\n* ATarget* createTarget(string const &), qui crée une cible du\n  type spécifié\n\nOuf, c'est fait. Voici maintenant un main de test. Il n'est pas très complet, alors assurez-vous\nd'utiliser le vôtre également.\n\nint main()\n{\n  Warlock richard(\"Richard\", \"foo\");\n  richard.setTitle(\"Hello, I'm Richard the Warlock!\");\n  BrickWall model1;\n\n  Polymorph* polymorph = new Polymorph();\n  TargetGenerator tarGen;\n\n  tarGen.learnTargetType(&model1);\n  richard.learnSpell(polymorph);\n\n  Fireball* fireball = new Fireball();\n\n  richard.learnSpell(fireball);\n\n  ATarget* wall = tarGen.createTarget(\"Inconspicuous Red-brick Wall\");\n\n  richard.introduce();\n  richard.launchSpell(\"Polymorph\", *wall);\n  richard.launchSpell(\"Fireball\", *wall);\n}\n\n~$ ./a.out | cat -e\nRichard: This looks like another boring day.$\nRichard: I am Richard, Hello, I'm Richard the Warlock!!$\nInconspicuous Red-brick Wall has been turned into a critter!$\nInconspicuous Red-brick Wall has been burnt to a crisp!$\nRichard: My job here is done!$\n~$\n```\n### Code Warlock.cpp:\n```c++\n#include \"Warlock.hpp\"\n\nWarlock::Warlock()\n{\n}\n\nWarlock::Warlock(const std::string &name, const std::string &title)\n: _name(name), _title(title)\n{\n\tstd::cout << _name << \": This looks like another boring day.\" << std::endl;\n}\n\nWarlock::Warlock(const Warlock &src)\n{\n\t(void)src;\n}\n\nWarlock& Warlock::operator=(const Warlock &src)\n{\n\t(void)src;\n\treturn (*this);\n}\n\nWarlock::~Warlock()\n{\n\tstd::cout << _name << \": My job here is done!\" << std::endl;\n}\n\nconst std::string& Warlock::getName() const\n{\n\treturn (_name);\n}\n\nconst std::string& Warlock::getTitle() const\n{\n\treturn (_title);\n}\n\nvoid Warlock::setTitle(const std::string &title)\n{\n\t_title = title;\n}\n\nvoid Warlock::introduce() const\n{\n\tstd::cout << _name << \": I am \" << _name << \", \" << _title << \"!\" << std::endl;\n}\n\nvoid Warlock::learnSpell(ASpell *Spell)\n{\n\t_SpellBook.learnSpell(Spell);\n}\n\nvoid Warlock::forgetSpell(std::string spellname)\n{\n\t_SpellBook.forgetSpell(spellname);\n}\n\nvoid Warlock::launchSpell(std::string spellname, const ATarget &target)\n{\n\tstd::map<std::string, ASpell*> copy = _SpellBook.getBook();\n\tstd::map<std::string, ASpell*>::iterator it = copy.find(spellname);\n\n\tif (it != copy.end())\n\t\tit->second->launch(target);\n}\n```\n### Code Warlock.hpp:\n```c++\n#pragma once\n\n#include <iostream>\n#include <string>\n#include <map>\n#include \"ASpell.hpp\"\n#include \"ATarget.hpp\"\n#include \"SpellBook.hpp\"\n\nclass\tWarlock\n{\n\tpublic:\n\t\tWarlock(const std::string &name, const std::string &title);\n\t\t~Warlock();\n\n\t\tconst std::string &getName() const;\n\t\tconst std::string &getTitle() const;\n\t\tvoid setTitle(const std::string &title);\n\t\tvoid introduce() const;\n\n\t\tvoid learnSpell(ASpell *Spell);\n\t\tvoid forgetSpell(std::string spellname);\n\t\tvoid launchSpell(std::string spellname, const ATarget &target);\n\t\n\tprivate:\n\t\tstd::string _name;\n\t\tstd::string _title;\n\t\tSpellBook\t_SpellBook;\n\n\t\tWarlock();\n\t\tWarlock(const Warlock &src);\n\t\tWarlock& operator=(const Warlock &src);\n};\n```\n### Code ASpell.cpp:\n```c++\n#include \"ASpell.hpp\"\n\nASpell::ASpell()\n{\n}\n\nASpell::ASpell(const std::string &name, const std::string &effects)\n: _name(name), _effects(effects)\n{\n}\n\nASpell::ASpell(const ASpell &src)\n{\n\t_name = src._name;\n\t_effects = src._effects;\n}\n\nASpell& ASpell::operator=(const ASpell &src)\n{\n\tif (this != &src)\n\t{\n\t\t_name = src._name;\n\t\t_effects = src._effects;\n\t}\n\treturn (*this);\n}\n\nASpell::~ASpell()\n{\n}\n\nstd::string ASpell::getName() const\n{\n\treturn (_name);\n}\n\nstd::string ASpell::getEffects() const\n{\n\treturn (_effects);\n}\n\nvoid ASpell::launch(const ATarget &target) const\n{\n\ttarget.getHitBySpell(*this);\n}\n\n```\n### Code ASpell.hpp:\n```c++\n#pragma once\n\n#include <iostream>\n#include <string>\n#include \"ATarget.hpp\"\n\nclass\tATarget;\n\nclass\tASpell\n{\n\tpublic:\n\t\tASpell();\n\t\tASpell(const std::string &name, const std::string &effects);\n\t\tASpell(const ASpell &src);\n\t\tASpell& operator=(const ASpell &src);\n\t\tvirtual ~ASpell();\n\n\t\tstd::string getName() const;\n\t\tstd::string getEffects() const;\n\t\tvirtual ASpell* clone() const = 0;\n\n\t\tvoid launch(const ATarget &target) const;\n\n\tprotected:\n\t\tstd::string _name;\n\t\tstd::string _effects;\n};\n```\n### Code ATarget.cpp:\n```c++\n#include \"ATarget.hpp\"\n\nATarget::ATarget()\n{\n}\n\nATarget::ATarget(const std::string &type)\n: _type(type)\n{\n}\n\nATarget::ATarget(const ATarget &src)\n{\n\t_type = src._type;\n}\n\nATarget& ATarget::operator=(const ATarget &src)\n{\n\tif (this != &src)\n\t\t_type = src._type;\n\treturn (*this);\n}\n\nATarget::~ATarget()\n{\n}\n\nconst std::string& ATarget::getType() const\n{\n\treturn (_type);\n}\n\nvoid ATarget::getHitBySpell(const ASpell &spell) const\n{\n\tstd::cout << _type << \" has been \" << spell.getEffects() << \"!\" << std::endl;\n}\n```\n### Code ATarget.hpp:\n```c++\n#pragma once\n\n#include <iostream>\n#include <string>\n#include \"ASpell.hpp\"\n\nclass\tASpell;\n\nclass\tATarget\n{\n\tpublic:\n\t\tATarget();\n\t\tATarget(const std::string &type);\n\t\tATarget(const ATarget &src);\n\t\tATarget& operator=(const ATarget &src);\n\t\tvirtual ~ATarget();\n\n\t\tconst std::string &getType() const;\n\t\tvirtual ATarget* clone() const = 0;\n\t\n\t\tvoid getHitBySpell(const ASpell &spell) const;\n\n\tprotected:\n\t\tstd::string _type;\n};\n```\n### Code Fwoosh.cpp:\n```c++\n#include \"Fwoosh.hpp\"\n\nFwoosh::Fwoosh()\n: ASpell(\"Fwoosh\", \"fwooshed\")\n{\t\n}\n\nFwoosh::~Fwoosh()\n{\n}\n\nFwoosh* Fwoosh::clone() const\n{\n\treturn (new Fwoosh());\n}\n```\n### Code Fwoosh.hpp:\n```c++\n#pragma once\n\n#include \"ASpell.hpp\"\n\nclass\tFwoosh : public ASpell\n{\n\tpublic:\n\t\tFwoosh();\n\t\t~Fwoosh();\n\t\tvirtual Fwoosh* clone() const;\n};\n```\n### Code Fireball.cpp:\n```c++\n#include \"Fireball.hpp\"\n\nFireball::Fireball()\n: ASpell(\"Fireball\", \"burnt to a crisp\")\n{\n}\n\nFireball::~Fireball()\n{\n}\n\nFireball* Fireball::clone() const\n{\n\treturn (new Fireball());\n}\n```\n### Code Fireball.hpp:\n```c++\n#pragma once\n\n#include \"ASpell.hpp\"\n\nclass\tFireball : public ASpell\n{\n\tpublic:\n\t\tFireball();\n\t\t~Fireball();\n\t\tvirtual Fireball* clone() const;\n};\n```\n### Code Polymorph.cpp:\n```c++\n#include \"Polymorph.hpp\"\n\nPolymorph::Polymorph()\n: ASpell(\"Polymorph\", \"turned into a critter\")\n{\n}\n\nPolymorph::~Polymorph()\n{\n}\n\nPolymorph* Polymorph::clone() const\n{\n\treturn (new Polymorph());\n}\n```\n### Code Polymorph.hpp:\n```c++\n#pragma once\n\n#include \"ASpell.hpp\"\n\nclass\tPolymorph : public ASpell\n{\n\tpublic:\n\t\tPolymorph();\n\t\t~Polymorph();\n\t\tvirtual Polymorph* clone() const;\n};\n```\n### Code BrickWall.cpp:\n```c++\n#include \"BrickWall.hpp\"\n\nBrickWall::BrickWall()\n: ATarget(\"Inconspicuous Red-brick Wall\")\n{\n}\n\nBrickWall::~BrickWall()\n{\n}\n\nBrickWall* BrickWall::clone() const\n{\n\treturn (new BrickWall());\n}\n\n```\n### Code BrickWall.hpp:\n```c++\n#pragma once\n\n#include \"ATarget.hpp\"\n\nclass\tBrickWall : public ATarget\n{\n\tpublic:\n\t\tBrickWall();\n\t\t~BrickWall();\n\t\tvirtual BrickWall* clone() const;\n};\n```\n### Code SpellBook.cpp:\n```c++\n#include \"SpellBook.hpp\"\n\nSpellBook::SpellBook()\n{\n}\n\nSpellBook::SpellBook(const SpellBook &src)\n{\n\t(void)src;\n}\n\nSpellBook& SpellBook::operator=(const SpellBook &src)\n{\n\t(void)src;\n\treturn (*this);\n}\n\nSpellBook::~SpellBook()\n{\n\tfor (std::map<std::string, ASpell*>::iterator it = _Book.begin(); it != _Book.end(); it++)\n\t\tdelete it->second;\n\t_Book.clear();\n}\n\nvoid\tSpellBook::learnSpell(ASpell *Spell)\n{\n\tif (_Book.find(Spell->getName()) == _Book.end())\n\t\t_Book[Spell->getName()] = Spell->clone();\n}\n\nvoid\tSpellBook::forgetSpell(const std::string &spellname)\n{\n\tfor (std::map<std::string, ASpell*>::iterator it = _Book.begin(); it != _Book.end(); it++)\n\t{\n\t\tif (it->first == spellname)\n\t\t\tdelete it->second;\n\t}\n}\n\nASpell*\tSpellBook::createSpell(const std::string &spellname)\n{\n\tfor (std::map<std::string, ASpell*>::iterator it = _Book.begin(); it != _Book.end(); it++)\n\t{\n\t\tif (it->first == spellname)\n\t\t\treturn(it->second->clone());\n\t}\n\treturn (NULL);\n}\n\nconst std::map<std::string, ASpell*>&\tSpellBook::getBook() const\n{\n\treturn (_Book);\n}\n```\n### Code SpellBook.hpp:\n```c++\n#pragma once\n\n#include <iostream>\n#include <string>\n#include <map>\n#include \"ASpell.hpp\"\n\nclass\tSpellBook\n{\n\tpublic:\n\t\tSpellBook();\n\t\t~SpellBook();\n\n\t\tvoid learnSpell(ASpell *Spell);\n\t\tvoid forgetSpell(const std::string &spellname);\n\t\tASpell* createSpell(const std::string &spellname);\n\n\t\tconst std::map<std::string, ASpell*>& getBook() const;\n\t\n\tprivate:\n\t\tstd::map<std::string, ASpell*> _Book;\n\t\n\t\tSpellBook(const SpellBook &src);\n\t\tSpellBook& operator=(const SpellBook &src);\n};\n```\n### Code TargetGenerator.cpp:\n```c++\n#include \"TargetGenerator.hpp\"\n\nTargetGenerator::TargetGenerator()\n{\n}\n\nTargetGenerator::TargetGenerator(const TargetGenerator &src)\n{\n\t(void)src;\n}\n\nTargetGenerator& TargetGenerator::operator=(const TargetGenerator &src)\n{\n\t(void)src;\n\treturn (*this);\n}\n\nTargetGenerator::~TargetGenerator()\n{\n\tfor (std::map<std::string, ATarget*>::iterator it = _list.begin(); it != _list.end(); it++)\n\t\tdelete it->second;\n\t_list.clear();\n}\n\nvoid\tTargetGenerator::learnTargetType(ATarget *target)\n{\n\tif (_list.find(target->getType()) == _list.end())\n\t\t_list[target->getType()] = target->clone();\n}\n\nvoid\tTargetGenerator::forgetTargetType(const std::string &targettype)\n{\n\tfor (std::map<std::string, ATarget*>::iterator it = _list.begin(); it != _list.end(); it++)\n\t{\n\t\tif (it->first == targettype)\n\t\t\tdelete it->second;\n\t}\n}\n\nATarget*\tTargetGenerator::createTarget(const std::string &targettype)\n{\n\tif (_list.find(targettype) != _list.end())\n\t\treturn (_list[targettype]->clone());\n\treturn (NULL);\n}\n```\n### Code TargetGenerator.hpp:\n```c++\n#pragma once\n\n#include <iostream>\n#include <string>\n#include <map>\n#include \"ATarget.hpp\"\n\nclass\tTargetGenerator\n{\n\tpublic:\n\t\tTargetGenerator();\n\t\t~TargetGenerator();\n\n\t\tvoid learnTargetType(ATarget *target);\n\t\tvoid forgetTargetType(const std::string &targettype);\n\t\tATarget* createTarget(const std::string &targettype);\n\n\tprivate:\n\t\tstd::map<std::string, ATarget*>\t_list;\n\n\t\tTargetGenerator(const TargetGenerator &src);\n\t\tTargetGenerator& operator=(const TargetGenerator &src);\n};\n```\n### Code main.cpp\n```c++\n#include \"Warlock.hpp\"\n#include \"ASpell.hpp\"\n#include \"ATarget.hpp\"\n#include \"Fwoosh.hpp\"\n#include \"Dummy.hpp\"\n#include \"Fireball.hpp\"\n#include \"Polymorph.hpp\"\n#include \"BrickWall.hpp\"\n#include \"SpellBook.hpp\"\n#include \"TargetGenerator.hpp\"\n\nint main()\n{\n  Warlock richard(\"Richard\", \"foo\");\n  richard.setTitle(\"Hello, I'm Richard the Warlock!\");\n  BrickWall model1;\n\n  Polymorph* polymorph = new Polymorph();\n  TargetGenerator tarGen;\n\n  tarGen.learnTargetType(&model1);\n  richard.learnSpell(polymorph);\n\n  Fireball* fireball = new Fireball();\n\n  richard.learnSpell(fireball);\n\n  ATarget* wall = tarGen.createTarget(\"Inconspicuous Red-brick Wall\");\n\n  richard.introduce();\n  richard.launchSpell(\"Polymorph\", *wall);\n  richard.launchSpell(\"Fireball\", *wall);\n}\n```"
          },
          "yes_no": false,
          "separator": false,
          "type": "mandatory"
        }
      ],
      "bonusSections": [],
      "gradingOptions": [
        {
          "ok": false,
          "outstanding": false,
          "empty_work": false,
          "incomplete_work": false,
          "invalid_compilation": false,
          "norme": false,
          "cheat": false,
          "crash": false,
          "concerning_situations": false,
          "leaks": false,
          "forbidden_functions": false,
          "cannot_support": false
        }
      ],
      "languages": [
        "EN",
        "FR"
      ],
      "language": "EN",
      "introduction": {
        "FR": "# Avant l'exam\nLes exams ont une durée de 3H. Ils sont théoriquement disponibles 2 fois par semaine :\n\n- Une session le mardi matin de 10h à 13h\n- Une deuxième le jeudi soir de 16h à 19h\n\nCependant ces dates peuvent être amenées à être modifiées selon les contraintes de la vie de l'école et du staff (piscine, events, etc...). Les événements disponibles sur votre intra font foi !\n\nLe cluster est précisé dans l'event de l'intra.\n\nVous devez toujours vous inscrire à l'évènement ET au projet.\n\nIl n'est pas possible de venir travailler en cluster d'examen sur un de ses projets pendant le déroulement d'un exam. Les tuteurs et tutrices sont responsables de la gestion de l'examen, et peuvent à tout moment vous demander de quitter le cluster si vous n'êtes pas inscrits à l'exam. \n\n---\n\n# Pendant l'exam\n\n- Si vous avez changé de mot de passe intra entre votre inscription et le début de l'exam, il faut utiliser votre ancien mot de passe.\n- Si votre exercice est faux, vous devez retenter le même exercice et cela jusqu'à sa validation.\n- Le temps entre chaque commande grademe devient incremental (suivant la suite de fibonnacci 1,2,3,5,8,13 etc.). Attention à bien tester avant de faire un grademe.",
        "EN": "# Before the exam\nExams last 3 hours. They are theoretically available twice a week:\n\n- One session on Tuesday morning from 10 a.m. to 1 p.m.\n- A second on Thursday evening from 4 p.m. to 7 p.m.\n\nHowever, these dates may be subject to change depending on the constraints of school life and staff (swimming pool, events, etc.). The events available on your intra are authoritative!\n\nThe cluster is specified in the intra event.\n\nYou must always register for the event AND the project.\n\nIt is not possible to come and work in an exam cluster on one of its projects during an exam. Tutors are responsible for managing the exam, and may ask you to leave the cluster at any time if you are not registered for the exam.\n\n---\n\n# During the exam\n\n- If you have changed your intra password between your registration and the start of the exam, you must use your old password.\n- If your exercise is wrong, you must try the same exercise again until it is validated.\n- The time between each grademe command becomes incremental (following the Fibonacci sequence 1,2,3,5,8,13 etc.). Be sure to test well before doing a grademe."
      },
      "guidelines": {
        "FR": "# Règles Exams Machine\n`\nTout manquement à l'une des règles suivantes entraînera l'exclusion de l'examen, la note -42 et pourra être suivi de sanction supplémentaire.\n`\n\n- L'entrée s'effectue dans le calme et sans précipitation.\n\n- A l'entrée, vous devrez présenter votre carte aux API, sans carte l'accès à la session d'examen vous sera refusé.\n\n- Il est interdit de se connecter sur sa session personnelle dans le cluster réservé pour l'exam, après y être entré et avant en être sorti.\n\n- Vous devez vous utiliser le login exam et le password exam.\n\n- Une fois l'examen commencé, il est interdit de rentrer dans la salle. Aucun retardataire ne sera admis.\n\n- Les téléphones, montres connectées et autres objets (connectés ou non) sont interdits, ils devront être éteint et rangé dans les sacs ou déposés dans la boîte à l'entrée du cluster. Pas en silencieux. Éteints.\n\n- Les écouteurs, filaires ou non, sont des objets connectés et doivent être rangés dans les sacs. Pas dans les poches, ni dans les oreilles.\n\n- Vous n'êtes autorisés à garder aucun objet sur vous (Ni dans vos poches). Sont uniquement autorisés sur votre bureau :\n  - Papier (3 feuilles max)\n  - un et un seul stylo/crayon\n  - une montre mécanique (== avec des aiguilles et rien d'autre)\n  - mouchoirs\n  - boule quiès\n\n- Les sacs et manteaux devront être déposés à l'endroit indiqué par les API.\n- Il est interdit de les déposer devant les extincteurs, sous les oeuvres et bouches d'aération.\n- Les cartes d'étudiant·e·s doivent être posées en évidence sur les tables.\n- Vos poches doivent être vides. Tout autre objet trouvé sur vous entraîne une suspicion de triche.\n- Tout périphérique personnel connecté (clavier, souris, etc) sont interdits en examen.\n- Vous avez le droit uniquement à des feuilles vierges volantes en guise de brouillon (pas de carnet), à un stylo ou un crayon, ainsi qu'une bouteille d'eau fermée au sol. Si vous avez besoin d'objets supplémentaires concernant votre santé, prévenez l'un de vos surveillants.\n- Vos feuilles doivent être vierges jusqu'au début de l'examen. Vous n'avez pas le droit de coder avant le début de l'examen.\n- Toute tentative de communication avec d'autres étudiant·e·s que ce soit oral, écrit ou autre est prohibée, ce sera considéré comme une tentative de triche et entrainera une sortie d'exam.\n- Il est interdit de se connecter avec les identifiants d'un autre étudiant.\n- Vous devez désactiver le son de vos iMac dès votre arrivée, une fois l'examen commencé toute personne faisant \"sonner\" volontairement son mac sera exclue de l'examen sans avertissement préalable.\n- Il est interdit de se déplacer, sauf pour quitter la session d'examen.\n- Les API ainsi que leurs décisions doivent être respectés.\n- Si vous souhaitez aller aux toilettes, vous devrez attendre qu'un API fasse une annonce. En cas d'extrême urgence, levez vous et attendez un API pour lui demander. Si vous êtes malade, prévenez l'un des surveillants.\n- Pour toute question, vous devrez vous LEVER ET ATTENDRE un API.\n- Les règles générales des clusters s'appliquent aux examens.\n- Vérifiez que vous n'oubliez rien en sortant, les cartes oubliées seront à récupérer au bocal, le reste sera rapporté aux objets trouvés.\n- Une fois l'examen terminé merci de faire preuve de respect en rangeant sa chaise, son clavier, sa souris et ses feuilles de brouillon, de déconnecter la session ouverte sur le poste et de sortir en silence.\n- Si vous avez des besoins spéciaux et que le staff a été mis au courant dites le dès le début aux surveillants.\n\n---\n**LES INFRACTIONS SUIVANTES ENTRAÎNERONT AUTOMATIQUEMENT, AU MOINS, UNE EXCLUSION DE L'EXAMEN:**\n- Communication orale/autre à qui que ce soit, même à soi même\n- Tout objet sur vous (sauf liste au dessus)\n- Appareil électronique allumé dans un sac\n- Se connecter avec l'identifiant d'un.e autre étudiant.e\n- Regarder un autre écran que le sien\n- Brouillon non vierge avant le début de l'examen\n- Commencer à coder avant le début de l'examen\n- Multiple récidive d'une même infraction\n- Le non-respect des gestes barrières contre le COVID en salle d'exam.",
        "EN": "# Machine Exams Rules\n`\nAny failure to comply with one of the following rules will result in exclusion from the exam, a mark of -42 and may be followed by additional sanctions.\n`\n\n- Entry must be done calmly and without rushing.\n\n- Upon entry, you will have to present your card to the APIs, without a card access to the exam session will be refused.\n\n- It is forbidden to connect to your personal session in the cluster reserved for the exam, after entering it and before leaving it.\n\n- You must use the exam login and the exam password.\n\n- Once the exam has started, it is forbidden to enter the room. No latecomers will be allowed.\n\n- Telephones, connected watches and other objects (connected or not) are prohibited, they must be switched off and stored in bags or placed in the box at the entrance to the cluster. Not in silent mode. Switched off.\n\n- Headphones, wired or not, are connected objects and must be stored in bags. Not in pockets, nor in ears.\n\n- You are not allowed to keep any objects on you (Nor in your pockets). Only the following are allowed on your desk:\n - Paper (3 sheets max)\n - one and only one pen/pencil\n - a mechanical watch (== with hands and nothing else)\n - handkerchiefs\n - earplugs\n\n- Bags and coats must be left in the place indicated by the APIs.\n- It is forbidden to place them in front of fire extinguishers, under works of art and ventilation openings.\n- Student cards must be placed visibly on the tables.\n- Your pockets must be empty. Any other object found on you will lead to suspicion of cheating.\n- Any personal connected device (keyboard, mouse, etc.) is prohibited in the exam.\n- You are only entitled to blank sheets of paper as a draft (no notebook), a pen or pencil, as well as a closed bottle of water on the floor. If you need additional items regarding your health, please notify one of your supervisors.\n- Your sheets must be blank until the start of the exam. You are not allowed to code before the start of the exam.\n- Any attempt to communicate with other students whether oral, written or otherwise is prohibited, this will be considered as an attempt to cheat and will result in an exam exit.\n- It is forbidden to connect with the identifiers of another student.\n- You must turn off the sound of your iMac as soon as you arrive, once the exam has started anyone who voluntarily makes their mac \"ring\" will be excluded from the exam without prior warning.\n- It is forbidden to move around, except to leave the exam session.\n- APIs and their decisions must be respected.\n- If you wish to go to the toilet, you will have to wait for an API to make an announcement. In case of extreme urgency, get up and wait for an API to ask him. If you are sick, notify one of the supervisors.\n- For any question, you will have to GET UP AND WAIT for an API.\n- The general rules of the clusters apply to exams.\n- Check that you don't forget anything when leaving, forgotten cards will have to be picked up at the bocal, the rest will be reported to the lost and found.\n- Once the exam is over, please show respect by tidying up your chair, keyboard, mouse and draft sheets, disconnecting the session open on the computer and leaving in silence.\n- If you have special needs and the staff has been informed, tell the supervisors from the beginning.\n\n---\n**THE FOLLOWING INFRACTIONS WILL AUTOMATICALLY RESULT IN, AT LEAST, EXCLUSION FROM THE EXAM:**\n- Oral/other communication to anyone, even to oneself\n- Any object on you (except list above)\n- Electronic device switched on in a bag\n- Connecting with the identifier of another student\n- Looking at another screen than your own\n- Non-blank draft before the start of the exam\n- Starting to code before the start of the exam\n- Multiple recidivism of the same offense\n- Failure to comply with barrier gestures against COVID in the exam room."
      }
    }
  ],
  "message": "Sheet created successfully"
}